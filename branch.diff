diff --git a/.clang-format b/.clang-format
index 894ada4ede..e3a7f137eb 100644
--- a/.clang-format
+++ b/.clang-format
@@ -28,6 +28,7 @@ IndentCaseLabels: false
 DerivePointerAlignment: false
 SpaceAfterTemplateKeyword: false
 SpacesBeforeTrailingComments: 1
+PackConstructorInitializers: Never
 # StatementMacros don't require a trailing semicolon.
 # Trailing semicolons should be omitted after these macros
 # when compiling with -Wpedantic to avoid warnings.
diff --git a/.codespellignore b/.codespellignore
index 60f9f40700..dfabf7450f 100644
--- a/.codespellignore
+++ b/.codespellignore
@@ -7,3 +7,7 @@ doubleClick
 sur
 jus
 caf
+ReflectIn
+bufferIn
+indexIn
+allLocations
diff --git a/.codespellignorelines b/.codespellignorelines
index 993aef1b45..bd75111c83 100644
--- a/.codespellignorelines
+++ b/.codespellignorelines
@@ -73,3 +73,4 @@ void EngineEffectsDelay::process(CSAMPLE* pInOut,
         QStringLiteral("caf"),
 void EngineFilter::process(CSAMPLE* pInOut, const int iBufferSize)
     // Note(RRyan/Max Linke):
+    // https://github.com/codders/libshout/blob/a17fb84671d3732317b0353d7281cc47e2df6cf6/src/timing/timing.c
diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index 7158b9f55f..ba20fa5c41 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -473,7 +473,7 @@ jobs:
 
       - name: "Upload GitHub Actions artifacts"
         if: matrix.artifacts_path != null
-        uses: actions/upload-artifact@v4.3.4
+        uses: actions/upload-artifact@v4.3.6
         with:
           name: ${{ matrix.artifacts_name }}
           path: ${{ matrix.artifacts_path }}
diff --git a/.github/workflows/pre-commit.yml b/.github/workflows/pre-commit.yml
index c849c188ae..e692ef901d 100644
--- a/.github/workflows/pre-commit.yml
+++ b/.github/workflows/pre-commit.yml
@@ -67,14 +67,14 @@ jobs:
 
       - name: "Upload patch artifact"
         if: failure() && env.UPLOAD_PATCH_FILE != null
-        uses: actions/upload-artifact@v4.3.4
+        uses: actions/upload-artifact@v4.3.6
         with:
           name: ${{ env.UPLOAD_PATCH_FILE }}
           path: ${{ env.UPLOAD_PATCH_FILE }}
 
       - name: "Upload pre-commit.log"
         if: failure() && env.UPLOAD_PATCH_FILE == null
-        uses: actions/upload-artifact@v4.3.4
+        uses: actions/upload-artifact@v4.3.6
         with:
           name: pre-commit.log
           path: /github/home/.cache/pre-commit/pre-commit.log
diff --git a/.markdownlint-cli2.yaml b/.markdownlint-cli2.yaml
index e42d18e03d..40f100b0b6 100644
--- a/.markdownlint-cli2.yaml
+++ b/.markdownlint-cli2.yaml
@@ -8,8 +8,8 @@ config:
 
   # The same headline in different nested sections is okay (and necessary for
   # CHANGELOG.md).
-  no-duplicate-header:
-    allow_different_nesting: true
+  no-duplicate-heading:
+    siblings_only: true
 
   # We use ordered lists to make stuff easier to read in a text editor.
   ol-prefix:
diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml
index 852bc3a8b7..39f2b52fcd 100644
--- a/.pre-commit-config.yaml
+++ b/.pre-commit-config.yaml
@@ -32,7 +32,7 @@ default_language_version:
   rust: 1.64.0
 repos:
   - repo: https://github.com/pre-commit/pre-commit-hooks
-    rev: v4.4.0
+    rev: v4.6.0
     hooks:
       - id: fix-byte-order-marker
         exclude: ^.*(\.cbproj|\.groupproj|\.props|\.sln|\.vcxproj|\.vcxproj.filters|UTF-8-BOM.txt)$
@@ -51,7 +51,7 @@ repos:
         # protect main and any branch that has a semver-like name
         args: [-b, main, -p, '^\d+\.\d+(?:\.\d+)?$']
   - repo: https://github.com/codespell-project/codespell
-    rev: v2.2.5
+    rev: v2.3.0
     hooks:
       - id: codespell
         args:
@@ -66,7 +66,7 @@ repos:
           ]
         exclude: ^(packaging/wix/LICENSE.rtf.in|src/dialog/dlgabout\.cpp|.*\.(?:pot?|(?<!d\.)ts|wxl|svg))$
   - repo: https://github.com/pre-commit/mirrors-eslint
-    rev: v8.48.0
+    rev: v9.8.0
     hooks:
       - id: eslint
         args: [--fix, --report-unused-disable-directives]
@@ -96,35 +96,35 @@ repos:
           - clang-format==16.0.6
         files: \.(c|cc|cxx|cpp|frag|glsl|h|hpp|hxx|ih|ispc|ipp|java|m|mm|proto|vert)$
   - repo: https://github.com/psf/black
-    rev: 23.7.0
+    rev: 24.4.2
     hooks:
       - id: black
         files: ^tools/.*$
   - repo: https://github.com/pycqa/flake8
-    rev: "6.1.0"
+    rev: "7.1.0"
     hooks:
       - id: flake8
         files: ^tools/.*$
         types: [text, python]
   - repo: https://github.com/shellcheck-py/shellcheck-py
-    rev: v0.9.0.5
+    rev: v0.10.0.1
     hooks:
       - id: shellcheck
   - repo: https://github.com/DavidAnson/markdownlint-cli2
-    rev: v0.9.2
+    rev: v0.13.0
     hooks:
       - id: markdownlint-cli2
   - repo: https://github.com/python-jsonschema/check-jsonschema
-    rev: 0.26.3
+    rev: 0.29.1
     hooks:
       - id: check-github-workflows
   - repo: https://github.com/pre-commit/mirrors-prettier
-    rev: v3.0.2
+    rev: v4.0.0-alpha.8
     hooks:
       - id: prettier
         types: [yaml]
   - repo: https://github.com/qarmin/qml_formatter.git
-    rev: 0.2.0
+    rev: 37c2513b1b8275a475a160ed2f5b044910335d5f # No release tag yet including #6 fix
     hooks:
       - id: qml_formatter
   - repo: local
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5779e89a51..81b9a91587 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -46,6 +46,8 @@
 * Waveforms: Allshader RGB, Filtered and Stacked Waveforms using textures for waveform data
   [#13151](https://github.com/mixxxdj/mixxx/pull/13151)
   [#12641](https://github.com/mixxxdj/mixxx/issues/12641)
+* Allow changing the waveform overview type without reloading the skin
+  [#13273](https://github.com/mixxxdj/mixxx/pull/13273)
 
 ### Skins / Interface
 
@@ -116,6 +118,9 @@
 * Effect Meta knob: Draw arc from default meta position
   [#12638](https://github.com/mixxxdj/mixxx/pull/12638)
   [#12634](https://github.com/mixxxdj/mixxx/issues/12634)
+* Show newly added effects, read/write HiddenEffects
+  [#13326](https://github.com/mixxxdj/mixxx/pull/13326)
+  [#11343](https://github.com/mixxxdj/mixxx/issues/11343)
 
 ### Library
 
@@ -124,6 +129,7 @@
 * Playlists: move tracks with Alt + Up/Down/PageUp/PageDown/Home/End
   [#13092](https://github.com/mixxxdj/mixxx/pull/13092)
   [#10826](https://github.com/mixxxdj/mixxx/issues/10826)
+  [#13098](https://github.com/mixxxdj/mixxx/pull/13098)
 * Search: Add special BPM filters
   [#12072](https://github.com/mixxxdj/mixxx/pull/12072)
   [#8191](https://github.com/mixxxdj/mixxx/issues/8191)
@@ -162,10 +168,10 @@
 * Track menu: add star rating
   [#12700](https://github.com/mixxxdj/mixxx/pull/12700)
   [#10652](https://github.com/mixxxdj/mixxx/issues/10652)
-* Playlists: move tracks with Alt + Up/Down/PageUp/PageDown/Home/End
-  [#13092](https://github.com/mixxxdj/mixxx/pull/13092)
-  [#10826](https://github.com/mixxxdj/mixxx/issues/10826)
+* Track menu: Show Properties in Missing and Hidden view [#13426](https://github.com/mixxxdj/mixxx/pull/13426)
 * Library control: make use of WLibrary::getCurrentTrackTableView() [#13335](https://github.com/mixxxdj/mixxx/pull/13335)
+* Optimize Library scrolling in BPMDelegate::paintItem [#13358](https://github.com/mixxxdj/mixxx/pull/13358)
+* Library: fix font reset in multiline comment editor [#13448](https://github.com/mixxxdj/mixxx/pull/13448)
 
 ### Preferences
 
@@ -180,6 +186,7 @@
 
 ### Controller Mappings
 
+* Numark Scratch: Add controller settings  [#13404](https://github.com/mixxxdj/mixxx/pull/13404)
 * Pioneer DDJ-FLX4: Mapping improvements [#12842](https://github.com/mixxxdj/mixxx/pull/12842)
 * Traktor S4 MK3: Add setting definition for  [#12995](https://github.com/mixxxdj/mixxx/pull/12995)
 * Traktor S4 MK3: Software mixer support and default pad layout customisation [#13059](https://github.com/mixxxdj/mixxx/pull/13059)
@@ -256,7 +263,8 @@
 * Introduce wrapper for non const iterators for erase and insert [#12201](https://github.com/mixxxdj/mixxx/pull/12201)
 * Fix Qt6/QML build [#12255](https://github.com/mixxxdj/mixxx/pull/12255)
 * Fix track color background with Qt6 [#12380](https://github.com/mixxxdj/mixxx/pull/12380)
-* multi-line delegate: fix bg color, Qt6 on Linux [#12478](https://github.com/mixxxdj/mixxx/pull/12478)
+* multi-line delegate: fix bg color, Qt6 on Linux
+  [#12478](https://github.com/mixxxdj/mixxx/pull/12478)
 * Revert "BaseTrackPlayer: Remove references to WaveformWidgetRenderer when using Qt6" [#12342](https://github.com/mixxxdj/mixxx/pull/12342)
 * Fix: Replace deprecated `qAsConst` with `std::as_const` [#13028](https://github.com/mixxxdj/mixxx/pull/13028)
 * Fix Drag'n'drop: avoid unintended drag on hover (WTrackProperty, WCoverArt etc.)
@@ -275,7 +283,13 @@
 * SoundManager: Use correct PortAudio backend on iOS [#12716](https://github.com/mixxxdj/mixxx/pull/12716)
 * DesktopHelper: Add openUrl abstraction to support iOS [#12698](https://github.com/mixxxdj/mixxx/pull/12698)
 * iOS packaging: Add Info.plist, launch screen and app icon [#12676](https://github.com/mixxxdj/mixxx/pull/12676)
-* CmdlineArgs: Move config directory to a user-accessible location on iOS [#12688](https://github.com/mixxxdj/mixxx/pull/12688)
+* CmdlineArgs: Move config directory to a user-accessible location on iOS
+  [#12688](https://github.com/mixxxdj/mixxx/pull/12688)
+* CMakeLists: Work around Qt shader bug with Xcode
+  [#13379](https://github.com/mixxxdj/mixxx/pull/13379)
+  [#13378](https://github.com/mixxxdj/mixxx/issues/13378)
+* AudioUnitManager: Disable unavailable in-process instantiation on iOS
+  [#13383](https://github.com/mixxxdj/mixxx/pull/13383)
 
 ### Experimental WebAssembly support
 
@@ -300,6 +314,10 @@
 * README: Recommend running buildenvs over sourcing them on Linux [#13071](https://github.com/mixxxdj/mixxx/pull/13071)
 * FindSndFile: Link mpg123 in static builds [#13087](https://github.com/mixxxdj/mixxx/pull/13087)
 * macOS packaging: Enable app sandbox in ad-hoc-packaged (i.e. non-notarized) bundles too [#12101](https://github.com/mixxxdj/mixxx/pull/12101)
+* Drop support for macOS versions earlier than 11
+* Drop support for Windows versions earlier than Windows 10 build 1809
+* Drop support for Ubuntu versions earlier than 22.04
+* Require a C++20 compiler
 
 ### Misc Refactorings
 
@@ -344,6 +362,8 @@
 * Code Style: Add branches around single line blocks. [#13097](https://github.com/mixxxdj/mixxx/pull/13097)
 * Add missing member in copy ctor [#13229](https://github.com/mixxxdj/mixxx/pull/13229)
 * Refactor/preferences enums [#12798](https://github.com/mixxxdj/mixxx/pull/12798)
+* localDateTimeFromUtc: Make argument a const reference and initialize QDateTime at construction [#13359](https://github.com/mixxxdj/mixxx/pull/13359)
+* use enum class for waveform overview type [#13370](https://github.com/mixxxdj/mixxx/pull/13370)
 * Update to latest vcpkg dependencies
   [#11649](https://github.com/mixxxdj/mixxx/pull/11649)
   [#12512](https://github.com/mixxxdj/mixxx/pull/12512)
@@ -398,7 +418,9 @@
   [#13196](https://github.com/mixxxdj/mixxx/pull/13196)
   [#13134](https://github.com/mixxxdj/mixxx/issues/13134)
 * Numark PartyMix: Fix EQ (script binding) display name [#13255](https://github.com/mixxxdj/mixxx/pull/13255)
-* Numark Scratch: Add initial mapping [#4834](https://github.com/mixxxdj/mixxx/pull/4834)
+* Numark Scratch: Add initial mapping
+  [#4834](https://github.com/mixxxdj/mixxx/pull/4834)
+  [#13375](https://github.com/mixxxdj/mixxx/pull/13375)
 * Sony SIXAXIS: Fix mapping [#13319](https://github.com/mixxxdj/mixxx/pull/13319)
 
 ### Fixes
@@ -432,6 +454,10 @@
 * Hardware preferences: Fix UX when applying config with missing/busy devices
   [#13312](https://github.com/mixxxdj/mixxx/pull/13312)
 * Fix minor 64 bit CPU performance issue [#13355](https://github.com/mixxxdj/mixxx/pull/13355)
+* Fix clicks at loop-out when looping into lead-in [#13294](https://github.com/mixxxdj/mixxx/pull/13294)
+* Fix wrong pitch value on startup, caused by `components.Pot`
+  [#11814](https://github.com/mixxxdj/mixxx/issues/11814)
+  [#13463](https://github.com/mixxxdj/mixxx/pull/13463)
 
 ## [2.4.1](https://github.com/mixxxdj/mixxx/milestone/41?closed=1) (2024-05-08)
 
@@ -602,7 +628,7 @@
   [#4806](https://github.com/mixxxdj/mixxx/pull/4806)
   [#11873](https://github.com/mixxxdj/mixxx/pull/11873)
   [#11872](https://github.com/mixxxdj/mixxx/issues/11872)
-* Add support for overriding analyzis settings about variable/constant BPM on a per-track basis [#10931](https://github.com/mixxxdj/mixxx/pull/10931)
+* Add support for overriding analysis settings about variable/constant BPM on a per-track basis [#10931](https://github.com/mixxxdj/mixxx/pull/10931)
 * Add menu for looking up track metadata at Discogs, SoundCloud and LastFM [#4772](https://github.com/mixxxdj/mixxx/pull/4772) [#4836](https://github.com/mixxxdj/mixxx/pull/4836)
 * Add "Delete Track Files" action, does "Move to Trash" with Qt >= 5.15
   [#4560](https://github.com/mixxxdj/mixxx/pull/4560)
@@ -1436,7 +1462,7 @@
   [#11327](https://github.com/mixxxdj/mixxx/issues/11327)
 * LateNight: brighter fx parameter buttons
   [#11397](https://github.com/mixxxdj/mixxx/pull/11397)
-* Fix drift in analyzis data after exporting metadata to MP3 files with ID3v1.1 tags
+* Fix drift in analysis data after exporting metadata to MP3 files with ID3v1.1 tags
   [#11168](https://github.com/mixxxdj/mixxx/pull/11168)
   [#11159](https://github.com/mixxxdj/mixxx/issues/11159)
 * Fix broadcasting using Opus encoding
@@ -1827,7 +1853,7 @@
 * Add controller mapping for Denon MC7000 [#2546](https://github.com/mixxxdj/mixxx/pull/2546)
 * Add controller mapping for Stanton DJC.4 [#2607](https://github.com/mixxxdj/mixxx/pull/2607)
 * Fix broadcasting via broadcast/recording input [#9959](https://github.com/mixxxdj/mixxx/issues/9959) [#2743](https://github.com/mixxxdj/mixxx/pull/2743)
-* Only apply ducking gain in manual ducking mode when talkover is enabed [#7668](https://github.com/mixxxdj/mixxx/issues/7668) [#8995](https://github.com/mixxxdj/mixxx/issues/8995) [#8795](https://github.com/mixxxdj/mixxx/issues/8795) [#2759](https://github.com/mixxxdj/mixxx/pull/2759)
+* Only apply ducking gain in manual ducking mode when talkover is enabled [#7668](https://github.com/mixxxdj/mixxx/issues/7668) [#8995](https://github.com/mixxxdj/mixxx/issues/8995) [#8795](https://github.com/mixxxdj/mixxx/issues/8795) [#2759](https://github.com/mixxxdj/mixxx/pull/2759)
 * Ignore MIDI Clock Messages (0xF8) because they are not usable in Mixxx and inhibited the screensaver [#2786](https://github.com/mixxxdj/mixxx/pull/2786)
 
 ## [2.2.3](https://launchpad.net/mixxx/+milestone/2.2.3) (2019-11-24)
diff --git a/CHANGELOG.md.backup b/CHANGELOG.md.backup
index 0ed482364b..1921760d81 100644
--- a/CHANGELOG.md.backup
+++ b/CHANGELOG.md.backup
@@ -515,7 +515,7 @@
   [#4806](https://github.com/mixxxdj/mixxx/pull/4806)
   [#11873](https://github.com/mixxxdj/mixxx/pull/11873)
   [#11872](https://github.com/mixxxdj/mixxx/issues/11872)
-* Add support for overriding analyzis settings about variable/constant BPM on a per-track basis [#10931](https://github.com/mixxxdj/mixxx/pull/10931)
+* Add support for overriding analysis settings about variable/constant BPM on a per-track basis [#10931](https://github.com/mixxxdj/mixxx/pull/10931)
 * Add menu for looking up track metadata at Discogs, SoundCloud and LastFM [#4772](https://github.com/mixxxdj/mixxx/pull/4772) [#4836](https://github.com/mixxxdj/mixxx/pull/4836)
 * Add "Delete Track Files" action, does "Move to Trash" with Qt >= 5.15
   [#4560](https://github.com/mixxxdj/mixxx/pull/4560)
@@ -1349,7 +1349,7 @@
   [#11327](https://github.com/mixxxdj/mixxx/issues/11327)
 * LateNight: brighter fx parameter buttons
   [#11397](https://github.com/mixxxdj/mixxx/pull/11397)
-* Fix drift in analyzis data after exporting metadata to MP3 files with ID3v1.1 tags
+* Fix drift in analysis data after exporting metadata to MP3 files with ID3v1.1 tags
   [#11168](https://github.com/mixxxdj/mixxx/pull/11168)
   [#11159](https://github.com/mixxxdj/mixxx/issues/11159)
 * Fix broadcasting using Opus encoding
@@ -1740,7 +1740,7 @@
 * Add controller mapping for Denon MC7000 [#2546](https://github.com/mixxxdj/mixxx/pull/2546)
 * Add controller mapping for Stanton DJC.4 [#2607](https://github.com/mixxxdj/mixxx/pull/2607)
 * Fix broadcasting via broadcast/recording input [#9959](https://github.com/mixxxdj/mixxx/issues/9959) [#2743](https://github.com/mixxxdj/mixxx/pull/2743)
-* Only apply ducking gain in manual ducking mode when talkover is enabed [#7668](https://github.com/mixxxdj/mixxx/issues/7668) [#8995](https://github.com/mixxxdj/mixxx/issues/8995) [#8795](https://github.com/mixxxdj/mixxx/issues/8795) [#2759](https://github.com/mixxxdj/mixxx/pull/2759)
+* Only apply ducking gain in manual ducking mode when talkover is enabled [#7668](https://github.com/mixxxdj/mixxx/issues/7668) [#8995](https://github.com/mixxxdj/mixxx/issues/8995) [#8795](https://github.com/mixxxdj/mixxx/issues/8795) [#2759](https://github.com/mixxxdj/mixxx/pull/2759)
 * Ignore MIDI Clock Messages (0xF8) because they are not usable in Mixxx and inhibited the screensaver [#2786](https://github.com/mixxxdj/mixxx/pull/2786)
 
 ## [2.2.3](https://launchpad.net/mixxx/+milestone/2.2.3) (2019-11-24)
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7d8494b260..520c86c884 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -982,12 +982,12 @@ add_library(mixxx-lib STATIC EXCLUDE_FROM_ALL
   src/library/sidebarmodel.cpp
   src/library/starrating.cpp
   src/library/tabledelegates/bpmdelegate.cpp
+  src/library/tabledelegates/checkboxdelegate.cpp
   src/library/tabledelegates/colordelegate.cpp
   src/library/tabledelegates/coverartdelegate.cpp
   src/library/tabledelegates/keydelegate.cpp
   src/library/tabledelegates/locationdelegate.cpp
   src/library/tabledelegates/multilineeditdelegate.cpp
-  src/library/tabledelegates/playcountdelegate.cpp
   src/library/tabledelegates/previewbuttondelegate.cpp
   src/library/tabledelegates/stardelegate.cpp
   src/library/tabledelegates/stareditor.cpp
@@ -1333,6 +1333,7 @@ set(MIXXX_LIB_PRECOMPILED_HEADER
   src/control/control.h
   src/control/controlaudiotaperpot.h
   src/control/controlbehavior.h
+  src/control/controlbuttonmode.h
   src/control/controlcompressingproxy.h
   src/control/controleffectknob.h
   src/control/controlencoder.h
@@ -2554,6 +2555,13 @@ add_library(rekordbox_metadata STATIC EXCLUDE_FROM_ALL
 target_include_directories(rekordbox_metadata SYSTEM PUBLIC lib/rekordbox-metadata)
 target_link_libraries(mixxx-lib PRIVATE rekordbox_metadata)
 
+#silence "enumeration values not handled in switch" in generated code
+if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
+    target_compile_options(rekordbox_metadata PRIVATE -Wno-switch)
+elseif(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
+    target_compile_options(rekordbox_metadata PRIVATE /w44063)
+endif()
+
 # Kaitai for reading Rekordbox libraries
 add_library(Kaitai STATIC EXCLUDE_FROM_ALL
   lib/kaitai/kaitai/kaitaistream.cpp
@@ -2776,6 +2784,7 @@ if(QML)
     src/qml/qmlplayermanagerproxy.cpp
     src/qml/qmlplayerproxy.cpp
     src/qml/qmlvisibleeffectsmodel.cpp
+    src/qml/qmlchainpresetmodel.cpp
     src/qml/qmlwaveformoverview.cpp
     # The following sources need to be in this target to get QML_ELEMENT properly interpreted
     src/control/controlmodel.cpp
@@ -3457,6 +3466,7 @@ if (STEM)
     src/sources/soundsourcestem.cpp
     src/track/steminfoimporter.cpp
     src/track/steminfo.cpp
+    src/widget/wstemcontrol.cpp
   )
   if(QOPENGL)
     target_sources(mixxx-lib PRIVATE
@@ -3672,7 +3682,7 @@ else()
   check_include_file_cxx(gsl/gsl HAVE_GSL_GSL)
   if(NOT HAVE_GSL_GSL)
     unset(HAVE_GSL_GSL CACHE) # unset cache to re-evaluate this until it succeeds. check_include_file_cxx() has no REQUIRED flag.
-    message(FATAL_ERROR "ms-gsl deveopment headers (libmsgsl-dev) not found")
+    message(FATAL_ERROR "ms-gsl development headers (libmsgsl-dev) not found")
   endif()
 endif()
 
diff --git a/cmake/modules/FindTagLib.cmake b/cmake/modules/FindTagLib.cmake
index 7e907f6794..42515ac569 100644
--- a/cmake/modules/FindTagLib.cmake
+++ b/cmake/modules/FindTagLib.cmake
@@ -48,7 +48,7 @@ include(IsStaticLibrary)
 find_package(PkgConfig QUIET)
 if(PkgConfig_FOUND)
   if(UNIX AND NOT APPLE)
-    # priorize the taglib1 package introduced in https://www.archlinux.de/packages/extra/x86_64/taglib1
+    # prioritize the taglib1 package introduced in https://www.archlinux.de/packages/extra/x86_64/taglib1
     set(ENV{PKG_CONFIG_PATH} "/usr/lib/taglib1/pkgconfig/:$ENV{PKG_CONFIG_PATH}")
   endif()
   pkg_check_modules(PC_TagLib QUIET taglib)
diff --git a/packaging/CPackConfig.cmake b/packaging/CPackConfig.cmake
index 9c83d3b6a8..62c70c79fc 100644
--- a/packaging/CPackConfig.cmake
+++ b/packaging/CPackConfig.cmake
@@ -15,7 +15,7 @@ set(CPACK_PACKAGE_FILE_NAME "mixxx-${PACKAGE_VERSION}")
 set(CPACK_SOURCE_PACKAGE_FILE_NAME "${CPACK_PACKAGE_FILE_NAME}-source")
 
 # The upstream version must not contain hyphen
-# . for nomal versioning + for advance and ~ for decline the version
+# . for normal versioning + for advance and ~ for decline the version
 # dpkg --compare-versions 2.3~alpha~1234~g8163 lt 2.3~beta~1234~g8163 && echo true
 # dpkg --compare-versions 2.3~beta~1234~g8163 lt 2.3.0 && echo true
 # dpkg --compare-versions 2.3.0 lt 2.3.0+2345+g163  && echo true
diff --git a/res/controllers/Denon-MC4000-scripts.js b/res/controllers/Denon-MC4000-scripts.js
index fd272b2cb0..6989a1af41 100644
--- a/res/controllers/Denon-MC4000-scripts.js
+++ b/res/controllers/Denon-MC4000-scripts.js
@@ -117,7 +117,7 @@ MC4000.Deck = function (channel) {
     // adds this jog value to an internal 25 sample buffer, and then sets the jog value to zero.
     // The engine takes the average of the 25 sample buffer, divides by 10, and adds this to the rate at
     // which the song is playing (e.g. determined by the pitch fader). Since the effect of this depends on many factors
-    // we can only really give an empirical senstivity which makes jog work "how we like it".
+    // we can only really give an empirical sensitivity which makes jog work "how we like it".
     this.jogWheel = function (channel, control, value, status, group) {
         var numTicks = (value < 0x40) ? value: (value - 0x80);
         if (engine.isScratching(this.engineChannel)) {
diff --git a/res/controllers/Gemini-CDMP-7000-scripts.js b/res/controllers/Gemini-CDMP-7000-scripts.js
index 9cfd88320a..e87e91a57f 100644
--- a/res/controllers/Gemini-CDMP-7000-scripts.js
+++ b/res/controllers/Gemini-CDMP-7000-scripts.js
@@ -8,7 +8,7 @@
 // Changelog v1.2
 // Fixed clearing/lighting leds for hotcues if song has them set or not
 // Incorporated Pitch Ranges into Button/LCD
-// Incorprated BPM in LCD (may still not happen on first load)
+// Incorporated BPM in LCD (may still not happen on first load)
 // Updates LCD with Vinyl and Hotcue messages
 
 // ---- remaining issues
diff --git a/res/controllers/Hercules-DJ-Console-4-Mx-scripts.js b/res/controllers/Hercules-DJ-Console-4-Mx-scripts.js
index c595e7bdb2..e1d137ed11 100644
--- a/res/controllers/Hercules-DJ-Console-4-Mx-scripts.js
+++ b/res/controllers/Hercules-DJ-Console-4-Mx-scripts.js
@@ -80,7 +80,7 @@ Hercules4Mx.userSettings = {
     // Setting this setting to true, the curve will change to scratch curve when the scratch mode is on (scratch button).
     // Setting it to false will not change it, so it will use the setting configured in the DJHercules Tray-icon configuration.
     'crossfaderScratchCurve': false,
-    // _Scratching_ Playback speed of the virtual vinyl that is being scratched. 45.00 and 33.33 are the common speeeds. (Lower number equals faster scratch)
+    // _Scratching_ Playback speed of the virtual vinyl that is being scratched. 45.00 and 33.33 are the common speeds. (Lower number equals faster scratch)
     'vinylSpeed': 45,
     // _Scratching_ You should configure this setting to the same value than in the DJHercules tray icon configuration. (Normal means 1/1).
     // If crossfaderScratchCurve is true, or the setting is changed while Mixxx is active, this value will be detected automatically.
diff --git a/res/controllers/Midi_for_light-scripts.js b/res/controllers/Midi_for_light-scripts.js
index 6c6cc073d8..d55429c526 100644
--- a/res/controllers/Midi_for_light-scripts.js
+++ b/res/controllers/Midi_for_light-scripts.js
@@ -75,12 +75,12 @@ midi_for_light.init = function(id) { // called when the MIDI device is opened &
     midi_for_light.directory_mode = false;
     midi_for_light.deck_current = 0;
     midi_for_light.crossfader_block = false;
-    midi_for_light.crossfader_change_block_timer = [-1, -1];
+    midi_for_light.crossfader_change_block_timer = undefined;
     midi_for_light.volumebeat = false;
     midi_for_light.volumeBeatBlockStatus = false;
-    midi_for_light.volumeBeatBlock_timer = [-1, -1];
-    midi_for_light.vu_meter_timer = [-1, -1];
-    midi_for_light.volumebeat_on_delay_timer = [-1, -1];
+    midi_for_light.volumeBeatBlock_timer = undefined;
+    midi_for_light.vu_meter_timer = undefined;
+    midi_for_light.volumebeat_on_delay_timer = undefined;
 
     engine.connectControl("[Master]", "crossfader", "midi_for_light.crossfaderChange");
 
@@ -102,26 +102,32 @@ midi_for_light.init = function(id) { // called when the MIDI device is opened &
 };
 
 midi_for_light.shutdown = function(id) { // called when the MIDI device is closed
-    engine.stopTimer(midi_for_light.deck_beat_watchdog_timer[0]);
-    engine.stopTimer(midi_for_light.deck_beat_watchdog_timer[1]);
-    engine.stopTimer(midi_for_light.deck_beat_watchdog_timer[2]);
-    engine.stopTimer(midi_for_light.deck_beat_watchdog_timer[3]);
-    engine.stopTimer(midi_for_light.vu_meter_timer);
-    engine.stopTimer(midi_for_light.volumeBeatBlock_timer);
-    engine.stopTimer(midi_for_light.crossfader_change_block_timer);
-    engine.stopTimer(midi_for_light.volumebeat_on_delay_timer);
+    for (let i = 0; i <= 3; i++) {
+        if (deck_beat_watchdog_timer[i]) {
+            engine.stopTimer(deck_beat_watchdog_timer[i]);
+        }
+    }
+    for (const timer of ["vu_meter_timer", "volumeBeatBlock_timer", "crossfader_change_block_timer", "volumebeat_on_delay_timer"]) {
+        if (midi_for_light[timer]) {
+            engine.stopTimer(midi_for_light[timer]);
+            midi_for_light[timer] = undefined;
+        }
+    }
 };
 
 midi_for_light.deckButtonPlay = function(value, group, control) { // called when click a play button
     var deck = parseInt(group.substring(8, 9)) - 1;
 
-    if (value == 1) { // deck play on
+    if (deck_beat_watchdog_timer[deck]) {
         engine.stopTimer(deck_beat_watchdog_timer[deck]);
+    }
+
+    if (value === 1) { // deck play on
         beat_watchdog[deck] = false;
         deck_beat_watchdog_timer[deck] = engine.beginTimer(beat_watchdog_time, () => { midi_for_light.deckBeatWatchdog(deck); });
     } else { // deck play stop
-        engine.stopTimer(deck_beat_watchdog_timer[deck]);
         beat_watchdog[deck] = true;
+        deck_beat_watchdog_timer[deck] = undefined;
     }
 
     if (midi_for_light.volumebeat === true) {
@@ -133,7 +139,10 @@ midi_for_light.deckButtonPlay = function(value, group, control) { // called when
 };
 
 midi_for_light.deckBeatWatchdog = function(deck) { //  if current deck beat lost without reason, search a new current deck
-    engine.stopTimer(deck_beat_watchdog_timer[deck]);
+    if (deck_beat_watchdog_timer[deck]) {
+        engine.stopTimer(deck_beat_watchdog_timer[deck]);
+        deck_beat_watchdog_timer[deck] = undefined;
+    }
     beat_watchdog[deck] = true;
     if (midi_for_light.volumebeat === false) midi_for_light.crossfaderChange();
 };
@@ -421,24 +430,33 @@ midi_for_light.deckVolumeChange = function(value, group, control) { // deck volu
 };
 
 midi_for_light.volumeBeatBlock = function() { // prevent deck change for one second
-    engine.stopTimer(midi_for_light.volumeBeatBlock_timer);
+    if (midi_for_light.volumeBeatBlock_timer) {
+        engine.stopTimer(midi_for_light.volumeBeatBlock_timer);
+        midi_for_light.volumeBeatBlock_timer = undefined;
+    }
     midi_for_light.volumeBeatBlockStatus = false;
     midi.sendShortMsg(0x8F + midi_channel, 0x30, 0x0); // note C on with value 0
     midi.sendShortMsg(0x7F + midi_channel, 0x30, 0x0); // note C off with value 0
 };
 
 midi_for_light.volumeBeatOnDelay = function() { // allow deck change with volume after 3 second fader do nothing
-    engine.stopTimer(midi_for_light.volumebeat_on_delay_timer);
+    if (midi_for_light.volumebeat_on_delay_timer) {
+        engine.stopTimer(midi_for_light.volumebeat_on_delay_timer);
+        midi_for_light.volumebeat_on_delay_timer = undefined;
+    }
     midi_for_light.volumebeat = true;
 };
 
-midi_for_light.crossfaderChange = function() { // crossfader chenge, check deck change
+midi_for_light.crossfaderChange = function() { // crossfader change, check deck change
     // if fader prevent, go out
     if (midi_for_light.crossfader_block === true) return;
 
     // check changing to "deck change by volume" method
     midi_for_light.volumebeat = false;
-    engine.stopTimer(midi_for_light.volumebeat_on_delay_timer);
+    if (midi_for_light.volumebeat_on_delay_timer) {
+        engine.stopTimer(midi_for_light.volumebeat_on_delay_timer);
+        midi_for_light.volumebeat_on_delay_timer = undefined;
+    }
     if (engine.getValue("[Master]", "crossfader") > -0.25) { // crossfader more than 25% left;
         if (engine.getValue("[Master]", "crossfader") < 0.25) { // crossfader more then 25% right;
             midi_for_light.volumebeat_on_delay_timer = engine.beginTimer(3000, midi_for_light.volumeBeatOnDelay);
@@ -468,7 +486,10 @@ midi_for_light.crossfaderChange = function() { // crossfader chenge, check deck
 };
 
 midi_for_light.crossfaderChangeBlock = function() { // prevent deck change for one second
-    engine.stopTimer(midi_for_light.crossfader_change_block_timer);
+    if (midi_for_light.crossfader_change_block_timer) {
+        engine.stopTimer(midi_for_light.crossfader_change_block_timer);
+        midi_for_light.crossfader_change_block_timer = undefined;
+    }
     midi_for_light.crossfader_block = false;
     midi.sendShortMsg(0x8F + midi_channel, 0x30, 0x0); // note C on with value 0
     midi.sendShortMsg(0x7F + midi_channel, 0x30, 0x0); // note C off with value 0
@@ -506,7 +527,9 @@ midi_for_light.deckBeatOutputToMidi = function(value, group, control) { // send
     var deck_bpm = parseInt(engine.getValue(group, "bpm")) - 50;
 
     // reset deck beat watchdog
-    engine.stopTimer(deck_beat_watchdog_timer[deck]);
+    if (deck_beat_watchdog_timer[deck]) {
+        engine.stopTimer(deck_beat_watchdog_timer[deck]);
+    }
     beat_watchdog[deck] = false;
     deck_beat_watchdog_timer[deck] = engine.beginTimer(beat_watchdog_time, () => { midi_for_light.deckBeatWatchdog(deck); });
 
diff --git a/res/controllers/Pioneer-DDJ-200-scripts.js b/res/controllers/Pioneer-DDJ-200-scripts.js
index 6514982d87..5c9c3928ea 100644
--- a/res/controllers/Pioneer-DDJ-200-scripts.js
+++ b/res/controllers/Pioneer-DDJ-200-scripts.js
@@ -233,7 +233,7 @@ DDJ200.rateMSB = function(channel, control, value, status, group) {
 DDJ200.rateLSB = function(channel, control, value, status, group) {
     var vDeckNo = DDJ200.vDeckNo[script.deckFromGroup(group)];
     var vgroup = "[Channel" + vDeckNo + "]";
-    // calculte rate value from its most and least significant bytes
+    // calculate rate value from its most and least significant bytes
     var rateMSB = DDJ200.vDeck[vDeckNo]["rateMSB"];
     var rate = 1 - (((rateMSB << 7) + value) / 0x1FFF);
     engine.setValue(vgroup, "rate", rate);
@@ -248,7 +248,7 @@ DDJ200.volumeMSB = function(channel, control, value, status, group) {
 DDJ200.volumeLSB = function(channel, control, value, status, group) {
     var vDeckNo = DDJ200.vDeckNo[script.deckFromGroup(group)];
     var vgroup = "[Channel" + vDeckNo + "]";
-    // calculte volume value from its most and least significant bytes
+    // calculate volume value from its most and least significant bytes
     var volMSB = DDJ200.vDeck[vDeckNo]["volMSB"];
     var vol = ((volMSB << 7) + value) / 0x3FFF;
     //var vol = ((volMSB << 7) + value); // use for linear correction
diff --git a/res/controllers/Pioneer-DDJ-SB3-scripts.js b/res/controllers/Pioneer-DDJ-SB3-scripts.js
index cf50a61500..7f67183c8a 100755
--- a/res/controllers/Pioneer-DDJ-SB3-scripts.js
+++ b/res/controllers/Pioneer-DDJ-SB3-scripts.js
@@ -1538,8 +1538,10 @@ PioneerDDJSB3.Slicer.prototype.generateBeatPositions = function() {
         if (sample < this.trackSamples) {
             var bp = {
                 sample: sample,
-                positionIn: (this.PLAY_POSITION_RANGE * sample - 1) / this.trackSamples,
-                positionOut: (this.PLAY_POSITION_RANGE * nextSample - 1) / this.trackSamples,
+                position: {
+                    in: (this.PLAY_POSITION_RANGE * sample - 1) / this.trackSamples,
+                    out: (this.PLAY_POSITION_RANGE * nextSample - 1) / this.trackSamples,
+                }
             };
 
             this.beatPositions.push(bp);
@@ -1595,7 +1597,7 @@ PioneerDDJSB3.Slicer.prototype.playPositionChange = function(value) {
         for (var i = 0; i < this.beatPositions.length; i++) {
             var beatPosition = this.beatPositions[i];
 
-            if (value >= beatPosition.positionIn && value < beatPosition.positionOut) {
+            if (value >= beatPosition.position.in && value < beatPosition.position.out) {
                 this.currentBeat = i;
                 found = true;
             }
diff --git a/res/controllers/Sony-SixxAxis.js b/res/controllers/Sony-SixxAxis.js
index cffb07ce24..ba0def6e24 100644
--- a/res/controllers/Sony-SixxAxis.js
+++ b/res/controllers/Sony-SixxAxis.js
@@ -139,7 +139,7 @@ SonySixxAxis.registerCallbacks = function(id) {
         return;
     }
     if (controller==undefined) {
-        HIDDebug("Error registrering callbacks: controller is undefined");
+        HIDDebug("Error registering callbacks: controller is undefined");
         return;
     }
 
diff --git a/res/controllers/Traktor-Kontrol-S4-MK3.js b/res/controllers/Traktor-Kontrol-S4-MK3.js
index 3f3fb65fbc..cfff2d38ac 100644
--- a/res/controllers/Traktor-Kontrol-S4-MK3.js
+++ b/res/controllers/Traktor-Kontrol-S4-MK3.js
@@ -117,7 +117,7 @@ const BeatLoopRolls = [
 ];
 
 
-// Define the speed of the jogwheel. This will impact the speed of the LED playback indicator, the sratch, and the speed of
+// Define the speed of the jogwheel. This will impact the speed of the LED playback indicator, the scratch, and the speed of
 // the motor if enable. Recommended value are 33 + 1/3 or 45.
 // Default: 33 + 1/3
 const BaseRevolutionsPerMinute = engine.getSetting("baseRevolutionsPerMinute") || 33 + 1/3;
diff --git a/res/linux/org.mixxx.Mixxx.metainfo.xml b/res/linux/org.mixxx.Mixxx.metainfo.xml
index f10bef3d2c..41b9047e8b 100644
--- a/res/linux/org.mixxx.Mixxx.metainfo.xml
+++ b/res/linux/org.mixxx.Mixxx.metainfo.xml
@@ -96,7 +96,7 @@
   Do not edit it manually.
   -->
   <releases>
-    <release version="2.6.0" type="development" date="2024-06-12" timestamp="1718193546">
+    <release version="2.6.0" type="development" date="2024-08-13" timestamp="1723570900">
       <description>
  <p>
   Waveforms
@@ -153,7 +153,7 @@
  </ul>
 </description>
     </release>
-    <release version="2.5.0" type="development" date="2024-06-12" timestamp="1718193546">
+    <release version="2.5.0" type="development" date="2024-08-13" timestamp="1723570900">
       <description>
  <p>
   Waveforms
@@ -179,6 +179,10 @@
    #13151
    #12641
   </li>
+  <li>
+   Allow changing the waveform overview type without reloading the skin
+   #13273
+  </li>
  </ul>
  <p>
   Skins / Interface
@@ -336,6 +340,11 @@
    #12638
    #12634
   </li>
+  <li>
+   Show newly added effects, read/write HiddenEffects
+   #13326
+   #11343
+  </li>
  </ul>
  <p>
   Library
@@ -353,6 +362,7 @@
    Playlists: move tracks with Alt + Up/Down/PageUp/PageDown/Home/End
    #13092
    #10826
+   #13098
   </li>
   <li>
    Search: Add special BPM filters
@@ -436,14 +446,21 @@
    #10652
   </li>
   <li>
-   Playlists: move tracks with Alt + Up/Down/PageUp/PageDown/Home/End
-   #13092
-   #10826
+   Track menu: Show Properties in Missing and Hidden view
+   #13426
   </li>
   <li>
    Library control: make use of WLibrary::getCurrentTrackTableView()
    #13335
   </li>
+  <li>
+   Optimize Library scrolling in BPMDelegate::paintItem
+   #13358
+  </li>
+  <li>
+   Library: fix font reset in multiline comment editor
+   #13448
+  </li>
  </ul>
  <p>
   Preferences
@@ -480,6 +497,10 @@
   Controller Mappings
  </p>
  <ul>
+  <li>
+   Numark Scratch: Add controller settings
+   #13404
+  </li>
   <li>
    Pioneer DDJ-FLX4: Mapping improvements
    #12842
@@ -768,6 +789,15 @@
    CmdlineArgs: Move config directory to a user-accessible location on iOS
    #12688
   </li>
+  <li>
+   CMakeLists: Work around Qt shader bug with Xcode
+   #13379
+   #13378
+  </li>
+  <li>
+   AudioUnitManager: Disable unavailable in-process instantiation on iOS
+   #13383
+  </li>
  </ul>
  <p>
   Experimental WebAssembly support
@@ -861,6 +891,18 @@
    macOS packaging: Enable app sandbox in ad-hoc-packaged (i.e. non-notarized) bundles too
    #12101
   </li>
+  <li>
+   Drop support for macOS versions earlier than 11
+  </li>
+  <li>
+   Drop support for Windows versions earlier than Windows 10 build 1809
+  </li>
+  <li>
+   Drop support for Ubuntu versions earlier than 22.04
+  </li>
+  <li>
+   Require a C++20 compiler
+  </li>
  </ul>
  <p>
   Misc Refactorings
@@ -1053,6 +1095,14 @@
    Refactor/preferences enums
    #12798
   </li>
+  <li>
+   localDateTimeFromUtc: Make argument a const reference and initialize QDateTime at construction
+   #13359
+  </li>
+  <li>
+   use enum class for waveform overview type
+   #13370
+  </li>
   <li>
    Update to latest vcpkg dependencies
    #11649
@@ -1104,7 +1154,7 @@
  </ul>
 </description>
     </release>
-    <release version="2.4.2" type="development" date="2024-06-12" timestamp="1718193546">
+    <release version="2.4.2" type="development" date="2024-08-13" timestamp="1723570900">
       <description>
  <p>
   Controller Mappings
@@ -1126,6 +1176,7 @@
   <li>
    Numark Scratch: Add initial mapping
    #4834
+   #13375
   </li>
   <li>
    Sony SIXAXIS: Fix mapping
@@ -1195,6 +1246,16 @@
    Fix minor 64 bit CPU performance issue
    #13355
   </li>
+  <li>
+   Fix clicks at loop-out when looping into lead-in
+   #13294
+  </li>
+  <li>
+   Fix wrong pitch value on startup, caused by
+   components.Pot
+   #11814
+   #13463
+  </li>
  </ul>
 </description>
     </release>
@@ -1566,7 +1627,7 @@
    #11872
   </li>
   <li>
-   Add support for overriding analyzis settings about variable/constant BPM on a per-track basis
+   Add support for overriding analysis settings about variable/constant BPM on a per-track basis
    #10931
   </li>
   <li>
@@ -3550,7 +3611,7 @@
    #11397
   </li>
   <li>
-   Fix drift in analyzis data after exporting metadata to MP3 files with ID3v1.1 tags
+   Fix drift in analysis data after exporting metadata to MP3 files with ID3v1.1 tags
    #11168
    #11159
   </li>
@@ -4957,7 +5018,7 @@
    #2743
   </li>
   <li>
-   Only apply ducking gain in manual ducking mode when talkover is enabed
+   Only apply ducking gain in manual ducking mode when talkover is enabled
    #7668
    #8995
    #8795
diff --git a/res/mixxx.qrc b/res/mixxx.qrc
index 8011fe39f9..3255930ff0 100644
--- a/res/mixxx.qrc
+++ b/res/mixxx.qrc
@@ -1,25 +1,21 @@
-<!DOCTYPE RCC>
-<RCC version="1.0">
+<RCC>
     <qresource prefix="/">
         <file>../LICENSE</file>
         <file>images/library/ic_library_drag_and_drop.svg</file>
-      <!-- open/closed lock icons for BPM button -->
         <file>images/library/ic_library_locked.svg</file>
         <file>images/library/ic_library_unlocked.svg</file>
-      <!-- lock icon for crates, playlists & history -->
         <file>images/library/ic_library_locked_tracklist.svg</file>
         <file>images/library/cover_default.svg</file>
-      <!-- icons for library side bar -->
         <file>images/library/ic_library_autodj.svg</file>
         <file>images/library/ic_library_banshee.svg</file>
-        <file>images/library/ic_library_computer.svg</file> <!-- from Gnome high contrast icons LGPL 2.1 -->
+        <file>images/library/ic_library_computer.svg</file>
         <file>images/library/ic_library_crates.svg</file>
         <file>images/library/ic_library_cross_grey.svg</file>
         <file>images/library/ic_library_cross_orange.svg</file>
         <file>images/library/ic_library_history.svg</file>
         <file>images/library/ic_library_history_current.svg</file>
         <file>images/library/ic_library_itunes.svg</file>
-        <file>images/library/ic_library_tracks.svg</file> <!-- from Gnome high contrast icons LGPL 2.1 -->
+        <file>images/library/ic_library_tracks.svg</file>
         <file>images/library/ic_library_playlist.svg</file>
         <file>images/library/ic_library_prepare.svg</file>
         <file>images/library/ic_library_preview_pause.svg</file>
@@ -29,19 +25,16 @@
         <file>images/library/ic_library_traktor.svg</file>
         <file>images/library/ic_library_rekordbox.svg</file>
         <file>images/library/ic_library_serato.svg</file>
-      <!-- logo and icons for 'About' dialog -->
         <file>images/mixxx_logo.svg</file>
         <file>images/icons/scalable/apps/mixxx.svg</file>
         <file>images/heart_icon_light.svg</file>
         <file>images/heart_icon_dark.svg</file>
         <file>images/heart_icon_rainbow.svg</file>
-        <file>images/mixxx-icon-logo-symbolic.svg</file> <!-- default launch image -->
+        <file>images/mixxx-icon-logo-symbolic.svg</file>
         <file>images/skin_preview_placeholder.png</file>
         <file>images/ic_checkmark.svg</file>
         <file>images/ic_delete.svg</file>
-      <!-- keywheel dialog image -->
         <file>images/keywheel/keywheel.svg</file>
-      <!-- dark icon set for preferences -->
         <file>images/preferences/dark/ic_preferences_autodj.svg</file>
         <file>images/preferences/dark/ic_preferences_bpmdetect.svg</file>
         <file>images/preferences/dark/ic_preferences_broadcast.svg</file>
@@ -64,7 +57,6 @@
         <file>images/preferences/dark/ic_custom.svg</file>
         <file>images/preferences/dark/ic_mixxx_symbolic.svg</file>
         <file>images/preferences/dark/ic_none.svg</file>
-      <!-- light icon set for preferences -->
         <file>images/preferences/light/ic_preferences_autodj.svg</file>
         <file>images/preferences/light/ic_preferences_bpmdetect.svg</file>
         <file>images/preferences/light/ic_preferences_broadcast.svg</file>
@@ -87,14 +79,13 @@
         <file>images/preferences/light/ic_custom.svg</file>
         <file>images/preferences/light/ic_mixxx_symbolic.svg</file>
         <file>images/preferences/light/ic_none.svg</file>
-      <!-- magnifier for the Search button in Search related tracks menu -->
         <file>images/ic_magnifier.svg</file>
-      <!-- skin oversize warning -->
         <file>images/preferences/ic_preferences_warning.svg</file>
         <file>schema.xml</file>
         <file>shaders/filteredsignal.frag</file>
         <file>shaders/passthrough.vert</file>
         <file>shaders/rgbsignal.frag</file>
         <file>shaders/stackedsignal.frag</file>
+        <file>images/preferences/ic_preferences_osc.png</file>
     </qresource>
 </RCC>
diff --git a/res/qml/ComboBox.qml b/res/qml/ComboBox.qml
index adf4494721..b1f36f5be5 100644
--- a/res/qml/ComboBox.qml
+++ b/res/qml/ComboBox.qml
@@ -6,6 +6,9 @@ import "Theme"
 ComboBox {
     id: root
 
+    property alias popupWidth: popup.width
+    property bool clip: false
+
     background: Skin.EmbeddedBackground {
     }
 
@@ -40,10 +43,12 @@ ComboBox {
         font: root.font
         color: Theme.deckTextColor
         verticalAlignment: Text.AlignVCenter
-        elide: Text.ElideRight
+        elide: root.clip ? Text.ElideNone : Text.ElideRight
+        clip: root.clip
     }
 
     popup: Popup {
+        id: popup
         y: root.height
         width: root.width
         implicitHeight: contentItem.implicitHeight
diff --git a/res/qml/EqColumn.qml b/res/qml/EqColumn.qml
index f894e27165..b6740cb825 100644
--- a/res/qml/EqColumn.qml
+++ b/res/qml/EqColumn.qml
@@ -22,6 +22,7 @@ Column {
         Column {
             id: stem
             spacing: 4
+            width: 10
             visible: opacity != 0
             Repeater {
                 model: root.player.stemsModel
@@ -59,11 +60,8 @@ Column {
                 knob.color: Theme.eqLowColor
             }
 
-            Skin.EqKnob {
-                knob.group: "[QuickEffectRack1_" + root.group + "]"
-                knob.key: "super1"
-                statusGroup: "[QuickEffectRack1_" + root.group + "_Effect1]"
-                statusKey: "enabled"
+            Skin.QuickFxKnob {
+                group: "[QuickEffectRack1_" + root.group + "]"
                 knob.arcStyle: ShapePath.DashLine
                 knob.arcStylePattern: [2, 2]
                 knob.color: Theme.eqFxColor
diff --git a/res/qml/Mixxx/Controls/Knob.qml b/res/qml/Mixxx/Controls/Knob.qml
index 5f269af8c3..7ac3828329 100644
--- a/res/qml/Mixxx/Controls/Knob.qml
+++ b/res/qml/Mixxx/Controls/Knob.qml
@@ -17,7 +17,7 @@ Item {
     property alias foreground: foreground.data
     property real min: 0
     property real max: 1
-    property real wheelStepSize: (root.max - root.min) / 10
+    property real wheelStepSize: (root.max - root.min) / 100
     property real angle: 130
     property bool arc: false
     property int arcStart: Knob.Center
diff --git a/res/qml/QuickFxKnob.qml b/res/qml/QuickFxKnob.qml
new file mode 100644
index 0000000000..6efa1a0bdc
--- /dev/null
+++ b/res/qml/QuickFxKnob.qml
@@ -0,0 +1,83 @@
+import "." as Skin
+import Mixxx 1.0 as Mixxx
+import QtQuick 2.12
+import "Theme"
+
+Rectangle {
+    id: root
+
+    property alias knob: knob
+    required property string group
+
+    color: Theme.knobBackgroundColor
+    width: 56
+    height: 56
+    radius: 5
+
+    Skin.ControlKnob {
+        id: knob
+
+        group: root.group
+        key: "super1"
+
+        anchors.horizontalCenter: root.horizontalCenter
+        anchors.top: root.top
+        width: 40
+        height: 40
+    }
+
+    Mixxx.ControlProxy {
+        id: statusControl
+
+        group: root.group
+        key: "enabled"
+    }
+
+    Rectangle {
+        id: statusButton
+
+        anchors.left: root.left
+        anchors.bottom: root.bottom
+        anchors.leftMargin: 4
+        anchors.bottomMargin: 4
+        width: 8
+        height: width
+        radius: width / 2
+        border.width: 1
+        border.color: Theme.buttonNormalColor
+        color: statusControl.value ? knob.color : "transparent"
+
+        TapHandler {
+            onTapped: statusControl.value = !statusControl.value
+        }
+    }
+
+    Mixxx.ControlProxy {
+        id: fxSelect
+
+        group: root.group
+        key: "loaded_chain_preset"
+    }
+
+    Skin.ComboBox {
+        id: effectSelector
+        anchors.left: statusButton.right
+        anchors.leftMargin: 2
+        anchors.right: root.right
+        anchors.top: knob.bottom
+        anchors.margins: 1
+        spacing: 2
+        indicator.width: 0
+        popupWidth: 150
+        clip: true
+
+        opacity: statusControl.value ? 1 : 0.5
+        textRole: "display"
+        font.pixelSize: 10
+        model: Mixxx.EffectsManager.quickChainPresetModel
+        currentIndex: fxSelect.value == -1 ? 0 : fxSelect.value
+        onActivated: (index) => {
+            fxSelect.value = index
+        }
+    }
+}
diff --git a/res/qml/StemKnob.qml b/res/qml/StemKnob.qml
index 0e0f1fd0e5..f9e9b3c6c5 100644
--- a/res/qml/StemKnob.qml
+++ b/res/qml/StemKnob.qml
@@ -6,62 +6,139 @@ import "Theme"
 Rectangle {
     id: root
 
-    property alias knob: knob
+    property alias knob: volume
 
     required property string group
     required property string label
     required property color stemColor
     required property int index
 
-    width: 56
-    height: 56
-    radius: 5
-    color: stemColor
+    readonly property string fxGroup: `[QuickEffectRack1_${group.substr(0, group.length-1)}Stem${index + 1}]]`
 
-    Skin.ControlKnob {
-        id: knob
-        group: root.group
-        key: `stem_${root.index + 1}_volume`
-        color: Theme.gainKnobColor
-        anchors.topMargin: 5
-        anchors.top: root.top
-        anchors.horizontalCenter: root.horizontalCenter
+width: 56
+height: 56
+radius: 5
+color: stemColor
+opacity: statusControl.value ? 0.5 : 1
 
-        arcStart: 0
+Mixxx.ControlProxy {
+    id: statusControl
 
-        width: 36
-        height: 36
-    }
+    group: root.group
+    key: `stem_${root.index + 1}_mute`
+}
+
+Mixxx.ControlProxy {
+    id: fxControl
+
+    group: root.fxGroup
+    key: "enabled"
+}
+
+Rectangle {
+    id: statusButton
 
-    Text {
-        anchors.bottom: root.bottom
-        anchors.horizontalCenter: root.horizontalCenter
-        text: label
+    anchors.left: root.left
+    anchors.top: root.top
+    anchors.leftMargin: 4
+    anchors.topMargin: 4
+    width: 8
+    height: width
+    radius: width / 2
+    border.width: 1
+    border.color: Theme.buttonNormalColor
+    color: statusControl.value ? volume.color : "transparent"
+
+    TapHandler {
+        onTapped: statusControl.value = !statusControl.value
     }
+}
+
+Text {
+    id: stemLabel
+    anchors.top: root.top
+    anchors.right: root.right
+    anchors.topMargin: 2
+    anchors.rightMargin: 2
+    elide: Text.ElideRight
+    text: label
+    font.pixelSize: 10
+}
+
+Skin.ControlKnob {
+    id: volume
+    group: root.group
+    key: `stem_${root.index + 1}_volume`
+    color: Theme.gainKnobColor
+    anchors.leftMargin: 1
+    anchors.top: statusButton.bottom
+    anchors.left: root.left
+
+    arcStart: 0
 
-    Mixxx.ControlProxy {
-        id: statusControl
+    width: 32
+    height: 32
+}
+
+Rectangle {
+    id: fxButton
+
+    anchors.top: stemLabel.bottom
+    anchors.right: root.right
+    anchors.left: volume.right
+    anchors.leftMargin: 8
+    anchors.rightMargin: 8
+    width: 8
+    height: width
+    radius: width / 2
+    border.width: 1
+    border.color: Theme.buttonNormalColor
+    color: fxControl.value ? effectSuperKnob.color : "transparent"
 
-        group: root.group
-        key: `stem_${root.index + 1}_mute`
+    TapHandler {
+        onTapped: fxControl.value = !fxControl.value
     }
+}
+
+Skin.ControlMiniKnob {
+    id: effectSuperKnob
 
-    Rectangle {
-        id: statusButton
-
-        anchors.left: root.left
-        anchors.top: root.top
-        anchors.leftMargin: 4
-        anchors.topMargin: 4
-        width: 8
-        height: width
-        radius: width / 2
-        border.width: 1
-        border.color: Theme.buttonNormalColor
-        color: statusControl.value ? knob.color : "transparent"
-
-        TapHandler {
-            onTapped: statusControl.value = !statusControl.value
-        }
+    anchors.right: root.right
+    anchors.left: volume.right
+    anchors.bottom: effectSelector.top
+    anchors.margins: 2
+    arcStart: Knob.ArcStart.Minimum
+    group: root.fxGroup
+    key: "super1"
+    color: Theme.effectColor
+    opacity: fxControl.value ? 1 : 0.5
+}
+
+Mixxx.ControlProxy {
+    id: fxSelect
+
+    group: root.fxGroup
+    key: "loaded_chain_preset"
+}
+
+Skin.ComboBox {
+    id: effectSelector
+    anchors.left: root.left
+    anchors.right: root.right
+    anchors.bottom: root.bottom
+    anchors.margins: 1
+    spacing: 2
+    indicator.width: 0
+    popupWidth: 150
+    clip: true
+
+    opacity: fxControl.value ? 1 : 0.5
+    textRole: "display"
+    font.pixelSize: 10
+    model: Mixxx.EffectsManager.quickChainPresetModel
+    currentIndex: fxSelect.value == -1 ? 0 : fxSelect.value
+    onActivated: (index) => {
+        fxSelect.value = index
     }
 }
+}
diff --git a/res/skins/Deere/deck.xml b/res/skins/Deere/deck.xml
index b899228904..a2dc41c93c 100644
--- a/res/skins/Deere/deck.xml
+++ b/res/skins/Deere/deck.xml
@@ -38,7 +38,7 @@
                     <Children>
                       <Template src="skins:Deere/deck_spinny.xml">
                         <SetVariable name="cover">true</SetVariable>
-                        <SetVariable name="Size">55f,55f</SetVariable>
+                        <SetVariable name="Size">68f,68f</SetVariable>
                       </Template>
                     </Children>
                   </WidgetGroup>
@@ -51,7 +51,7 @@
                     <Children>
                       <Template src="skins:Deere/deck_spinny.xml">
                         <SetVariable name="cover">false</SetVariable>
-                        <SetVariable name="Size">55f,55f</SetVariable>
+                        <SetVariable name="Size">68f,68f</SetVariable>
                       </Template>
                     </Children>
                   </WidgetGroup>
diff --git a/res/skins/Deere/deck_waveform.xml b/res/skins/Deere/deck_waveform.xml
index e7cf2dd245..8e4a0ac371 100644
--- a/res/skins/Deere/deck_waveform.xml
+++ b/res/skins/Deere/deck_waveform.xml
@@ -128,6 +128,41 @@
         - if a MIDI device which supports more hotcues than buttons are in the current skin has them activated
         - if you change from a skin which supports more hotcues than buttons are in the current skin (and has them activated)
         -->
+        <StemControl alignment="left">
+          <MinimumSize>138,68</MinimumSize>
+          <MaximumSize>158,1920</MaximumSize>
+          <SizePolicy>me,me</SizePolicy>
+          <Stem>
+            <MinimumSize>130,17</MinimumSize>
+            <MaximumSize>150,1920</MaximumSize>
+            <SizePolicy>me,min</SizePolicy>
+            <Layout>horizontal</Layout>
+            <Children>
+              <Label>
+                <ObjectName>stem_label</ObjectName>
+                <SizePolicy>e,max</SizePolicy>
+              </Label>
+              <KnobComposed>
+                <Pos>0,0</Pos>
+                <MinimumSize>20,17</MinimumSize>
+                <MaximumSize>40,34</MaximumSize>
+                <SizePolicy>me,me</SizePolicy>
+                <Knob>knob.svg</Knob>
+                <BackPath>knob_bg_blue.svg</BackPath>
+                <MinAngle>-135</MinAngle>
+                <MaxAngle>135</MaxAngle>
+                <KnobCenterYOffset>1.602</KnobCenterYOffset>
+                <Connection>
+                  <ConfigKey><Variable name="StemGroup"/>,volume</ConfigKey>
+                </Connection>
+              </KnobComposed>
+            </Children>
+          </Stem>
+          <Connection>
+            <ConfigKey persist="true">[Skin],show_stem_controls</ConfigKey>
+            <BindProperty>displayed</BindProperty>
+          </Connection>
+        </StemControl>
       </Visual>
 
       <WidgetGroup>
diff --git a/res/skins/Deere/skin_settings.xml b/res/skins/Deere/skin_settings.xml
index ab9dceaab7..ee33aca99f 100644
--- a/res/skins/Deere/skin_settings.xml
+++ b/res/skins/Deere/skin_settings.xml
@@ -61,6 +61,11 @@
             <SetVariable name="skinsetting">[Skin],show_4decks</SetVariable>
           </Template>
 
+          <Template src="skins:Deere/skinsettings_button.xml">
+            <SetVariable name="TooltipId">show_stem_controls</SetVariable>
+            <SetVariable name="text">Show stem controls</SetVariable>
+            <SetVariable name="skinsetting">[Skin],show_stem_controls</SetVariable>
+          </Template>
         </Children>
       </WidgetGroup>
 
diff --git a/res/skins/Deere/style.qss b/res/skins/Deere/style.qss
index 990a9c5769..a4a2bd9fc6 100644
--- a/res/skins/Deere/style.qss
+++ b/res/skins/Deere/style.qss
@@ -374,7 +374,7 @@ WTrackTableViewHeader {
 WTrackTableViewHeader::section {
   height: 1.1em;
   font-weight: bold;
-  padding: 0.1em;
+  padding: 0.1em -1em 0.1em 0.1em;
   background-color: #1A1A1A;
   border-top: none;
   border-left: none;
@@ -1432,11 +1432,6 @@ WWidget, WLabel {
   font-size: 12px;
 }
 
-/* Track text, etc. should be in the deck color. */
-#Deck1 WLabel, #Deck2 WLabel, #Deck3 WLabel, #Deck4 WLabel {
-  color: #D2D2D2;
-}
-
 WNumberRate {
   font-size: 13px;
 }
@@ -2456,3 +2451,17 @@ WRateRange {
 #RateDisplayBottomRate {
     qproperty-alignment: 'AlignRight | AlignBottom';
 }
+
+/** Stem control **/
+WStemControlBox {
+  background-color: transparent;
+}
+WStemControl WLabel {
+  color: #222222;
+  padding-left: 5px;
+  font-weight: 500;
+  font-size: 14px;
+}
+WStemControl {
+  margin: 10px 15px 10px 15px;
+}
diff --git a/res/skins/Deere/tool_bar.xml b/res/skins/Deere/tool_bar.xml
index 7e1eb8402f..4af57c9e76 100644
--- a/res/skins/Deere/tool_bar.xml
+++ b/res/skins/Deere/tool_bar.xml
@@ -34,8 +34,7 @@
               <Time>
                 <TooltipId>time</TooltipId>
                 <ObjectName>Time</ObjectName>
-                <Size>52f,20f</Size>
-                <CustomFormat>hh:mm</CustomFormat>
+                <Size>56f,20f</Size>
               </Time>
 
               <Template src="skin:vumeter_latency.xml">
diff --git a/res/skins/LateNight/classic/buttons/btn__delete.svg b/res/skins/LateNight/classic/buttons/btn__delete.svg
index 8185e6f2fe..b2ab8b65a9 100644
--- a/res/skins/LateNight/classic/buttons/btn__delete.svg
+++ b/res/skins/LateNight/classic/buttons/btn__delete.svg
@@ -1,6 +1,10 @@
 <svg width="1024" height="1024" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
-	<g transform="translate(-23.64344,7e-5)" fill="#d2d2d1">
-		<path d="m279.64681 171.88159c-26.06575 0-52.13052.0299-71.90526.0877l-71.90864.20917 11.39635 144.28116c7.26636 91.9973 11.88509 146.21609 12.74582 149.6234 2.4022 9.50895 6.88437 16.93731 14.65702 24.28386 7.88017 7.44816 14.40588 11.12108 24.00553 13.51503 5.96413 1.48733 10.30426 1.57485 80.65663 1.61768 71.30357.0434 74.62708-.0215 81.02436-1.57888 9.85632-2.39955 16.34743-6.02487 24.29398-13.57238 7.85903-7.46439 12.32536-14.96921 14.6857-24.67522.90639-3.72716 5.40827-56.44582 12.77787-149.62509l11.37779-143.86956-71.90188-.20917c-19.77331-.0578-45.83951-.0877-71.90527-.0877zm79.20088 23.47248c1.92031.0545 3.91687.65563 5.89385 1.87747 4.29268 2.65302 5.9201 6.92117 5.75552 15.10065-.0764 3.80014-2.86136 62.8749-6.18904 131.27725-6.57263 135.10449-5.97739 128.11675-11.2479 131.76981-4.70407 3.26046-10.50992 2.49862-14.17796-1.86059-1.87869-2.2327-2.2317-3.50477-2.2317-8.05808 0-5.74085 8.32212-242.81518 8.888-253.19417.56337-10.33268 6.45099-17.10691 13.30923-16.91234zm-79.51126.22773c4.38547-.10444 8.72138 2.47334 10.99151 7.105 1.52928 3.12018 1.6007 6.17808 1.40345 60.44482-.11427 31.43731-.45063 90.79419-.74728 131.90475-.50093 69.42126-.6481 74.91225-2.06301 77.07039-.83789 1.27804-2.39249 2.86626-3.45466 3.52889-6.30109 3.93089-14.30324.80068-16.12627-6.30712-.65167-2.54075-2.5629-242.03828-2.06302-258.52124.18575-6.12512 2.35757-10.77695 6.23797-13.36153 1.82416-1.215 3.82792-1.8165 5.82131-1.86396zm-78.86857.007c5.49185.14786 11.05876 4.33427 12.51979 12.08289.48348 2.56393 2.8998 62.42091 5.37092 133.01639 4.87989 139.42323 4.88156 131.2626-.0304 134.68467-2.86392 1.99523-5.87605 2.50847-9.21188 1.56878-2.9698-.83662-6.927-4.95017-7.64816-7.95012-1.01291-4.21309-13.19116-261.60393-12.4928-264.03892 1.8586-6.48061 6.64675-9.49416 11.49249-9.36369z"/>
-		<path d="m197.35198 25.916155c5.91021-9.37875 14.10043-14.356319 23.66471-14.382207l5.25609-.01419 37.62836 20.407046 37.62843 20.407088 3.50577-4.104816c7.29902-8.546334 17.96939-13.649361 27.61485-13.206643l4.78273.219524 31.39991 17.283079c30.62399 16.855999 31.46538 17.371964 34.04955 20.880829 5.51991 7.495076 7.17444 22.573787 3.50975 31.986485l-1.49873 3.84943 37.42427 20.896 37.42427 20.89599 2.7998 4.44829c5.09476 8.0945 5.27082 17.67701.50871 27.6877l-2.88036 6.05495-143.19644-78.81791-143.19644-78.817918z"/>
-	</g>
+  <g transform="translate(-23.64344,7e-5)" fill="#d2d2d1">
+    <path d="m279.64681 171.88159c-26.06575 0-52.13052.0299-71.90526.0877l-71.90864.20917 11.39635 144.28116c7.26636 91.9973 11.88509 146.21609 12.74582 149.6234 2.4022 9.50895 6.88437 16.93731 14.65702 24.28386 7.88017 7.44816 14.40588 11.12108 24.00553 13.51503 5.96413 1.48733 10.30426 1.57485 80.65663 1.61768 71.30357.0434 74.62708-.0215 81.02436-1.57888 9.85632-2.39955 16.34743-6.02487 24.29398-13.57238 7.85903-7.46439 12.32536-14.96921 14.6857-24.67522.90639-3.72716 5.40827-56.44582 12.77787-149.62509l11.37779-143.86956-71.90188-.20917c-19.77331-.0578-45.83951-.0877-71.90527-.0877zm79.20088 23.47248c1.92031.0545 3.91687.65563 5.89385 1.87747 4.29268 2.65302 5.9201 6.92117 5.75552 15.10065-.0764 3.80014-2.86136 62.8749-6.18904 131.27725-6.57263 135.10449-5.97739 128.11675-11.2479 131.76981-4.70407 3.26046-10.50992 2.49862-14.17796-1.86059-1.87869-2.2327-2.2317-3.50477-2.2317-8.05808 0-5.74085 8.32212-242.81518 8.888-253.19417.56337-10.33268 6.45099-17.10691 13.30923-16.91234zm-79.51126.22773c4.38547-.10444 8.72138 2.47334 10.99151 7.105 1.52928 3.12018 1.6007 6.17808 1.40345 60.44482-.11427 31.43731-.45063 90.79419-.74728 131.90475-.50093 69.42126-.6481 74.91225-2.06301 77.07039-.83789 1.27804-2.39249 2.86626-3.45466 3.52889-6.30109 3.93089-14.30324.80068-16.12627-6.30712-.65167-2.54075-2.5629-242.03828-2.06302-258.52124.18575-6.12512 2.35757-10.77695 6.23797-13.36153 1.82416-1.215 3.82792-1.8165 5.82131-1.86396zm-78.86857.007c5.49185.14786 11.05876 4.33427 12.51979 12.08289.48348 2.56393 2.8998 62.42091 5.37092 133.01639 4.87989 139.42323 4.88156 131.2626-.0304 134.68467-2.86392 1.99523-5.87605 2.50847-9.21188 1.56878-2.9698-.83662-6.927-4.95017-7.64816-7.95012-1.01291-4.21309-13.19116-261.60393-12.4928-264.03892 1.8586-6.48061 6.64675-9.49416 11.49249-9.36369z"/>
+    <path d="m197.35198 25.916155c5.91021-9.37875 14.10043-14.356319 23.66471-14.382207l5.25609-.01419 37.62836 20.407046 37.62843 20.407088 3.50577-4.104816c7.29902-8.546334 17.96939-13.649361 27.61485-13.206643l4.78273.219524 31.39991 17.283079c30.62399 16.855999 31.46538 17.371964 34.04955 20.880829 5.51991 7.495076 7.17444 22.573787 3.50975 31.986485l-1.49873 3.84943 37.42427 20.896 37.42427 20.89599 2.7998 4.44829c5.09476 8.0945 5.27082 17.67701.50871 27.6877l-2.88036 6.05495-143.19644-78.81791-143.19644-78.817918z"/>
+  </g>
+  <g transform="translate(-23.64344,8.8871122e-5)" fill="none" stroke="#000" stroke-width="14">
+    <path d="m279.64681 171.88159c-26.06575 0-52.13052 0.0299-71.90526 0.0877l-71.90864 0.20917 11.39635 144.28116c7.26636 91.9973 11.88509 146.21609 12.74582 149.6234 2.4022 9.50895 6.88437 16.93731 14.65702 24.28386 7.88017 7.44816 14.40588 11.12108 24.00553 13.51503 5.96413 1.48733 10.30426 1.57485 80.65663 1.61768 71.30357 0.0434 74.62708-0.0215 81.02436-1.57888 9.85632-2.39955 16.34743-6.02487 24.29398-13.57238 7.85903-7.46439 12.32536-14.96921 14.6857-24.67522 0.90639-3.72716 5.40827-56.44582 12.77787-149.62509l11.37779-143.86956-71.90188-0.20917c-19.77331-0.0578-45.83951-0.0877-71.90527-0.0877zm79.20088 23.47248c1.92031 0.0545 3.91687 0.65563 5.89385 1.87747 4.29268 2.65302 5.9201 6.92117 5.75552 15.10065-0.0764 3.80014-2.86136 62.8749-6.18904 131.27725-6.57263 135.10449-5.97739 128.11675-11.2479 131.76981-4.70407 3.26046-10.50992 2.49862-14.17796-1.86059-1.87869-2.2327-2.2317-3.50477-2.2317-8.05808 0-5.74085 8.32212-242.81518 8.888-253.19417 0.56337-10.33268 6.45099-17.10691 13.30923-16.91234zm-79.51126 0.22773c4.38547-0.10444 8.72138 2.47334 10.99151 7.105 1.52928 3.12018 1.6007 6.17808 1.40345 60.44482-0.11427 31.43731-0.45063 90.79419-0.74728 131.90475-0.50093 69.42126-0.6481 74.91225-2.06301 77.07039-0.83789 1.27804-2.39249 2.86626-3.45466 3.52889-6.30109 3.93089-14.30324 0.80068-16.12627-6.30712-0.65167-2.54075-2.5629-242.03828-2.06302-258.52124 0.18575-6.12512 2.35757-10.77695 6.23797-13.36153 1.82416-1.215 3.82792-1.8165 5.82131-1.86396zm-78.86857 7e-3c5.49185 0.14786 11.05876 4.33427 12.51979 12.08289 0.48348 2.56393 2.8998 62.42091 5.37092 133.01639 4.87989 139.42323 4.88156 131.2626-0.0304 134.68467-2.86392 1.99523-5.87605 2.50847-9.21188 1.56878-2.9698-0.83662-6.927-4.95017-7.64816-7.95012-1.01291-4.21309-13.19116-261.60393-12.4928-264.03892 1.8586-6.48061 6.64675-9.49416 11.49249-9.36369z"/>
+    <path d="m197.35198 25.916155c5.91021-9.37875 14.10043-14.356319 23.66471-14.382207l5.25609-0.01419 37.62836 20.407046 37.62843 20.407088 3.50577-4.104816c7.29902-8.546334 17.96939-13.649361 27.61485-13.206643l4.78273 0.219524 31.39991 17.283079c30.62399 16.855999 31.46538 17.371964 34.04955 20.880829 5.51991 7.495076 7.17444 22.573787 3.50975 31.986485l-1.49873 3.84943 37.42427 20.896 37.42427 20.89599 2.7998 4.44829c5.09476 8.0945 5.27082 17.67701 0.50871 27.6877l-2.88036 6.05495-143.19644-78.81791-143.19644-78.817918z"/>
+  </g>
 </svg>
diff --git a/res/skins/LateNight/controls/button_2state.xml b/res/skins/LateNight/controls/button_2state.xml
index b9f5842d13..77587fd371 100644
--- a/res/skins/LateNight/controls/button_2state.xml
+++ b/res/skins/LateNight/controls/button_2state.xml
@@ -17,6 +17,7 @@ Variables:
     <TooltipId><Variable name="TooltipId"/></TooltipId>
     <ObjectName><Variable name="ObjectName"/></ObjectName>
     <Size><Variable name="Size"/></Size>
+    <Pos><Variable name="Pos"/></Pos>
     <NumberStates>2</NumberStates>
     <RightClickIsPushButton>false</RightClickIsPushButton>
     <State>
diff --git a/res/skins/LateNight/controls/button_4state_display.xml b/res/skins/LateNight/controls/button_4state_display.xml
index 55c2513ab0..a6e49b25fb 100644
--- a/res/skins/LateNight/controls/button_4state_display.xml
+++ b/res/skins/LateNight/controls/button_4state_display.xml
@@ -23,29 +23,29 @@ Variables:
       <Number>0</Number>
       <Text><Variable name="state_0_text"/></Text>
       <Alignment><Variable name="Align"/></Alignment>
-      <Unpressed scalemode="STRETCH">skin:/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>.svg</Unpressed>
-      <Pressed scalemode="STRETCH">skin:/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Pressed>
+      <Unpressed scalemode="STRETCH">skins:LateNight/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>.svg</Unpressed>
+      <Pressed scalemode="STRETCH">skins:LateNight/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Pressed>
     </State>
     <State>
       <Number>1</Number>
       <Text><Variable name="state_1_text"/></Text>
       <Alignment><Variable name="Align"/></Alignment>
-      <Unpressed scalemode="STRETCH">skin:/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Unpressed>
-      <Pressed scalemode="STRETCH">skin:/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Pressed>
+      <Unpressed scalemode="STRETCH">skins:LateNight/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Unpressed>
+      <Pressed scalemode="STRETCH">skins:LateNight/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Pressed>
     </State>
     <State>
       <Number>2</Number>
       <Text><Variable name="state_2_text"/></Text>
       <Alignment><Variable name="Align"/></Alignment>
-      <Unpressed scalemode="STRETCH">skin:/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Unpressed>
-      <Pressed scalemode="STRETCH">skin:/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Pressed>
+      <Unpressed scalemode="STRETCH">skins:LateNight/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Unpressed>
+      <Pressed scalemode="STRETCH">skins:LateNight/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Pressed>
     </State>
     <State>
       <Number>4</Number>
       <Text><Variable name="state_3_text"/></Text>
       <Alignment><Variable name="Align"/></Alignment>
-      <Unpressed scalemode="STRETCH">skin:/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Unpressed>
-      <Pressed scalemode="STRETCH">skin:/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Pressed>
+      <Unpressed scalemode="STRETCH">skins:LateNight/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Unpressed>
+      <Pressed scalemode="STRETCH">skins:LateNight/<Variable name="BtnScheme"/>/buttons/btn_<Variable name="BtnType"/>_<Variable name="BtnSize"/>_active.svg</Pressed>
     </State>
     <Connection>
       <ConfigKey><Variable name="ConfigKey"/></ConfigKey>
diff --git a/res/skins/LateNight/palemoon/buttons/btn__delete_active.svg b/res/skins/LateNight/palemoon/buttons/btn__delete_active.svg
new file mode 100644
index 0000000000..ea2b150f81
--- /dev/null
+++ b/res/skins/LateNight/palemoon/buttons/btn__delete_active.svg
@@ -0,0 +1,6 @@
+<svg width="1024" height="1024" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
+  <g transform="translate(-23.6434 7e-5)">
+    <path d="m279.647 171.882c-26.0658 0-52.1305 0.0299-71.9053 0.0877l-71.9086 0.20917 11.3964 144.281c7.26636 91.9973 11.8851 146.216 12.7458 149.623 2.4022 9.50895 6.88437 16.9373 14.657 24.2839 7.88017 7.44816 14.4059 11.1211 24.0055 13.515 5.96413 1.48733 10.3043 1.57485 80.6566 1.61768 71.3036 0.0434 74.6271-0.0215 81.0244-1.57888 9.85632-2.39955 16.3474-6.02487 24.294-13.5724 7.85903-7.46439 12.3254-14.9692 14.6857-24.6752 0.90639-3.72716 5.40827-56.4458 12.7779-149.625l11.3778-143.87-71.9019-0.20917c-19.7733-0.0578-45.8395-0.0877-71.9053-0.0877zm79.2009 23.4725c1.92031 0.0545 3.91687 0.65563 5.89385 1.87747 4.29268 2.65302 5.9201 6.92117 5.75552 15.1006-0.0764 3.80014-2.86136 62.8749-6.18904 131.277-6.57263 135.104-5.97739 128.117-11.2479 131.77-4.70407 3.26046-10.5099 2.49862-14.178-1.86059-1.87869-2.2327-2.2317-3.50477-2.2317-8.05808 0-5.74085 8.32212-242.815 8.888-253.194 0.56337-10.3327 6.45099-17.1069 13.3092-16.9123zm-79.5113 0.22773c4.38547-0.10444 8.72138 2.47334 10.9915 7.105 1.52928 3.12018 1.6007 6.17808 1.40345 60.4448-0.11427 31.4373-0.45063 90.7942-0.74728 131.905-0.50093 69.4213-0.6481 74.9122-2.06301 77.0704-0.83789 1.27804-2.39249 2.86626-3.45466 3.52889-6.30109 3.93089-14.3032 0.80068-16.1263-6.30712-0.65167-2.54075-2.5629-242.038-2.06302-258.521 0.18575-6.12512 2.35757-10.777 6.23797-13.3615 1.82416-1.215 3.82792-1.8165 5.82131-1.86396zm-78.8686 7e-3c5.49185 0.14786 11.0588 4.33427 12.5198 12.0829 0.48348 2.56393 2.8998 62.4209 5.37092 133.016 4.87989 139.423 4.88156 131.263-0.0304 134.685-2.86392 1.99523-5.87605 2.50847-9.21188 1.56878-2.9698-0.83662-6.927-4.95017-7.64816-7.95012-1.01291-4.21309-13.1912-261.604-12.4928-264.039 1.8586-6.48061 6.64675-9.49416 11.4925-9.36369z"/>
+    <path d="m197.352 25.9162c5.91021-9.37875 14.1004-14.3563 23.6647-14.3822l5.25609-0.01419 75.2568 40.8141 3.50577-4.10482c7.29902-8.54633 17.9694-13.6494 27.6148-13.2066l4.78273 0.219524 31.3999 17.2831c30.624 16.856 31.4654 17.372 34.0496 20.8808 5.51991 7.49508 7.17444 22.5738 3.50975 31.9865l-1.49873 3.84943 74.8485 41.792 2.7998 4.44829c5.09476 8.0945 5.27082 17.677 0.50871 27.6877l-2.88036 6.05495-286.393-157.636z"/>
+  </g>
+</svg>
diff --git a/res/skins/LateNight/skin.xml b/res/skins/LateNight/skin.xml
index a553f5500b..daffcad913 100644
--- a/res/skins/LateNight/skin.xml
+++ b/res/skins/LateNight/skin.xml
@@ -41,6 +41,7 @@
       <attribute config_key="[App],num_samplers">16</attribute>
       <attribute persist="true" config_key="[Skin],show_waveforms">1</attribute>
       <attribute persist="true" config_key="[Skin],timing_shift_buttons">0</attribute>
+      <attribute persist="true" config_key="[Skin],show_stem_controls">0</attribute>
 
     <!-- Decks -->
       <!-- general -->
@@ -63,6 +64,7 @@
       <attribute persist="true" config_key="[Skin],show_rate_controls">1</attribute>
       <attribute persist="true" config_key="[Skin],show_rate_control_buttons">1</attribute>
       <attribute persist="true" config_key="[Skin],show_beatgrid_controls">1</attribute>
+      <attribute persist="true" config_key="[Skin],show_stem_controls">1</attribute>
       <!-- Compact deck -->
       <attribute persist="true" config_key="[Skin],show_rate_controls_compact">1</attribute>
       <attribute persist="true" config_key="[Skin],show_loop_controls_compact">1</attribute>
diff --git a/res/skins/LateNight/skin_settings.xml b/res/skins/LateNight/skin_settings.xml
index d395224296..8d05c58f3c 100644
--- a/res/skins/LateNight/skin_settings.xml
+++ b/res/skins/LateNight/skin_settings.xml
@@ -266,6 +266,26 @@ Description:
 
                     </Children>
                   </WidgetGroup>
+
+                  <!-- Stem control over the waveform -->
+                  <WidgetGroup>
+                    <ObjectName>SkinSettingsCategory</ObjectName>
+                    <SizePolicy>me,f</SizePolicy>
+                    <Layout>stacked</Layout>
+                    <Children>
+                      <!-- translucent cover when waveforms are hidden -->
+                      <Template src="skins:LateNight/helpers/skin_settings_cover_inverted.xml">
+                        <SetVariable name="Setting">[Skin],show_waveforms</SetVariable>
+                      </Template>
+
+                      <Template src="skins:LateNight/helpers/skin_settings_button_2state.xml">
+                        <SetVariable name="TooltipId">show_stem_controls</SetVariable>
+                        <SetVariable name="Text">Stem control</SetVariable>
+                        <SetVariable name="Setting">[Skin],show_stem_controls</SetVariable>
+                      </Template>
+
+                    </Children>
+                  </WidgetGroup>
                 </Children>
               </WidgetGroup>
             </Children>
diff --git a/res/skins/LateNight/style.qss b/res/skins/LateNight/style.qss
index 05f5a82771..0b177acace 100644
--- a/res/skins/LateNight/style.qss
+++ b/res/skins/LateNight/style.qss
@@ -198,7 +198,7 @@ WSearchLineEdit::item:selected,
   WSearchRelatedTracksMenu #SearchSelectedAction::indicator {
     border: 0px;
     background-color: transparent;
-    image: url(skin:../LateNight/palemoon/buttons/btn__search.svg);
+    image: url(skins:LateNight/palemoon/buttons/btn__search.svg);
     margin-left: 2px;
   }
   WSearchRelatedTracksMenu #SearchSelectedAction::indicator:disabled {
@@ -208,7 +208,7 @@ WSearchLineEdit::item:selected,
   WSearchRelatedTracksMenu #SearchSelectedAction::indicator {
   }
   WSearchRelatedTracksMenu #SearchSelectedAction::indicator:disabled {
-    image: url(skin:../LateNight/palemoon/buttons/btn__search_disabled.svg);
+    image: url(skins:LateNight/palemoon/buttons/btn__search_disabled.svg);
   }
 
 /************** font sizes / alignment ****************************************/
@@ -1045,3 +1045,10 @@ WLibrarySidebar {
 #Border58 {
   border: 1px solid #585858;
 }
+
+WStemControl #FxToggleButton[displayValue="1"] {
+  background-color: #438225;
+}
+WStemControl #FxToggleButton[displayValue="0"] {
+  background-color: #121212;
+}
diff --git a/res/skins/LateNight/style_classic.qss b/res/skins/LateNight/style_classic.qss
index eb917a5498..2172ef3585 100644
--- a/res/skins/LateNight/style_classic.qss
+++ b/res/skins/LateNight/style_classic.qss
@@ -2087,6 +2087,7 @@ QPushButton#pushButtonRepeatPlaylist:!checked {
 #CueSavedLoopButton {
   image: url(skins:LateNight/classic/buttons/btn__loop.svg);
 }
+#CueDeleteButton:pressed,
 #CueSavedLoopButton:pressed,
 #CueSavedLoopButton:checked {
   background-color: #db0000;
@@ -2231,10 +2232,10 @@ WTrackProperty[selected="true"] {
       image: url(skins:LateNight/classic/buttons/btn__lib_bpm_down.svg) no-repeat;
     }
 #LibraryPlayedCheckbox::indicator:checked {
-  image: url(skin:../LateNight/classic/buttons/btn__lib_checkbox_checked.svg);
+  image: url(skins:LateNight/classic/buttons/btn__lib_checkbox_checked.svg);
 }
 #LibraryPlayedCheckbox::indicator:unchecked {
-  image: url(skin:../LateNight/classic/buttons/btn__lib_checkbox.svg);
+  image: url(skins:LateNight/classic/buttons/btn__lib_checkbox.svg);
 }
 
 WCueMenuPopup QPushButton:focus {
@@ -2271,6 +2272,9 @@ WTrackTableViewHeader {
       stop:1 #111);
   }
   WTrackTableViewHeader::section {
+    /* Workaround Qt bug that causes space being reserved for invisible sort indicators.
+       For details see style-plaemon.qss */
+    padding-right: -0.95em;
     border-right: 1px solid #000;
     border-bottom: 1px solid #000;
   }
diff --git a/res/skins/LateNight/style_palemoon.qss b/res/skins/LateNight/style_palemoon.qss
index 5146e2e0a5..d7891cbe0c 100644
--- a/res/skins/LateNight/style_palemoon.qss
+++ b/res/skins/LateNight/style_palemoon.qss
@@ -1512,23 +1512,6 @@ WEffectSelector:!editable,
     border-image: url(skins:LateNight/palemoon/buttons/btn_embedded_library_active.svg) 2 2 2 2;
   }
 
-  WTrackTableViewHeader {
-    border-bottom-right-radius: 1px solid #000;
-    outline: none;
-  }
-  WTrackTableViewHeader::section {
-    outline: none;
-    border-width: 1px 2px 1px 1px;
-    border-image: url(skins:LateNight/palemoon/buttons/btn_embedded_library_header.svg) 1 2 1 1;
-  }
-  WTrackTableViewHeader::up-arrow,
-  WTrackTableViewHeader::down-arrow {
-    outline: none;
-    /* ToDo: restore image
-    border-width: 1px 2px 1px 0px;
-    border-image: url(skins:LateNight/palemoon/buttons/btn_embedded_library_header_sort.svg) 1 2 1 1; */
-  }
-
   #LibraryFeatureControls QPushButton:!enabled {
     outline: none;
     border-width: 2px;
@@ -2713,7 +2696,7 @@ WTrackPropertyEditor {
       }
 
 #LibraryPlayedCheckbox::indicator:unchecked {
-  image: url(skin:../LateNight/palemoon/buttons/btn__lib_checkbox.svg);
+  image: url(skins:LateNight/palemoon/buttons/btn__lib_checkbox.svg);
 }
 
 /* Button in library "Preview" column */
@@ -2734,16 +2717,40 @@ WTrackPropertyEditor {
 /*********** table header styles *********************************/
 
 WTrackTableViewHeader {
+  border-bottom-right-radius: 1px solid #000;
+  outline: none;
+}
+
+WTrackTableViewHeader::section {
+/* Setting an image causes QHeaderView to reserve space for the sort indicator,
+   i.e. column titles are truncated, even where no indicators are shown.
+   The arrow width and padding are set in style.qss (0.8em + .15em),
+   so let's set a negative padding-right to shift the text. This will push the
+   reserved space out of the visible region, but the actual arrow will still be visible.
+   Now the arrow overlaps the column title again like in Qt5 (bug), so the arrow images
+   could use a background-color to cover the text, or a gradient to fade it out gently. */
+  padding: 2px -0.95em 0px 3px;
+  outline: none;
+  border-width: 1px 2px 1px 1px;
+  border-image: url(skins:LateNight/palemoon/buttons/btn_embedded_library_header.svg) 1 2 1 1;
+}
+
+WTrackTableViewHeader::up-arrow,
+WTrackTableViewHeader::down-arrow {
+  outline: none;
+  /* horizontal gradient to fade out the text */
+  background-color: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
+    stop: 0 transparent,
+    stop: 0.2 #171719,
+    stop: 1 #171719);
   }
-  WTrackTableViewHeader::section {
-    padding: 2px 1px 0px 3px;
-    }
-    WTrackTableViewHeader::up-arrow {
-      image: url(skins:LateNight/palemoon/buttons/btn__lib_sort_up.svg);
-    }
-    WTrackTableViewHeader::down-arrow {
-      image: url(skins:LateNight/palemoon/buttons/btn__lib_sort_down.svg);
-    }
+  WTrackTableViewHeader::up-arrow {
+    image: url(skins:LateNight/palemoon/buttons/btn__lib_sort_up.svg);
+  }
+  WTrackTableViewHeader::down-arrow {
+    image: url(skins:LateNight/palemoon/buttons/btn__lib_sort_down.svg);
+  }
+
 
 
 
@@ -3208,3 +3215,18 @@ WSearchLineEdit::indicator:unchecked:selected {
 }
 /************** common styles for WEffectSelector ******************************
 *************** QSpinBox, QMenu, QToolTip *************************************/
+
+/** Stem control **/
+WStemControlBox {
+  padding-left: 8px;
+  background-color: transparent;
+}
+WStemControl WLabel {
+  padding-left: 5px;
+  font-weight: 500;
+  font-size: 14px;
+}
+WStemControl {
+  border-radius: 7px;
+  opacity: 0.2;
+}
diff --git a/res/skins/LateNight/toolbar.xml b/res/skins/LateNight/toolbar.xml
index c1d84b372e..65436230db 100644
--- a/res/skins/LateNight/toolbar.xml
+++ b/res/skins/LateNight/toolbar.xml
@@ -144,7 +144,6 @@
         <Children>
           <Time>
             <TooltipId>time</TooltipId>
-            <CustomFormat>hh:mm</CustomFormat>
           </Time>
         </Children>
       </WidgetGroup>
@@ -270,7 +269,7 @@
         </Children>
       </WidgetGroup><!-- /Recording button & recording duration label -->
 
-      <Template src="skin:/controls/button_4state_display.xml">
+      <Template src="skins:LateNight/controls/button_4state_display.xml">
         <SetVariable name="ObjectName">BroadcastButton</SetVariable>
         <SetVariable name="TooltipId">broadcast_enabled</SetVariable>
         <SetVariable name="Size">72f,20f</SetVariable>
diff --git a/res/skins/LateNight/waveform.xml b/res/skins/LateNight/waveform.xml
index 2af82f4188..7c568fabbe 100644
--- a/res/skins/LateNight/waveform.xml
+++ b/res/skins/LateNight/waveform.xml
@@ -137,6 +137,84 @@
               <Color><Variable name="IntroOutroColor"/></Color>
               <TextColor>#FFFFFF</TextColor>
             </Mark>
+            <StemControl alignment="left">
+              <MinimumSize>248me,68m</MinimumSize>
+              <Stem>
+                <MinimumSize>240,17</MinimumSize>
+                <MaximumSize>240,34</MaximumSize>
+                <SizePolicy>me,min</SizePolicy>
+                <Layout>horizontal</Layout>
+                <Children>
+                  <Label>
+                    <ObjectName>stem_label</ObjectName>
+                    <SizePolicy>e,max</SizePolicy>
+                  </Label>
+                  <KnobComposed>
+                    <Pos>0,0</Pos>
+                    <MinimumSize>20,17</MinimumSize>
+                    <MaximumSize>40,34</MaximumSize>
+                    <SizePolicy>me,me</SizePolicy>
+                    <Knob>skins:LateNight/<Variable name="KnobScheme"/>/knobs/knob_indicator_regular_grey.svg</Knob>
+                    <BackPath>skins:LateNight/<Variable name="KnobScheme"/>/knobs/knob_bg_regular.svg</BackPath>
+                    <MinAngle><Variable name="PotiMinAngle"/></MinAngle>
+                    <MaxAngle><Variable name="PotiMaxAngle"/></MaxAngle>
+                    <ArcRadius><Variable name="ArcRadius"/></ArcRadius>
+                    <ArcThickness><Variable name="ArcThickness"/></ArcThickness>
+                    <ArcColor><Variable name="ArcColorEq"/></ArcColor>
+                    <ArcRoundCaps><Variable name="ArcRoundCaps"/></ArcRoundCaps>
+                    <KnobCenterYOffset>1.998</KnobCenterYOffset>
+                    <Connection>
+                      <ConfigKey><Variable name="StemGroup"/>,volume</ConfigKey>
+                    </Connection>
+                  </KnobComposed>
+                  <EffectChainPresetSelector>
+                    <ObjectName>QuickEffectSelectorLeft</ObjectName>
+                    <MinimumSize>40,17</MinimumSize>
+                    <MaximumSize>70,28</MaximumSize>
+                    <SizePolicy>me,e</SizePolicy>
+                    <EffectUnitGroup>[QuickEffectRack1_<Variable name="StemGroup"/>]</EffectUnitGroup>
+                  </EffectChainPresetSelector>
+                  <WidgetGroup>
+                    <Size>32f,28f</Size>
+                    <Children>
+                      <Template src="skins:LateNight/controls/button_2state.xml">
+                        <SetVariable name="TooltipId">EffectSlot_enabled</SetVariable>
+                        <SetVariable name="ObjectName">FxToggleButton</SetVariable>
+                        <SetVariable name="BtnSize">square</SetVariable>
+                        <SetVariable name="Size">28f,28f</SetVariable>
+                        <SetVariable name="Pos">4,0</SetVariable>
+                        <SetVariable name="ConfigKey">[QuickEffectRack1_<Variable name="StemGroup"/>],enabled</SetVariable>
+                      </Template>
+                    </Children>
+                  </WidgetGroup>
+                  <KnobComposed>
+                    <TooltipId>QuickEffectRack_super1</TooltipId>
+                    <Pos>0,0</Pos>
+                    <MinimumSize>20,17</MinimumSize>
+                    <MaximumSize>40,34</MaximumSize>
+                    <SizePolicy>me,me</SizePolicy>
+                    <Knob>skins:LateNight/<Variable name="KnobScheme"/>/knobs/knob_indicator_regular_green.svg</Knob>
+                    <BackPath>skins:LateNight/<Variable name="KnobScheme"/>/knobs/knob_bg_regular.svg</BackPath>
+                    <MinAngle><Variable name="PotiMinAngle"/></MinAngle>
+                    <MaxAngle><Variable name="PotiMaxAngle"/></MaxAngle>
+                    <ArcRadius><Variable name="ArcRadius"/></ArcRadius>
+                    <ArcUnipolar><Variable name="ArcUnipolar"/></ArcUnipolar>
+                    <ArcReversed><Variable name="ArcReversed"/></ArcReversed>
+                    <ArcColor><Variable name="ArcColorFx12Quick"/></ArcColor>
+                    <ArcThickness><Variable name="ArcThickness"/></ArcThickness>
+                    <ArcRoundCaps><Variable name="ArcRoundCaps"/></ArcRoundCaps>
+                    <KnobCenterYOffset>1.998</KnobCenterYOffset>
+                    <Connection>
+                      <ConfigKey>[QuickEffectRack1_<Variable name="StemGroup"/>],super1</ConfigKey>
+                    </Connection>
+                  </KnobComposed>
+                </Children>
+              </Stem>
+              <Connection>
+                <ConfigKey persist="true">[Skin],show_stem_controls</ConfigKey>
+                <BindProperty>displayed</BindProperty>
+              </Connection>
+            </StemControl>
           </Visual>
         </Children>
         <Connection>
diff --git a/res/skins/LateNight/waveforms_container.xml b/res/skins/LateNight/waveforms_container.xml
index ae71be1b41..86800623a9 100644
--- a/res/skins/LateNight/waveforms_container.xml
+++ b/res/skins/LateNight/waveforms_container.xml
@@ -20,7 +20,7 @@
                 <Layout>horizontal</Layout>
                 <SizePolicy>me,me</SizePolicy>
                 <Children>
-                  <Template src="skin:waveform.xml">
+                  <Template src="skins:LateNight/waveform.xml">
                     <SetVariable name="ChanNum">3</SetVariable>
                     <SetVariable name="SignalColor"><Variable name="SignalColor_34"/></SetVariable>
                     <SetVariable name="BgColorWaveform"><Variable name="BgColorWaveform_34"/></SetVariable>
@@ -37,7 +37,7 @@
                 <Layout>horizontal</Layout>
                 <SizePolicy>me,me</SizePolicy>
                 <Children>
-                  <Template src="skin:waveform.xml">
+                  <Template src="skins:LateNight/waveform.xml">
                     <SetVariable name="ChanNum">1</SetVariable>
                     <SetVariable name="SignalColor"><Variable name="SignalColor_12"/></SetVariable>
                     <SetVariable name="BgColorWaveform"><Variable name="BgColorWaveform_12"/></SetVariable>
@@ -50,7 +50,7 @@
                 <Layout>horizontal</Layout>
                 <SizePolicy>me,me</SizePolicy>
                 <Children>
-                  <Template src="skin:waveform.xml">
+                  <Template src="skins:LateNight/waveform.xml">
                     <SetVariable name="ChanNum">2</SetVariable>
                     <SetVariable name="SignalColor"><Variable name="SignalColor_12"/></SetVariable>
                     <SetVariable name="BgColorWaveform"><Variable name="BgColorWaveform_12"/></SetVariable>
@@ -63,7 +63,7 @@
                 <Layout>horizontal</Layout>
                 <SizePolicy>me,me</SizePolicy>
                 <Children>
-                  <Template src="skin:waveform.xml">
+                  <Template src="skins:LateNight/waveform.xml">
                     <SetVariable name="ChanNum">4</SetVariable>
                     <SetVariable name="SignalColor"><Variable name="SignalColor_34"/></SetVariable>
                     <SetVariable name="BgColorWaveform"><Variable name="BgColorWaveform_34"/></SetVariable>
diff --git a/res/skins/Shade/btn/btn_stem_minus.png b/res/skins/Shade/btn/btn_stem_minus.png
new file mode 100644
index 0000000000..ae616e19e8
Binary files /dev/null and b/res/skins/Shade/btn/btn_stem_minus.png differ
diff --git a/res/skins/Shade/btn/btn_stem_plus.png b/res/skins/Shade/btn/btn_stem_plus.png
new file mode 100644
index 0000000000..a453ab6713
Binary files /dev/null and b/res/skins/Shade/btn/btn_stem_plus.png differ
diff --git a/res/skins/Shade/deck.xml b/res/skins/Shade/deck.xml
index d1780c3554..0d2d21cf33 100644
--- a/res/skins/Shade/deck.xml
+++ b/res/skins/Shade/deck.xml
@@ -16,7 +16,7 @@
         <Children>
           <WidgetGroup><!-- Cover/Artist/title/time / waveform/spinny / overview/controls -->
             <ObjectName>DeckLeft</ObjectName>
-            <Size>0e,165f</Size>
+            <Size>0e,175f</Size>
             <Layout>horizontal</Layout>
             <Children>
               <WidgetGroup><!-- Cover/Artist/title/time / waveform/spinny / overview/controls -->
diff --git a/res/skins/Shade/deck_transport.xml b/res/skins/Shade/deck_transport.xml
index 9b66358856..24cfc11a5f 100644
--- a/res/skins/Shade/deck_transport.xml
+++ b/res/skins/Shade/deck_transport.xml
@@ -1,9 +1,32 @@
 <Template>
   <WidgetGroup>
-    <Size>243f,59f</Size>
+    <Size>290f,59f</Size>
     <Children>
         <!--
       **********************************************
+      Button- Stem
+      **********************************************
+      -->
+      <PushButton>
+        <TooltipId></TooltipId>
+        <NumberStates>2</NumberStates>
+        <State>
+          <Number>0</Number>
+          <Pressed>skin:/btn/btn_stem_plus.png</Pressed>
+          <Unpressed>skin:/btn/btn_stem_plus.png</Unpressed>
+        </State>
+        <State>
+          <Number>1</Number>
+          <Pressed>skin:/btn/btn_stem_minus.png</Pressed>
+          <Unpressed>skin:/btn/btn_stem_minus.png</Unpressed>
+        </State>
+        <Pos>5,0</Pos>
+        <Connection>
+          <ConfigKey>[Skin],show_stem_controls</ConfigKey>
+        </Connection>
+      </PushButton>
+        <!--
+      **********************************************
       Button- Src
       **********************************************
       -->
@@ -20,7 +43,7 @@
           <Pressed>skin:/btn/btn_src_minus.png</Pressed>
           <Unpressed>skin:/btn/btn_src_minus.png</Unpressed>
         </State>
-        <Pos>5,0</Pos>
+        <Pos>52,0</Pos>
         <Connection>
           <ConfigKey>[Skin],show_microphones</ConfigKey>
         </Connection>
@@ -39,7 +62,7 @@
           <Pressed>skin:/btn/btn_microphone_talkover_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_microphone_talkover_over.png</Unpressed>
         </State>
-        <Pos>5,14</Pos>
+        <Pos>52,14</Pos>
         <Connection>
           <ConfigKey>[Microphone<Variable name="micnum"/>],talkover</ConfigKey>
           <EmitOnPressAndRelease>true</EmitOnPressAndRelease>
@@ -60,7 +83,7 @@
           <Pressed>skin:/btn/btn_aux_mute_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_aux_mute_over.png</Unpressed>
         </State>
-        <Pos>5,35</Pos>
+        <Pos>52,35</Pos>
         <Connection>
           <ConfigKey>[Auxiliary<Variable name="auxnum"/>],main_mix</ConfigKey>
           <ButtonState>LeftButton</ButtonState>
@@ -85,7 +108,7 @@
           <Pressed>skin:/btn/btn_sampler_minus.png</Pressed>
           <Unpressed>skin:/btn/btn_sampler_minus.png</Unpressed>
         </State>
-        <Pos>53,0</Pos>
+        <Pos>100,0</Pos>
         <Connection>
           <ConfigKey>[Skin],show_samplers</ConfigKey>
         </Connection>
@@ -104,7 +127,7 @@
           <Pressed>skin:/btn/btn_pause_sampler_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_pause_sampler_over.png</Unpressed>
         </State>
-        <Pos>53,14</Pos>
+        <Pos>100,14</Pos>
         <Connection>
           <ConfigKey>[Sampler<Variable name="samplernum1"/>],cue_gotoandplay</ConfigKey>
           <ButtonState>LeftButton</ButtonState>
@@ -131,7 +154,7 @@
           <Pressed>skin:/btn/btn_pause_sampler_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_pause_sampler_over.png</Unpressed>
         </State>
-        <Pos>74,14</Pos>
+        <Pos>121,14</Pos>
         <Connection>
           <ConfigKey>[Sampler<Variable name="samplernum2"/>],cue_gotoandplay</ConfigKey>
           <ButtonState>LeftButton</ButtonState>
@@ -158,7 +181,7 @@
           <Pressed>skin:/btn/btn_pause_sampler_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_pause_sampler_over.png</Unpressed>
         </State>
-        <Pos>53,35</Pos>
+        <Pos>100,35</Pos>
         <Connection>
           <ConfigKey>[Sampler<Variable name="samplernum3"/>],cue_gotoandplay</ConfigKey>
           <ButtonState>LeftButton</ButtonState>
@@ -185,7 +208,7 @@
           <Pressed>skin:/btn/btn_pause_sampler_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_pause_sampler_over.png</Unpressed>
         </State>
-        <Pos>74,35</Pos>
+        <Pos>121,35</Pos>
         <Connection>
           <ConfigKey>[Sampler<Variable name="samplernum4"/>],cue_gotoandplay</ConfigKey>
           <ButtonState>LeftButton</ButtonState>
@@ -206,7 +229,7 @@
       -->
       <PushButton>
         <Size>54f,14f</Size>
-        <Pos>101,0</Pos>
+        <Pos>148,0</Pos>
         <NumberStates>2</NumberStates>
         <State>
           <Number>0</Number>
@@ -231,7 +254,7 @@
           <Pressed>skin:/btn/btn_beatjump_forward_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_beatjump_forward.png</Unpressed>
         </State>
-        <Pos>122,14</Pos>
+        <Pos>169,14</Pos>
         <Connection>
           <ConfigKey>[Channel<Variable name="channum"/>],beatjump_forward</ConfigKey>
           <ButtonState>LeftButton</ButtonState>
@@ -249,7 +272,7 @@
           <Pressed>skin:/btn/btn_beatjump_backward_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_beatjump_backward.png</Unpressed>
         </State>
-        <Pos>101,14</Pos>
+        <Pos>148,14</Pos>
         <Connection>
           <ConfigKey>[Channel<Variable name="channum"/>],beatjump_backward</ConfigKey>
           <ButtonState>LeftButton</ButtonState>
@@ -279,7 +302,7 @@
           <Pressed>skin:/btn/btn_reverse_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_reverse_over.png</Unpressed>
         </State>
-        <Pos>101,35</Pos>
+        <Pos>148,35</Pos>
         <Connection>
           <ConfigKey>[Channel<Variable name="channum"/>],reverse</ConfigKey>
           <EmitOnPressAndRelease>true</EmitOnPressAndRelease>
@@ -310,7 +333,7 @@
           <Pressed>skin:/btn/btn_loop_minus.png</Pressed>
           <Unpressed>skin:/btn/btn_loop_minus.png</Unpressed>
         </State>
-        <Pos>149,0</Pos>
+        <Pos>196,0</Pos>
         <Connection>
           <ConfigKey>[Skin],show_loop_beatjump_controls</ConfigKey>
         </Connection>
@@ -336,7 +359,7 @@
           <Pressed>skin:/btn/btn_beatloop_4_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_beatloop_4_over.png</Unpressed>
         </State>
-        <Pos>149,14</Pos>
+        <Pos>196,14</Pos>
         <Connection>
           <ConfigKey>[Channel<Variable name="channum"/>],beatloop_4_toggle</ConfigKey>
           <EmitOnPressAndRelease>true</EmitOnPressAndRelease>
@@ -358,7 +381,7 @@
       </PushButton>
       <PushButton>
         <TooltipId>reloop_toggle</TooltipId>
-        <Pos>170,14</Pos>
+        <Pos>217,14</Pos>
         <NumberStates>2</NumberStates>
         <LeftClickIsPushButton>true</LeftClickIsPushButton>
         <State>
@@ -393,7 +416,7 @@
           <Pressed>skin:/btn/btn_beatloop_halve_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_beatloop_halve.png</Unpressed>
         </State>
-        <Pos>149,35</Pos>
+        <Pos>196,35</Pos>
         <Connection>
           <ConfigKey>[Channel<Variable name="channum"/>],loop_halve</ConfigKey>
           <EmitOnPressAndRelease>true</EmitOnPressAndRelease>
@@ -408,7 +431,7 @@
           <Pressed>skin:/btn/btn_beatloop_double_overdown.png</Pressed>
           <Unpressed>skin:/btn/btn_beatloop_double.png</Unpressed>
         </State>
-        <Pos>170,35</Pos>
+        <Pos>217,35</Pos>
         <Connection>
           <ConfigKey>[Channel<Variable name="channum"/>],loop_double</ConfigKey>
           <EmitOnPressAndRelease>true</EmitOnPressAndRelease>
@@ -436,13 +459,13 @@
           <Pressed>skin:/btn/btn_intro_cues.png</Pressed>
           <Unpressed>skin:/btn/btn_intro_cues.png</Unpressed>
         </State>
-        <Pos>196,0</Pos>
+        <Pos>245,0</Pos>
         <Connection>
           <ConfigKey>[Skin],show_intro_outro_cues</ConfigKey>
         </Connection>
       </PushButton>
       <WidgetGroup><!-- Hotcues 1-4 -->
-        <Pos>197,14</Pos>
+        <Pos>244,14</Pos>
         <Size>43f,43f</Size>
         <Children>
           <Template src="skin:hotcue_button.xml">
@@ -469,7 +492,7 @@
         </Connection>
       </WidgetGroup>
       <WidgetGroup><!-- Special Cues -->
-        <Pos>197,14</Pos>
+        <Pos>244,14</Pos>
         <Size>43f,43f</Size>
         <Children>
           <PushButton>
diff --git a/res/skins/Shade/mixer_panel.xml b/res/skins/Shade/mixer_panel.xml
index aed8967856..b968cce10f 100644
--- a/res/skins/Shade/mixer_panel.xml
+++ b/res/skins/Shade/mixer_panel.xml
@@ -496,21 +496,30 @@
               Text- Clock display
               **********************************************
               -->
-              <Time>
-                <TooltipId>time</TooltipId>
+              <WidgetGroup>
+                <Pos>101,14</Pos>
+                <Size>50f,14f</Size>
+                <Layout>horizontal</Layout>
                 <Style>
-                  QLabel {
-                    font-size: 10px;
-                    font-weight: bold;
-                    background-color: transparent;
-                    color: #191F24;
-                    text-align:center;
+                  WWidgetGroup {
+                    align: center;
                   }
                 </Style>
-                <Pos>113,14</Pos>
-                <CustomFormat>hh:mm</CustomFormat>
-                <ShowSeconds>false</ShowSeconds>
-              </Time>
+                <Children>
+                  <Time>
+                    <TooltipId>time</TooltipId>
+                    <Style>
+                      QLabel {
+                        font-size: 10px;
+                        font-weight: bold;
+                        background-color: transparent;
+                        color: #191F24;
+                        text-align:center;
+                      }
+                    </Style>
+                  </Time>
+                </Children>
+              </WidgetGroup>
 
               <StatusLight>
                 <Pos>113,27</Pos>
diff --git a/res/skins/Shade/style.qss b/res/skins/Shade/style.qss
index bb48ce8acc..0a81cd2393 100644
--- a/res/skins/Shade/style.qss
+++ b/res/skins/Shade/style.qss
@@ -763,7 +763,7 @@ WTrackTableViewHeader {
 /*	Library header 'buttons'	*/
 WTrackTableViewHeader::section {
   height: 1.1em;
-  padding: 0.1em;
+  padding: 0.1em -0.7em 0.1em 0.1em;
   /*	set right border so that first column header
   on the left doesn't have double border on the left	*/
   border-right: 1px solid #0f0f0f;
@@ -1047,3 +1047,19 @@ WRateRange {
   font-size: 10px;
   qproperty-alignment: 'AlignCenter';
 }
+
+/** Stem control **/
+WStemControlBox {
+  background-color: transparent;
+}
+WStemControl WLabel {
+  padding-left: 5px;
+  font-weight: bold;
+  font-size: 14px;
+}
+WStemControl WKnob {
+  background-color: #717171;
+}
+WStemControl {
+  margin: 10px 15px 10px 15px;
+}
diff --git a/res/skins/Shade/style_dark.qss b/res/skins/Shade/style_dark.qss
index bfb776cff5..0c0b49540e 100644
--- a/res/skins/Shade/style_dark.qss
+++ b/res/skins/Shade/style_dark.qss
@@ -288,3 +288,19 @@ WTrackTableViewHeader::down-arrow {
 WRateRange {
   color: #181319;
 }
+
+/** Stem control **/
+WStemControlBox {
+  background-color: transparent;
+}
+WStemControl WLabel {
+  padding-left: 5px;
+  font-weight: bold;
+  font-size: 14px;
+}
+WStemControl WKnob {
+  background-color: #aab2b7;
+}
+WStemControl {
+  margin: 10px 15px 10px 15px;
+}
diff --git a/res/skins/Shade/style_summer_sunset.qss b/res/skins/Shade/style_summer_sunset.qss
index 560377cda8..e38dec7a3b 100644
--- a/res/skins/Shade/style_summer_sunset.qss
+++ b/res/skins/Shade/style_summer_sunset.qss
@@ -198,3 +198,19 @@ QPushButton#pushButtonAnalyze:hover {
 WRateRange {
   color: #4B515F;
 }
+
+/** Stem control **/
+WStemControlBox {
+  background-color: transparent;
+}
+WStemControl WLabel {
+  padding-left: 5px;
+  font-weight: bold;
+  font-size: 14px;
+}
+WStemControl WKnob {
+  background-color: #d9c663;
+}
+WStemControl {
+  margin: 10px 15px 10px 15px;
+}
diff --git a/res/skins/Shade/waveform.xml b/res/skins/Shade/waveform.xml
index 292d7e1c16..c0d6ec99de 100644
--- a/res/skins/Shade/waveform.xml
+++ b/res/skins/Shade/waveform.xml
@@ -108,5 +108,51 @@
     - if you change from a skin which supports more hotcues
       than buttons are in the current skin (and has them activated)
     -->
+    <StemControl alignment="left">
+      <MinimumSize>168,58</MinimumSize>
+      <MaximumSize>168,1920</MaximumSize>
+      <SizePolicy>me,me</SizePolicy>
+      <Stem>
+        <MinimumSize>130,14</MinimumSize>
+        <MaximumSize>150,1920</MaximumSize>
+        <SizePolicy>me,min</SizePolicy>
+        <Layout>horizontal</Layout>
+        <Children>
+          <Label>
+            <ObjectName>stem_label</ObjectName>
+            <SizePolicy>e,max</SizePolicy>
+          </Label>
+          <Knob>
+            <TooltipId>main_gain</TooltipId>
+            <NumberStates>64</NumberStates>
+            <Path>knobs_no_center/knob_rotary_s%1.png</Path>
+            <Pos>151,15</Pos>
+            <Connection>
+              <ConfigKey><Variable name="StemGroup"/>,volume</ConfigKey>
+            </Connection>
+          </Knob>
+          <EffectChainPresetSelector>
+            <ObjectName>QuickEffectSelectorLeft</ObjectName>
+            <MinimumSize>20,14</MinimumSize>
+            <MaximumSize>20,28</MaximumSize>
+            <SizePolicy>me,e</SizePolicy>
+            <EffectUnitGroup>[QuickEffectRack1_<Variable name="StemGroup"/>]</EffectUnitGroup>
+          </EffectChainPresetSelector>
+          <Knob>
+            <TooltipId>QuickEffectRack_super1</TooltipId>
+            <NumberStates>64</NumberStates>
+            <Path>knobs_no_center/knob_rotary_s%1.png</Path>
+            <Pos>151,15</Pos>
+            <Connection>
+              <ConfigKey>[QuickEffectRack1_<Variable name="StemGroup"/>],super1</ConfigKey>
+            </Connection>
+          </Knob>
+        </Children>
+      </Stem>
+      <Connection>
+        <ConfigKey persist="true">[Skin],show_stem_controls</ConfigKey>
+        <BindProperty>displayed</BindProperty>
+      </Connection>
+    </StemControl>
   </Visual>
 </Template>
diff --git a/res/skins/Tango/decks/row_comment_fx_left.xml b/res/skins/Tango/decks/row_comment_fx_left.xml
index 40f95d2f9f..053d6c5820 100644
--- a/res/skins/Tango/decks/row_comment_fx_left.xml
+++ b/res/skins/Tango/decks/row_comment_fx_left.xml
@@ -1,6 +1,6 @@
 <!--
 Description:
-  An extra line below/above waveform overview that contains FX asssign buttons and
+  An extra line below/above waveform overview that contains FX assign buttons and
   track comment (optional)
 Variables:
   chanNum : the channel number
diff --git a/res/skins/Tango/decks/row_comment_fx_right.xml b/res/skins/Tango/decks/row_comment_fx_right.xml
index 8bc9742cb5..4129921d12 100644
--- a/res/skins/Tango/decks/row_comment_fx_right.xml
+++ b/res/skins/Tango/decks/row_comment_fx_right.xml
@@ -1,6 +1,6 @@
 <!--
 Description:
-  An extra line below/above waveform overview that contains FX asssign buttons and
+  An extra line below/above waveform overview that contains FX assign buttons and
   track comment (optional)
 Variables:
   chanNum : the channel number
diff --git a/res/skins/Tango/skin_settings.xml b/res/skins/Tango/skin_settings.xml
index 53eee475eb..9931a6e976 100644
--- a/res/skins/Tango/skin_settings.xml
+++ b/res/skins/Tango/skin_settings.xml
@@ -63,6 +63,11 @@ Description:
             <SetVariable name="Setting">[Tango],symmetric_overviews</SetVariable>
           </Template>
 
+          <Template src="skins:Tango/controls/skin_settings_button_2state.xml">
+            <SetVariable name="text">Show stem control</SetVariable>
+            <SetVariable name="Setting">[Skin],show_stem_controls</SetVariable>
+          </Template>
+
           <Template src="skins:Tango/controls/skin_settings_button_2state.xml">
             <SetVariable name="text">Symmetric Time/Duration</SetVariable>
             <SetVariable name="Setting">[Tango],symmetric_time</SetVariable>
@@ -724,7 +729,7 @@ Description:
                 <MaximumSize>112,20</MaximumSize>
                 <SizePolicy>me,me</SizePolicy>
                 <Children>
-                  <!-- translucent cover when Samlers are hidden -->
+                  <!-- translucent cover when Samplers are hidden -->
                   <WidgetGroup>
                     <ObjectName>SubmenuCover</ObjectName>
                     <MinimumSize>112,13</MinimumSize>
diff --git a/res/skins/Tango/style.qss b/res/skins/Tango/style.qss
index 3fd548cc4f..0d7e674ce9 100644
--- a/res/skins/Tango/style.qss
+++ b/res/skins/Tango/style.qss
@@ -2756,7 +2756,7 @@ WTrackTableViewHeader {
   /*  Library header 'buttons'  */
   WTrackTableViewHeader::section {
     height: 1.1em;
-    padding: 0 0.1em;
+    padding: 0 -0.7em 0 0.1em;
     /*  use 'border-right' so that for the header of the leftmost column
     the border doesn't add to the border of the surrounding qtableview */
     border-right: 1px solid #585858;
@@ -2782,15 +2782,9 @@ WTrackTableViewHeader {
     WTrackTableViewHeader::up-arrow {
       image: url(skin:/../Tango/graphics/library_sort_up.svg);
       }
-      WTrackTableViewHeader::up-arrow:hover {
-        image: url(skin:/../Tango/graphics/library_sort_down.svg);
-      }
     WTrackTableViewHeader::down-arrow {
       image: url(skin:/../Tango/graphics/library_sort_down.svg);
       }
-      WTrackTableViewHeader::down-arrow:hover {
-        image: url(skin:/../Tango/graphics/library_sort_up.svg);
-      }
 
 WLibraryTextBrowser {
   padding-left: 5px;
@@ -3223,3 +3217,17 @@ WRateRange {
 #RateDisplayBottomRate {
     qproperty-alignment: 'AlignHCenter';
 }
+
+/** Stem control **/
+WStemControlBox {
+  padding-left: 8px;
+  background-color: transparent;
+}
+WStemControl WLabel {
+  padding-left: 5px;
+  font-weight: bold;
+  font-size: 14px;
+}
+WStemControl {
+  margin: 10px 15px 10px 15px;
+}
diff --git a/res/skins/Tango/topbar.xml b/res/skins/Tango/topbar.xml
index 72b6af6271..7132f50aa4 100644
--- a/res/skins/Tango/topbar.xml
+++ b/res/skins/Tango/topbar.xml
@@ -281,7 +281,9 @@ Description:
 
           <WidgetGroup><!-- Clock + latency display -->
             <ObjectName>ClockBox</ObjectName>
-            <Size>52f,28f</Size>
+            <MinimumSize>52,28</MinimumSize>
+            <MaximumSize>64,28</MaximumSize>
+            <SizePolicy>max</SizePolicy>
             <Layout>vertical</Layout>
             <Children>
 
@@ -292,9 +294,6 @@ Description:
                   <Time>
                     <TooltipId>time</TooltipId>
                     <ObjectName>Clock</ObjectName>
-                    <!-- <ShowSeconds>false</ShowSeconds>
-                    <ClockFormat>12AP</ClockFormat>
-                    This has no effect, neither has 'text-align' in qss.   -->
                     <Align>center</Align>
                   </Time>
                 </Children>
diff --git a/res/skins/Tango/waveform.xml b/res/skins/Tango/waveform.xml
index a1da2bb3ca..435b06e674 100644
--- a/res/skins/Tango/waveform.xml
+++ b/res/skins/Tango/waveform.xml
@@ -124,6 +124,85 @@ Variables:
           - if you change from a skin which supports more hotcues than buttons are in the current skin
           (and has them activated)
         -->
+        <StemControl alignment="left">
+          <MinimumSize>248me,68m</MinimumSize>
+          <Stem>
+            <MinimumSize>240,17</MinimumSize>
+            <MaximumSize>240,34</MaximumSize>
+            <SizePolicy>me,min</SizePolicy>
+            <Layout>horizontal</Layout>
+            <Children>
+              <Label>
+                <ObjectName>stem_label</ObjectName>
+                <SizePolicy>e,max</SizePolicy>
+              </Label>
+              <KnobComposed>
+                <Pos>0,0</Pos>
+                <MinimumSize>20,17</MinimumSize>
+                <MaximumSize>40,34</MaximumSize>
+                <SizePolicy>me,me</SizePolicy>
+                <Knob>skins:Tango/knobs_sliders/knob_blue.svg</Knob>
+                <BackPath>skins:Tango/knobs_sliders/knob_bg.svg</BackPath>
+                <MinAngle><Variable name="PotiMinAngle"/></MinAngle>
+                <MaxAngle><Variable name="PotiMaxAngle"/></MaxAngle>
+                <KnobCenterYOffset>2.000</KnobCenterYOffset>
+                <Connection>
+                  <ConfigKey><Variable name="StemGroup"/>,volume</ConfigKey>
+                </Connection>
+              </KnobComposed>
+              <EffectChainPresetSelector>
+                <ObjectName>QuickEffectSelectorLeft</ObjectName>
+                <MinimumSize>40,17</MinimumSize>
+                <MaximumSize>70,28</MaximumSize>
+                <SizePolicy>me,e</SizePolicy>
+                <EffectUnitGroup>[QuickEffectRack1_<Variable name="StemGroup"/>]</EffectUnitGroup>
+              </EffectChainPresetSelector>
+              <WidgetGroup>
+                <Size>21f,18f</Size>
+                <Children>
+                  <PushButton>
+                    <ObjectName>QuickFXButton</ObjectName>
+                    <Size>18f,18f</Size>
+                    <Pos>3,0</Pos>
+                    <NumberStates>2</NumberStates>
+                    <State>
+                      <Number>0</Number>
+                      <Pressed scalemode="STRETCH">buttons/btn_.svg</Pressed>
+                      <Unpressed scalemode="STRETCH">buttons/btn_.svg</Unpressed>
+                    </State>
+                    <State>
+                      <Number>1</Number>
+                      <Pressed scalemode="STRETCH">buttons/btn_.svg</Pressed>
+                      <Unpressed scalemode="STRETCH">buttons/btn_.svg</Unpressed>
+                    </State>
+                    <Connection>
+                      <ConfigKey>[QuickEffectRack1_<Variable name="StemGroup"/>],enabled</ConfigKey>
+                      <ButtonState>LeftButton</ButtonState>
+                    </Connection>
+                  </PushButton>
+                </Children>
+              </WidgetGroup>
+              <KnobComposed>
+                <TooltipId>QuickEffectRack_super1</TooltipId>
+                <Pos>0,0</Pos>
+                <MinimumSize>20,17</MinimumSize>
+                <MaximumSize>40,34</MaximumSize>
+                <SizePolicy>me,me</SizePolicy>
+                <Knob>skins:Tango/knobs_sliders/knob_blue.svg</Knob>
+                <BackPath>skins:Tango/knobs_sliders/knob_bg.svg</BackPath>
+                <MinAngle><Variable name="PotiMinAngle"/></MinAngle>
+                <MaxAngle><Variable name="PotiMaxAngle"/></MaxAngle>
+                <Connection>
+                  <ConfigKey>[QuickEffectRack1_<Variable name="StemGroup"/>],super1</ConfigKey>
+                </Connection>
+              </KnobComposed>
+            </Children>
+          </Stem>
+          <Connection>
+            <ConfigKey persist="true">[Skin],show_stem_controls</ConfigKey>
+            <BindProperty>displayed</BindProperty>
+          </Connection>
+        </StemControl>
       </Visual>
 
       <WidgetGroup><!-- Transparent container for beatgrid buttons -->
diff --git a/src/RCa10948 b/src/RCa10948
new file mode 100644
index 0000000000..7487ae5139
Binary files /dev/null and b/src/RCa10948 differ
diff --git a/src/analyzer/analyzergain.cpp b/src/analyzer/analyzergain.cpp
index 4007b4c1cc..7b53517f77 100644
--- a/src/analyzer/analyzergain.cpp
+++ b/src/analyzer/analyzergain.cpp
@@ -7,18 +7,15 @@
 #include "analyzer/analyzertrack.h"
 #include "analyzer/constants.h"
 #include "track/track.h"
-#include "util/math.h"
 #include "util/sample.h"
 #include "util/timer.h"
 
 AnalyzerGain::AnalyzerGain(UserSettingsPointer pConfig)
-        : m_rgSettings(pConfig) {
-    m_pReplayGain = new ReplayGain();
+        : m_rgSettings(pConfig),
+          m_pReplayGain(std::make_unique<ReplayGain>()) {
 }
 
-AnalyzerGain::~AnalyzerGain() {
-    delete m_pReplayGain;
-}
+AnalyzerGain::~AnalyzerGain() = default;
 
 bool AnalyzerGain::initialize(const AnalyzerTrack& track,
         mixxx::audio::SampleRate sampleRate,
diff --git a/src/analyzer/analyzergain.h b/src/analyzer/analyzergain.h
index a690a34b6f..6aa8a3ff14 100644
--- a/src/analyzer/analyzergain.h
+++ b/src/analyzer/analyzergain.h
@@ -7,6 +7,7 @@
 
 #pragma once
 
+#include <memory>
 #include <vector>
 
 #include "analyzer/analyzer.h"
@@ -36,5 +37,5 @@ class AnalyzerGain : public Analyzer {
     std::vector<CSAMPLE> m_pLeftTempBuffer;
     std::vector<CSAMPLE> m_pRightTempBuffer;
     mixxx::audio::ChannelCount m_channelCount;
-    ReplayGain* m_pReplayGain;
+    std::unique_ptr<ReplayGain> m_pReplayGain;
 };
diff --git a/src/analyzer/analyzersilence.cpp b/src/analyzer/analyzersilence.cpp
index d950c4ab8a..a1b463a121 100644
--- a/src/analyzer/analyzersilence.cpp
+++ b/src/analyzer/analyzersilence.cpp
@@ -67,9 +67,6 @@ SINT AnalyzerSilence::findFirstSoundInChunk(std::span<const CSAMPLE> samples) {
 SINT AnalyzerSilence::findLastSoundInChunk(std::span<const CSAMPLE> samples) {
     // -1 is required, because the distance from the fist sample index (0) to crend() is 1,
     SINT ret = std::distance(first_sound(samples.rbegin(), samples.rend()), samples.rend()) - 1;
-    if (ret == -1) {
-        ret = samples.size();
-    }
     return ret;
 }
 
@@ -98,7 +95,7 @@ bool AnalyzerSilence::processSamples(const CSAMPLE* pIn, SINT count) {
     }
     if (m_signalStart >= 0) {
         const SINT lastSoundSample = findLastSoundInChunk(samples);
-        if (lastSoundSample < count - 1) { // not only sound or silence
+        if (lastSoundSample >= 0) {
             m_signalEnd = m_framesProcessed + lastSoundSample / m_channelCount + 1;
         }
     }
diff --git a/src/analyzer/constants.h b/src/analyzer/constants.h
index 42d84db721..5e670a37dc 100644
--- a/src/analyzer/constants.h
+++ b/src/analyzer/constants.h
@@ -10,7 +10,6 @@ namespace mixxx {
 // fixed number of channels like the engine does, usually 2 = stereo.
 constexpr audio::ChannelCount kAnalysisChannels = mixxx::kEngineChannelOutputCount;
 constexpr audio::ChannelCount kAnalysisMaxChannels = mixxx::kMaxEngineChannelInputCount;
-constexpr int kMaxSupportedStems = 4;
 constexpr SINT kAnalysisFramesPerChunk = 4096;
 constexpr SINT kAnalysisSamplesPerChunk =
         kAnalysisFramesPerChunk * kAnalysisMaxChannels;
diff --git a/src/broadcast/broadcastmanager.cpp b/src/broadcast/broadcastmanager.cpp
index 0298e596ea..f3e9e25b6b 100644
--- a/src/broadcast/broadcastmanager.cpp
+++ b/src/broadcast/broadcastmanager.cpp
@@ -22,7 +22,7 @@ BroadcastManager::BroadcastManager(SettingsManager* pSettingsManager,
     const bool persist = true;
     m_pBroadcastEnabled = new ControlPushButton(
             ConfigKey(BROADCAST_PREF_KEY,"enabled"), persist);
-    m_pBroadcastEnabled->setButtonMode(ControlPushButton::TOGGLE);
+    m_pBroadcastEnabled->setButtonMode(mixxx::control::ButtonMode::Toggle);
     connect(m_pBroadcastEnabled,
             &ControlPushButton::valueChanged,
             this,
diff --git a/src/control/control.cpp b/src/control/control.cpp
index c6a88b889f..ef2066baf0 100644
--- a/src/control/control.cpp
+++ b/src/control/control.cpp
@@ -30,14 +30,14 @@ QWeakPointer<ControlDoublePrivate> s_pDefaultCO;
 } // namespace
 
 ControlDoublePrivate::ControlDoublePrivate()
-        : m_bPersistInConfiguration(false),
-          m_bIgnoreNops(true),
-          m_bTrack(false),
-          m_trackType(Stat::UNSPECIFIED),
+        : m_trackType(Stat::UNSPECIFIED),
           m_trackFlags(Stat::COUNT | Stat::SUM | Stat::AVERAGE |
                   Stat::SAMPLE_VARIANCE | Stat::MIN | Stat::MAX),
+          m_bTrack(false),
           // default CO is read only
           m_confirmRequired(true),
+          m_bPersistInConfiguration(false),
+          m_bIgnoreNops(true),
           m_kbdRepeatable(false) {
     m_value.setValue(0.0);
 }
@@ -51,13 +51,13 @@ ControlDoublePrivate::ControlDoublePrivate(
         double defaultValue)
         : m_key(key),
           m_pCreatorCO(pCreatorCO),
-          m_bPersistInConfiguration(bPersist),
-          m_bIgnoreNops(bIgnoreNops),
-          m_bTrack(bTrack),
           m_trackType(Stat::UNSPECIFIED),
           m_trackFlags(Stat::COUNT | Stat::SUM | Stat::AVERAGE |
                   Stat::SAMPLE_VARIANCE | Stat::MIN | Stat::MAX),
+          m_bTrack(bTrack),
           m_confirmRequired(false),
+          m_bPersistInConfiguration(bPersist),
+          m_bIgnoreNops(bIgnoreNops),
           m_kbdRepeatable(false) {
     initialize(defaultValue);
 }
diff --git a/src/control/control.h b/src/control/control.h
index a33c4648f1..ba7da689ca 100644
--- a/src/control/control.h
+++ b/src/control/control.h
@@ -183,8 +183,31 @@ class ControlDoublePrivate : public QObject {
 
     const ConfigKey m_key;
 
+    QSharedPointer<ControlNumericBehavior> m_pBehavior;
+
+    // User-visible, i18n name for what the control is.
+    QString m_name;
+
+    // User-visible, i18n description for what the control does.
+    QString m_description;
+
+    // The control value.
+    ControlValueAtomic<double> m_value;
+    // The default control value.
+    ControlValueAtomic<double> m_defaultValue;
+
     QAtomicPointer<ControlObject> m_pCreatorCO;
 
+    QString m_trackKey;
+
+    // Note: keep the order of the members below to not introduce gaps due to
+    // memory alignment in this often used class. Whether to track value changes
+    // with the stats framework.
+    int m_trackType;
+    int m_trackFlags;
+    bool m_bTrack;
+    bool m_confirmRequired;
+
     // Whether the control should persist in the Mixxx user configuration. The
     // value is loaded from configuration when the control is created and
     // written to the configuration when the control is deleted.
@@ -193,28 +216,10 @@ class ControlDoublePrivate : public QObject {
     // Whether to ignore sets which would have no effect.
     bool m_bIgnoreNops;
 
-    // Whether to track value changes with the stats framework.
-    bool m_bTrack;
-    QString m_trackKey;
-    int m_trackType;
-    int m_trackFlags;
-    bool m_confirmRequired;
-
-    // User-visible, i18n name for what the control is.
-    QString m_name;
-
-    // User-visible, i18n description for what the control does.
-    QString m_description;
 
     // If true, this control will be issued repeatedly if the keyboard key is held.
     bool m_kbdRepeatable;
 
-    // The control value.
-    ControlValueAtomic<double> m_value;
-    // The default control value.
-    ControlValueAtomic<double> m_defaultValue;
-
-    QSharedPointer<ControlNumericBehavior> m_pBehavior;
 };
 
 /// The constant ControlDoublePrivate version is used as dummy for default
diff --git a/src/control/controlbehavior.cpp b/src/control/controlbehavior.cpp
index c4dbfddb86..33ab059de3 100644
--- a/src/control/controlbehavior.cpp
+++ b/src/control/controlbehavior.cpp
@@ -342,8 +342,8 @@ double ControlLinSteppedIntPotBehavior::parameterToValue(double dParam) {
 const int ControlPushButtonBehavior::kPowerWindowTimeMillis = 300;
 const int ControlPushButtonBehavior::kLongPressLatchingTimeMillis = 300;
 
-ControlPushButtonBehavior::ControlPushButtonBehavior(ButtonMode buttonMode,
-                                                     int iNumStates)
+ControlPushButtonBehavior::ControlPushButtonBehavior(mixxx::control::ButtonMode buttonMode,
+        int iNumStates)
         : m_buttonMode(buttonMode),
           m_iNumStates(iNumStates) {
 }
@@ -364,7 +364,7 @@ void ControlPushButtonBehavior::setValueFromMidi(
     }
 
     // This block makes push-buttons act as power window buttons.
-    if (m_buttonMode == POWERWINDOW && m_iNumStates == 2) {
+    if (m_buttonMode == mixxx::control::ButtonMode::PowerWindow && m_iNumStates == 2) {
         auto* timer = getTimer();
         if (pressed) {
             // Toggle on press
@@ -376,7 +376,8 @@ void ControlPushButtonBehavior::setValueFromMidi(
             // Disable after releasing a long press
             pControl->set(0., nullptr);
         }
-    } else if (m_buttonMode == TOGGLE || m_buttonMode == LONGPRESSLATCHING) {
+    } else if (m_buttonMode == mixxx::control::ButtonMode::Toggle ||
+            m_buttonMode == mixxx::control::ButtonMode::LongPressLatching) {
         // This block makes push-buttons act as toggle buttons.
         if (m_iNumStates > 1) { // multistate button
             if (pressed) {
@@ -387,14 +388,14 @@ void ControlPushButtonBehavior::setValueFromMidi(
                 double value = pControl->get();
                 value = (int)(value + 1.) % m_iNumStates;
                 pControl->set(value, nullptr);
-                if (m_buttonMode == LONGPRESSLATCHING) {
+                if (m_buttonMode == mixxx::control::ButtonMode::LongPressLatching) {
                     auto* timer = getTimer();
                     timer->setSingleShot(true);
                     timer->start(kLongPressLatchingTimeMillis);
                 }
             } else {
                 double value = pControl->get();
-                if (m_buttonMode == LONGPRESSLATCHING &&
+                if (m_buttonMode == mixxx::control::ButtonMode::LongPressLatching &&
                         getTimer()->isActive() && value >= 1.) {
                     // revert toggle if button is released too early
                     value = (int)(value - 1.) % m_iNumStates;
diff --git a/src/control/controlbehavior.h b/src/control/controlbehavior.h
index 9d87a346c4..52c0c14d17 100644
--- a/src/control/controlbehavior.h
+++ b/src/control/controlbehavior.h
@@ -1,8 +1,9 @@
 #pragma once
 
-#include <QTimer>
 #include <QScopedPointer>
+#include <QTimer>
 
+#include "control/controlbuttonmode.h"
 #include "controllers/midi/midimessage.h"
 
 class ControlDoublePrivate;
@@ -130,17 +131,7 @@ class ControlPushButtonBehavior : public ControlNumericBehavior {
     static const int kPowerWindowTimeMillis;
     static const int kLongPressLatchingTimeMillis;
 
-    // TODO(XXX) Duplicated from ControlPushButton. It's complicated and
-    // annoying to share them so I just copied them.
-    enum ButtonMode {
-         PUSH = 0,
-         TOGGLE,
-         POWERWINDOW,
-         LONGPRESSLATCHING,
-         TRIGGER
-    };
-
-    ControlPushButtonBehavior(ButtonMode buttonMode, int iNumStates);
+    ControlPushButtonBehavior(mixxx::control::ButtonMode buttonMode, int iNumStates);
     void setValueFromMidi(
             MidiOpCode o, double dParam, ControlDoublePrivate* pControl)
                 override;
@@ -154,7 +145,7 @@ class ControlPushButtonBehavior : public ControlNumericBehavior {
         }
         return m_pushTimer.data();
     }
-    ButtonMode m_buttonMode;
+    mixxx::control::ButtonMode m_buttonMode;
     int m_iNumStates;
     QScopedPointer<QTimer> m_pushTimer;
 };
diff --git a/src/control/controlbuttonmode.h b/src/control/controlbuttonmode.h
new file mode 100644
index 0000000000..8be1210a7b
--- /dev/null
+++ b/src/control/controlbuttonmode.h
@@ -0,0 +1,23 @@
+#pragma once
+
+// required for Qt-Macros
+#include <qobjectdefs.h>
+
+namespace mixxx {
+
+namespace control {
+
+Q_NAMESPACE
+
+enum class ButtonMode {
+    Push,
+    Toggle,
+    PowerWindow,
+    LongPressLatching,
+    Trigger
+};
+
+Q_ENUM_NS(ButtonMode);
+
+} // namespace control
+} // namespace mixxx
diff --git a/src/control/controlmodel.cpp b/src/control/controlmodel.cpp
index 142b050d6c..73d818db4f 100644
--- a/src/control/controlmodel.cpp
+++ b/src/control/controlmodel.cpp
@@ -20,6 +20,9 @@ ControlModel::ControlModel(QObject* pParent)
 
     QSet<ConfigKey> controlKeys;
 
+    // Reserve memory for m_controls, which will be used later in addControl
+    m_controls.reserve(controlsList.size());
+
     for (const QSharedPointer<ControlDoublePrivate>& pControl : controlsList) {
         if (!pControl) {
             continue;
diff --git a/src/control/controlpushbutton.cpp b/src/control/controlpushbutton.cpp
index 1a3b2a1f3b..a3b44dc265 100644
--- a/src/control/controlpushbutton.cpp
+++ b/src/control/controlpushbutton.cpp
@@ -8,39 +8,50 @@
    -------- ------------------------------------------------------ */
 ControlPushButton::ControlPushButton(const ConfigKey& key, bool bPersist, double defaultValue)
         : ControlObject(key, false, false, bPersist, defaultValue),
-          m_buttonMode(PUSH),
+          m_buttonMode(mixxx::control::ButtonMode::Push),
           m_iNoStates(2) {
-    if (m_pControl) {
-        m_pControl->setBehavior(
-                new ControlPushButtonBehavior(
-                        static_cast<ControlPushButtonBehavior::ButtonMode>(m_buttonMode),
-                        m_iNoStates));
+    updateBehavior();
+}
+
+ControlPushButton::~ControlPushButton() = default;
+
+void ControlPushButton::setButtonMode(mixxx::control::ButtonMode mode) {
+    if (m_buttonMode != mode) {
+        m_buttonMode = mode;
+        updateBehavior();
     }
 }
 
-ControlPushButton::~ControlPushButton() {
+void ControlPushButton::setStates(int num_states) {
+    if (m_iNoStates != num_states) {
+        m_iNoStates = num_states;
+        updateBehavior();
+    }
 }
 
-// Tell this PushButton how to act on rising and falling edges
-void ControlPushButton::setButtonMode(enum ButtonMode mode) {
-    //qDebug() << "Setting " << m_Key.group << m_Key.item << "as toggle";
-    m_buttonMode = mode;
+void ControlPushButton::setBehavior(mixxx::control::ButtonMode mode, int num_states) {
+    bool shouldUpdate = false;
+    if (m_buttonMode != mode) {
+        m_buttonMode = mode;
+        shouldUpdate = true;
+    }
+    if (m_iNoStates != num_states) {
+        m_iNoStates = num_states;
+        shouldUpdate = true;
+    }
+
+    // If we would update unconditional, the state would be set always to the default value
+    if (shouldUpdate) {
+        updateBehavior();
+    }
+}
 
+// private
+void ControlPushButton::updateBehavior() {
     if (m_pControl) {
         m_pControl->setBehavior(
                 new ControlPushButtonBehavior(
-                        static_cast<ControlPushButtonBehavior::ButtonMode>(m_buttonMode),
+                        m_buttonMode,
                         m_iNoStates));
     }
 }
-
-void ControlPushButton::setStates(int num_states) {
-    m_iNoStates = num_states;
-
-    if (m_pControl) {
-            m_pControl->setBehavior(
-                    new ControlPushButtonBehavior(
-                            static_cast<ControlPushButtonBehavior::ButtonMode>(m_buttonMode),
-                            m_iNoStates));
-    }
-}
diff --git a/src/control/controlpushbutton.h b/src/control/controlpushbutton.h
index d523ee5329..e914cd0c30 100644
--- a/src/control/controlpushbutton.h
+++ b/src/control/controlpushbutton.h
@@ -1,69 +1,40 @@
-/***************************************************************************
-                          controlpushbutton.h  -  description
-                             -------------------
-    begin                : Wed Feb 20 2002
-    copyright            : (C) 2002 by Tue and Ken Haste Andersen
-    email                :
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef CONTROLPUSHBUTTON_H
-#define CONTROLPUSHBUTTON_H
+#pragma once
 
+#include "control/controlbuttonmode.h"
 #include "control/controlobject.h"
 
-/**
-  *@author Tue and Ken Haste Andersen
-  */
-
 class ControlPushButton : public ControlObject {
     Q_OBJECT
   public:
-    enum ButtonMode {
-         PUSH = 0,
-         TOGGLE,
-         POWERWINDOW,
-         LONGPRESSLATCHING,
-         TRIGGER,
-    };
-
-    static QString buttonModeToString(int mode) {
-        switch(mode) {
-            case ControlPushButton::PUSH:
-                return "PUSH";
-            case ControlPushButton::TOGGLE:
-                return "TOGGLE";
-            case ControlPushButton::POWERWINDOW:
-                return "POWERWINDOW";
-            case ControlPushButton::LONGPRESSLATCHING:
-                return "LONGPRESSLATCHING";
-            case ControlPushButton::TRIGGER:
-                return "TRIGGER";
-            default:
-                return "UNKNOWN";
+    static QString buttonModeToString(mixxx::control::ButtonMode buttonMode) {
+        switch (buttonMode) {
+        case mixxx::control::ButtonMode::Push:
+            return QStringLiteral("Push");
+        case mixxx::control::ButtonMode::Toggle:
+            return QStringLiteral("Toggle");
+        case mixxx::control::ButtonMode::PowerWindow:
+            return QStringLiteral("PowerWindow");
+        case mixxx::control::ButtonMode::LongPressLatching:
+            return QStringLiteral("LongPressLatching");
+        case mixxx::control::ButtonMode::Trigger:
+            return QStringLiteral("Trigger");
         }
+        DEBUG_ASSERT(false);
+        return "Unknown";
     }
 
     ControlPushButton(const ConfigKey& key, bool bPersist = false, double defaultValue = 0.0);
     virtual ~ControlPushButton();
 
-    inline ButtonMode getButtonMode() const {
+    inline mixxx::control::ButtonMode getButtonMode() const {
         return m_buttonMode;
     }
-    void setButtonMode(enum ButtonMode mode);
+    void setButtonMode(mixxx::control::ButtonMode mode);
     void setStates(int num_states);
+    void setBehavior(mixxx::control::ButtonMode mode, int num_states);
 
   private:
-    enum ButtonMode m_buttonMode;
+    void updateBehavior();
+    enum mixxx::control::ButtonMode m_buttonMode;
     int m_iNoStates;
 };
-
-#endif
diff --git a/src/control/controlvalue.h b/src/control/controlvalue.h
index 0361cbafb7..0858c6dc80 100644
--- a/src/control/controlvalue.h
+++ b/src/control/controlvalue.h
@@ -1,20 +1,20 @@
 #pragma once
 
-#include <QAtomicInt>
-#include <QObject>
+#include <atomic>
+#include <bit>
+#include <cstddef>
 #include <limits>
 
-#include "util/assert.h"
-#include "util/compatibility/qatomic.h"
+namespace {
 
 // for lock free access, this value has to be >= the number of value using threads
 // value must be a fraction of an integer
-constexpr int kDefaultRingSize = 8;
+constexpr std::size_t kDefaultRingSize = 8;
 // there are basically unlimited readers allowed at each ring element
 // but we have to count them so max() is just fine.
-// NOTE(rryan): Wrapping max with parentheses avoids conflict with the max macro
-// defined in windows.h.
-constexpr int kMaxReaderSlots = (std::numeric_limits<int>::max)();
+constexpr std::size_t kMaxReaderSlots = std::numeric_limits<std::size_t>::max();
+
+} // namespace
 
 // A single instance of a value of type T along with an atomic integer which
 // tracks the current number of readers or writers of the slot. The value
@@ -35,26 +35,27 @@ class ControlRingValue {
     // slot, because the stored value is preserved.
     bool tryGet(T* value) const {
         // Read while consuming one readerSlot
-        if (m_readerSlots.fetchAndAddAcquire(-1) > 0) {
+        if (m_readerSlots.fetch_sub(1, std::memory_order_acquire) > 0) {
             // Reader slot has been acquired, no writer is active
             *value = m_value;
-            m_readerSlots.fetchAndAddRelease(1);
+            m_readerSlots.fetch_add(1, std::memory_order_release);
             // We need the early return here to make the compiler
             // aware that *value is initialised in the true case.
             return true;
         }
-        m_readerSlots.fetchAndAddRelease(1);
+        m_readerSlots.fetch_add(1, std::memory_order_release);
         return false;
     }
 
     bool trySet(const T& value) {
         // try to lock this element entirely for reading
-        if (m_readerSlots.testAndSetAcquire(kMaxReaderSlots, 0)) {
+        std::size_t expected = kMaxReaderSlots;
+        if (m_readerSlots.compare_exchange_strong(expected, 0, std::memory_order_acquire)) {
             m_value = value;
             // We need to re-add kMaxReaderSlots instead of storing it
             // to keep the balance if readers have decreased the number
             // of slots in the meantime!
-            m_readerSlots.fetchAndAddRelease(kMaxReaderSlots);
+            m_readerSlots.fetch_add(kMaxReaderSlots, std::memory_order_release);
             return true;
         }
         return false;
@@ -62,7 +63,9 @@ class ControlRingValue {
 
   private:
     T m_value;
-    mutable QAtomicInt m_readerSlots;
+    mutable std::atomic<std::size_t> m_readerSlots;
+    static_assert(std::atomic<std::size_t>::is_always_lock_free,
+            "atomics used for lock-free data storage are not lock-free");
 };
 
 // Ring buffer based implementation for all Types sizeof(T) > sizeof(void*)
@@ -71,12 +74,15 @@ class ControlRingValue {
 // ring-buffer of ControlRingValues and a read pointer and write pointer to
 // provide getValue()/setValue() methods which *sacrifice perfect consistency*
 // for the benefit of wait-free read/write access to a value.
-template <typename T, int cRingSize, bool ATOMIC = false>
+template<typename T, std::size_t cRingSize, bool ATOMIC = false>
 class ControlValueAtomicBase {
+    static_assert(std::has_single_bit(cRingSize),
+            "cRingSize is not a power of two; required for optimal alignment");
+
   public:
-    inline T getValue() const {
+    T getValue() const {
         T value;
-        unsigned int index = static_cast<unsigned int>(atomicLoadRelaxed(m_readIndex)) % cRingSize;
+        std::size_t index = m_readIndex.load(std::memory_order_relaxed) % cRingSize;
         while (!m_ring[index].tryGet(&value)) {
             // We are here if
             // 1) there are more then kMaxReaderSlots reader (get) reading the same value or
@@ -91,12 +97,12 @@ class ControlValueAtomicBase {
         return value;
     }
 
-    inline void setValue(const T& value) {
+    void setValue(const T& value) {
         // Test if we can read atomic
         // This test is const and will be mad only at compile time
-        unsigned int index;
+        std::size_t index;
         do {
-            index = static_cast<unsigned int>(m_writeIndex.fetchAndAddAcquire(1)) % cRingSize;
+            index = m_writeIndex.fetch_add(1, std::memory_order_acquire) % cRingSize;
             // This will be repeated if the value is locked
             // 1) by another writer writing at the same time or
             // 2) a delayed reader is still blocking the formerly current value
@@ -107,61 +113,62 @@ class ControlValueAtomicBase {
 
   protected:
     ControlValueAtomicBase() : m_readIndex(0), m_writeIndex(1) {
-        // NOTE(rryan): Wrapping max with parentheses avoids conflict with the
-        // max macro defined in windows.h.
-        DEBUG_ASSERT(((std::numeric_limits<unsigned int>::max)() % cRingSize) == (cRingSize - 1));
+    }
+    ControlValueAtomicBase(const T& value)
+            : ControlValueAtomicBase() {
+        setValue(value);
     }
 
   private:
     // In worst case, each reader can consume a reader slot from a different ring element.
     // In this case there is still one ring element available for writing.
     ControlRingValue<T> m_ring[cRingSize];
-    QAtomicInt m_readIndex;
-    QAtomicInt m_writeIndex;
+    std::atomic<std::size_t> m_readIndex;
+    std::atomic<std::size_t> m_writeIndex;
+    static_assert(std::atomic<std::size_t>::is_always_lock_free,
+            "atomics used for lock-free data storage are not lock-free");
 };
 
 // Specialized template for types that are deemed to be atomic on the target
 // architecture. Instead of using a read/write ring to guarantee atomicity,
 // direct assignment/read of an aligned member variable is used.
-template<typename T, int cRingSize>
+template<typename T, std::size_t cRingSize>
 class ControlValueAtomicBase<T, cRingSize, true> {
   public:
-    inline T getValue() const {
+    T getValue() const {
         return m_value;
     }
 
-    inline T getValueOnce() {
-        return std::move(m_value);
-    }
-
-    inline void setValue(const T& value) {
+    void setValue(const T& value) {
         m_value = value;
     }
 
   protected:
     ControlValueAtomicBase() = default;
+    ControlValueAtomicBase(const T& value)
+            : m_value(value){};
 
   private:
-#if defined(__GNUC__)
-    T m_value __attribute__((aligned(sizeof(void*))));
-#elif defined(_MSC_VER)
-#ifdef _WIN64
-    T __declspec(align(8)) m_value;
-#else
-    T __declspec(align(4)) m_value;
-#endif
-#else
-    T m_value;
-#endif
+    std::atomic<T> m_value;
+    static_assert(std::atomic<T>::is_always_lock_free);
 };
 
-// ControlValueAtomic is a wrapper around ControlValueAtomicBase which uses the
-// sizeof(T) to determine which underlying implementation of
-// ControlValueAtomicBase to use. For types where sizeof(T) <= sizeof(void*),
-// the specialized implementation of ControlValueAtomicBase for types that are
-// atomic on the architecture is used.
-template <typename T, int cRingSize = kDefaultRingSize>
-class ControlValueAtomic : public ControlValueAtomicBase<T, cRingSize, sizeof(T) <= sizeof(void*)> {
+template<typename T, std::size_t cRingSize = kDefaultRingSize>
+class ControlValueAtomic : public ControlValueAtomicBase<T,
+                                   cRingSize,
+                                   std::atomic<T>::is_always_lock_free> {
+    // naming the parent class is tedious because all template parameters have to be specified,
+    // so this alias makes it a little more manageable.
+    using ParentT = ControlValueAtomicBase<T, cRingSize, std::atomic<T>::is_always_lock_free>;
+
+    static_assert(!(!std::atomic<T>::is_always_lock_free &&
+                          sizeof(T) <= sizeof(void*)),
+            "T is not lock free even though it is smaller than void*! Consider "
+            "using `std::atomic<T>::is_lock_free()` to only fallback to the "
+            "eventually-consistent ControlValueAtomicBase when necessary");
+
   public:
     ControlValueAtomic() = default;
+    ControlValueAtomic(const T& value)
+            : ParentT(value){};
 };
diff --git a/src/controllers/hid/hidioglobaloutputreportfifo.cpp b/src/controllers/hid/hidioglobaloutputreportfifo.cpp
index 51314be272..f68b680b32 100644
--- a/src/controllers/hid/hidioglobaloutputreportfifo.cpp
+++ b/src/controllers/hid/hidioglobaloutputreportfifo.cpp
@@ -54,7 +54,7 @@ bool HidIoGlobalOutputReportFifo::sendNextReportDataset(QMutex* pHidDeviceAndPol
     if (pFront == nullptr) {
         // No data in FIFO to be send
         // Return with false, to signal the caller, that no time consuming IO
-        // operation was ncessary
+        // operation was necessary
         return false;
     }
 
diff --git a/src/controllers/keyboard/keyboardeventfilter.cpp b/src/controllers/keyboard/keyboardeventfilter.cpp
index 56702ce427..b520388595 100644
--- a/src/controllers/keyboard/keyboardeventfilter.cpp
+++ b/src/controllers/keyboard/keyboardeventfilter.cpp
@@ -149,36 +149,34 @@ bool KeyboardEventFilter::eventFilter(QObject*, QEvent* e) {
 
 // static
 QKeySequence KeyboardEventFilter::getKeySeq(QKeyEvent* e) {
-    QKeySequence k;
-
     if ((e->key() >= Qt::Key_Shift && e->key() <= Qt::Key_Alt) ||
             e->key() == Qt::Key_AltGr) {
         // Do not act on Modifier only, Shift, Ctrl, Meta, Alt and AltGr
         // avoid returning "khmer vowel sign ie (U+17C0)"
-        return k;
+        return {};
     }
 
+    // Note: test for individual modifiers, don't use e->modifiers() for composing
+    // the QKeySequence because on macOS arrow key events are sent with the Num
+    // modifier for some reason. This result in a key sequence for which there
+    // would be no match in our keyseq/control hash.
+    // See https://github.com/mixxxdj/mixxx/issues/13305
     QString modseq;
-    // TODO(XXX) check if we may simply return QKeySequence(e->modifiers()+e->key())
-
     if (e->modifiers() & Qt::ShiftModifier) {
         modseq += "Shift+";
     }
-
     if (e->modifiers() & Qt::ControlModifier) {
         modseq += "Ctrl+";
     }
-
     if (e->modifiers() & Qt::AltModifier) {
         modseq += "Alt+";
     }
-
     if (e->modifiers() & Qt::MetaModifier) {
         modseq += "Meta+";
     }
 
-    QString keyseq = QKeySequence(e->key()).toString();
-    k = QKeySequence(modseq + keyseq);
+    const QString keyseq = QKeySequence(e->key()).toString();
+    const QKeySequence k = QKeySequence(modseq + keyseq);
 
     if (CmdlineArgs::Instance().getDeveloper()) {
         if (e->type() == QEvent::KeyPress) {
@@ -188,11 +186,7 @@ QKeySequence KeyboardEventFilter::getKeySeq(QKeyEvent* e) {
         }
     }
 
-#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
-    return QKeySequence(e->modifiers() | e->key());
-#else
-    return QKeySequence(e->modifiers() + e->key());
-#endif
+    return k;
 }
 
 void KeyboardEventFilter::setKeyboardConfig(ConfigObject<ConfigValueKbd>* pKbdConfigObject) {
diff --git a/src/controllers/legacycontrollermapping.h b/src/controllers/legacycontrollermapping.h
index 3c74c7c858..17dec26338 100644
--- a/src/controllers/legacycontrollermapping.h
+++ b/src/controllers/legacycontrollermapping.h
@@ -154,8 +154,8 @@ class LegacyControllerMapping {
     /// @brief Set a setting layout as they should be perceived when edited in
     /// the preference dialog.
     /// @param layout The layout root element
-    void setSettingLayout(std::unique_ptr<LegacyControllerSettingsLayoutElement>&& layout) {
-        VERIFY_OR_DEBUG_ASSERT(layout.get()) {
+    void setSettingLayout(std::unique_ptr<LegacyControllerSettingsLayoutElement> layout) {
+        VERIFY_OR_DEBUG_ASSERT(layout) {
             return;
         }
         m_settingsLayout = std::move(layout);
diff --git a/src/controllers/legacycontrollersettingslayout.h b/src/controllers/legacycontrollersettingslayout.h
index 37ae2aec0b..ee967e2baf 100644
--- a/src/controllers/legacycontrollersettingslayout.h
+++ b/src/controllers/legacycontrollersettingslayout.h
@@ -57,7 +57,7 @@ class LegacyControllerSettingsLayoutContainer : public LegacyControllerSettingsL
     /// the right parameters
     /// @param setting The controller setting to add to the layout container
     void addItem(std::shared_ptr<AbstractLegacyControllerSetting> setting);
-    void addItem(std::unique_ptr<LegacyControllerSettingsLayoutContainer>&& container) {
+    void addItem(std::unique_ptr<LegacyControllerSettingsLayoutContainer> container) {
         m_elements.push_back(std::move(container));
     }
 
diff --git a/src/controllers/midi/midicontroller.cpp b/src/controllers/midi/midicontroller.cpp
index 3130f6594f..5494db2874 100644
--- a/src/controllers/midi/midicontroller.cpp
+++ b/src/controllers/midi/midicontroller.cpp
@@ -4,6 +4,7 @@
 #include <algorithm>
 
 #include "control/controlobject.h"
+#include "control/controlpotmeter.h"
 #include "controllers/defs_controllers.h"
 #include "controllers/midi/midioutputhandler.h"
 #include "controllers/midi/midiutils.h"
@@ -451,7 +452,11 @@ void MidiController::processInputMapping(const MidiInputMapping& mapping,
 
     if (mapping.options.testFlag(MidiOption::SoftTakeover)) {
         // This is the only place to enable it if it isn't already.
-        m_st.enable(pCO);
+        auto* pControlPotmeter = qobject_cast<ControlPotmeter*>(pCO);
+        if (!pControlPotmeter) {
+            return;
+        }
+        m_st.enable(gsl::not_null(pControlPotmeter));
         if (m_st.ignore(pCO, pCO->getParameterForMidi(newValue))) {
             return;
         }
diff --git a/src/controllers/midi/midicontroller.h b/src/controllers/midi/midicontroller.h
index fabc0df85a..74e10820e6 100644
--- a/src/controllers/midi/midicontroller.h
+++ b/src/controllers/midi/midicontroller.h
@@ -1,10 +1,9 @@
 #pragma once
 
 #include <QJSValue>
-#include <utility>
 
 #include "controllers/controller.h"
-#include "controllers/midi/legacymidicontrollermappingfilehandler.h"
+#include "controllers/midi/legacymidicontrollermapping.h"
 #include "controllers/midi/midimessage.h"
 #include "controllers/softtakeover.h"
 
diff --git a/src/controllers/scripting/legacy/controllerscriptinterfacelegacy.cpp b/src/controllers/scripting/legacy/controllerscriptinterfacelegacy.cpp
index 9325a29faa..665a3ca524 100644
--- a/src/controllers/scripting/legacy/controllerscriptinterfacelegacy.cpp
+++ b/src/controllers/scripting/legacy/controllerscriptinterfacelegacy.cpp
@@ -1,7 +1,10 @@
 #include "controllerscriptinterfacelegacy.h"
 
+#include <gsl/pointers>
+
 #include "control/controlobject.h"
 #include "control/controlobjectscript.h"
+#include "control/controlpotmeter.h"
 #include "controllers/scripting/legacy/controllerscriptenginelegacy.h"
 #include "controllers/scripting/legacy/scriptconnectionjsproxy.h"
 #include "mixer/playermanager.h"
@@ -584,11 +587,12 @@ void ControllerScriptInterfaceLegacy::softTakeover(
         const QString& group, const QString& name, bool set) {
     ControlObject* pControl = ControlObject::getControl(
             ConfigKey(group, name), ControlFlag::AllowMissingOrInvalid);
-    if (!pControl) {
-        return;
-    }
     if (set) {
-        m_st.enable(pControl);
+        auto* pControlPotmeter = qobject_cast<ControlPotmeter*>(pControl);
+        if (!pControlPotmeter) {
+            return;
+        }
+        m_st.enable(gsl::not_null(pControlPotmeter));
     } else {
         m_st.disable(pControl);
     }
@@ -605,6 +609,17 @@ void ControllerScriptInterfaceLegacy::softTakeoverIgnoreNextValue(
     m_st.ignoreNext(pControl);
 }
 
+bool ControllerScriptInterfaceLegacy::softTakeoverWillIgnore(
+        const QString& group, const QString& name, double parameter) {
+    ControlObject* pControl = ControlObject::getControl(
+            ConfigKey(group, name));
+    if (!pControl) {
+        return false;
+    }
+
+    return m_st.willIgnore(pControl, parameter);
+}
+
 double ControllerScriptInterfaceLegacy::getDeckRate(const QString& group) {
     double rate = 0.0;
     ControlObjectScript* pRateRatio =
diff --git a/src/controllers/scripting/legacy/controllerscriptinterfacelegacy.h b/src/controllers/scripting/legacy/controllerscriptinterfacelegacy.h
index 4d3e280a6f..b83ca2fa29 100644
--- a/src/controllers/scripting/legacy/controllerscriptinterfacelegacy.h
+++ b/src/controllers/scripting/legacy/controllerscriptinterfacelegacy.h
@@ -60,6 +60,8 @@ class ControllerScriptInterfaceLegacy : public QObject {
     Q_INVOKABLE bool isScratching(int deck);
     Q_INVOKABLE void softTakeover(const QString& group, const QString& name, bool set);
     Q_INVOKABLE void softTakeoverIgnoreNextValue(const QString& group, const QString& name);
+    Q_INVOKABLE bool softTakeoverWillIgnore(
+            const QString& group, const QString& name, double parameter);
     Q_INVOKABLE void brake(const int deck,
             bool activate,
             double factor = 1.0,
diff --git a/src/controllers/softtakeover.cpp b/src/controllers/softtakeover.cpp
index fcd4e9dee3..444e8e3a43 100644
--- a/src/controllers/softtakeover.cpp
+++ b/src/controllers/softtakeover.cpp
@@ -1,87 +1,18 @@
 #include "controllers/softtakeover.h"
-#include "control/controlpotmeter.h"
-#include "util/math.h"
-#include "util/time.h"
-
-// 3/128 units away from the current is enough to catch fast non-sequential moves
-//  but not cause an audibly noticeable jump, determined experimentally with
-//  slow-refresh controllers.
-const double SoftTakeover::kDefaultTakeoverThreshold = 3.0 / 128;
-
-const mixxx::Duration SoftTakeover::kSubsequentValueOverrideTime =
-        mixxx::Duration::fromMillis(50);
-
-SoftTakeoverCtrl::SoftTakeoverCtrl() {
-
-}
-
-SoftTakeoverCtrl::~SoftTakeoverCtrl() {
-    QHashIterator<ControlObject*, SoftTakeover*> i(m_softTakeoverHash);
-    while (i.hasNext()) {
-        i.next();
-        delete i.value();
-    }
-}
-
-void SoftTakeoverCtrl::enable(ControlObject* control) {
-    ControlPotmeter* cpo = qobject_cast<ControlPotmeter*>(control);
-    if (cpo == nullptr) {
-        // softtakecover works only for continuous ControlPotmeter based COs
-        return;
-    }
-
-    // Initialize times
-    if (!m_softTakeoverHash.contains(control)) {
-        m_softTakeoverHash.insert(control, new SoftTakeover());
-    }
-}
-
-void SoftTakeoverCtrl::disable(ControlObject* control) {
-    if (control == nullptr) {
-        return;
-    }
-    SoftTakeover* pSt = m_softTakeoverHash.take(control);
-    if (pSt) {
-        delete pSt;
-    }
-}
-
-bool SoftTakeoverCtrl::ignore(ControlObject* control, double newParameter) {
-    if (control == nullptr) {
-        return false;
-    }
-    bool ignore = false;
-    SoftTakeover* pSt = m_softTakeoverHash.value(control);
-    if (pSt) {
-        ignore = pSt->ignore(control, newParameter);
-    }
-    return ignore;
-}
-
-void SoftTakeoverCtrl::ignoreNext(ControlObject* control) {
-    if (control == nullptr) {
-        return;
-    }
-
-    SoftTakeover* pSt = m_softTakeoverHash.value(control);
-    if (pSt == nullptr) {
-        return;
-    }
 
-    pSt->ignoreNext();
-}
+#include "control/controlobject.h"
+#include "control/controlpotmeter.h"
 
-SoftTakeover::SoftTakeover()
-    : m_prevParameter(0),
-      m_dThreshold(kDefaultTakeoverThreshold) {
-}
+using namespace std::chrono_literals;
 
-void SoftTakeover::setThreshold(double threshold) {
-    m_dThreshold = threshold;
+void SoftTakeoverCtrl::enable(gsl::not_null<ControlPotmeter*> pControl) {
+    // explicitly not in the header to avoid adding dependency on ControlPotmeter
+    m_softTakeoverHash.try_emplace(static_cast<ControlObject*>(pControl.get()));
 }
 
-bool SoftTakeover::ignore(ControlObject* control, double newParameter) {
-    bool ignore = false;
+bool SoftTakeover::willIgnore(const ControlObject& control,
+        double newParameter,
+        ClockT::time_point currentTime) const {
     /*
      * We only want to ignore the controller when:
      * - its new value is far away from the current value of the ControlObject
@@ -108,30 +39,40 @@ bool SoftTakeover::ignore(ControlObject* control, double newParameter) {
      *      Don't ignore in every other case.
      */
 
-    mixxx::Duration currentTime = mixxx::Time::elapsed();
+    if (m_time == kFirstValueTime) {
+        return true;
+    }
+    // don't ignore value if a previous one was not ignored in time
+    if (currentTime < m_time + kSubsequentValueOverrideTime) {
+        return false;
+    }
+    const double currentParameter = control.getParameter();
+    const double difference = currentParameter - newParameter;
+    const double prevDiff = currentParameter - m_prevParameter;
+    // Don't ignore if opposite side of the current parameter value
+    if (std::signbit(prevDiff) != std::signbit(difference)) {
+        return false;
+    }
+    // On same side of the current parameter value
+    if (fabs(difference) <= m_dThreshold || fabs(prevDiff) <= m_dThreshold) {
+        // differences are below threshold
+        return false;
+    }
+    return true;
+}
+
+bool SoftTakeover::ignore(const ControlObject& control, double newParameter) {
+    bool ignore = false;
+
+    auto currentTime = ClockT::now();
     // We will get a sudden jump if we don't ignore the first value.
-    if (m_time == mixxx::Duration::fromMillis(0)) {
+    if (m_time == kFirstValueTime) {
         ignore = true;
         // Change the stored time (but keep it far away from the current time)
         //  so this block doesn't run again.
-        m_time = mixxx::Duration::fromMillis(1);
-//         qDebug() << "SoftTakeover::ignore: ignoring the first value"
-//                  << newParameter;
-    } else if (currentTime - m_time > kSubsequentValueOverrideTime) {
-        // don't ignore value if a previous one was not ignored in time
-        const double currentParameter = control->getParameter();
-        const double difference = currentParameter - newParameter;
-        const double prevDiff = currentParameter - m_prevParameter;
-        if ((prevDiff < 0 && difference < 0) ||
-                (prevDiff > 0 && difference > 0)) {
-            // On same side of the current parameter value
-            if (fabs(difference) > m_dThreshold && fabs(prevDiff) > m_dThreshold) {
-                // differences are above threshold
-                ignore = true;
-//                 qDebug() << "SoftTakeover::ignore: ignoring, not near"
-//                          << newParameter << m_prevParameter << currentParameter;
-            }
-        }
+        m_time = ClockT::time_point(kFirstValueTime + 1ms);
+    } else {
+        ignore = willIgnore(control, newParameter, currentTime);
     }
     if (!ignore) {
         // Update the time only if the value is not ignored. Replaces any
@@ -143,7 +84,3 @@ bool SoftTakeover::ignore(ControlObject* control, double newParameter) {
 
     return ignore;
 }
-
-void SoftTakeover::ignoreNext() {
-    m_time = mixxx::Duration::fromMillis(0);
-}
diff --git a/src/controllers/softtakeover.h b/src/controllers/softtakeover.h
index ba439b82ad..ab013895d9 100644
--- a/src/controllers/softtakeover.h
+++ b/src/controllers/softtakeover.h
@@ -1,56 +1,113 @@
 #pragma once
 
-#include <QHash>
+#include <chrono>
+#include <gsl/pointers>
+#include <unordered_map>
 
-#include "util/duration.h"
+#include "util/assert.h"
+#include "util/time.h"
 
 class ControlObject;
+class ControlPotmeter;
 
 class SoftTakeover {
   public:
-    // I would initialize it here but that's C++11 coolness. (Because it's a double.)
-    static const double kDefaultTakeoverThreshold;
+    using ClockT = mixxx::Time;
+    // 3/128 units away from the current is enough to catch fast non-sequential moves
+    //  but not cause an audibly noticeable jump, determined experimentally with
+    //  slow-refresh controllers.
+    // TODO (XXX): Expose this to the controller mapping environment?
+    static constexpr double kDefaultTakeoverThreshold = 3.0 / 128;
 
-    SoftTakeover();
-    bool ignore(ControlObject* control, double newParameter);
-    void ignoreNext();
-    void setThreshold(double threshold);
+    SoftTakeover() = default;
+    bool ignore(const ControlObject& control, double newParameter);
+    bool willIgnore(const ControlObject& control,
+            double newParameter,
+            ClockT::time_point currentTime) const;
+    void ignoreNext() {
+        m_time = kFirstValueTime;
+    }
+    void setThreshold(double threshold) {
+        m_dThreshold = threshold;
+    }
 
-    struct TestAccess;
+    // TODO (XXX): find a better testing solution than this TestAccess
+    // front-door coupled to `mixxx::Time`.
+    struct TestAccess {
+        static constexpr ClockT::duration getTimeThreshold() {
+            return kSubsequentValueOverrideTime;
+        }
+        template<class Rep = ClockT::rep,
+                class Period = ClockT::period>
+        static void advanceTimePastThreshold(
+                std::chrono::duration<Rep, Period> offset =
+                        std::chrono::nanoseconds(0)) {
+            mixxx::Time::addTestTime(getTimeThreshold() + offset);
+        }
+    };
 
   private:
     // If a new value is received within this amount of time, jump to it
     // regardless. This allows quickly whipping controls to work while retaining
     // the benefits of soft-takeover for slower movements.  Setting this too
     // high will defeat the purpose of soft-takeover.
-    static const mixxx::Duration kSubsequentValueOverrideTime;
+    static constexpr ClockT::duration kSubsequentValueOverrideTime = std::chrono::milliseconds(50);
+    static constexpr ClockT::time_point kFirstValueTime = ClockT::time_point::min();
 
-    mixxx::Duration m_time;
-    double m_prevParameter;
-    double m_dThreshold;
-};
-
-struct SoftTakeover::TestAccess {
-    static mixxx::Duration getTimeThreshold() {
-        return kSubsequentValueOverrideTime;
-    }
+    ClockT::time_point m_time{kFirstValueTime};
+    double m_prevParameter{0};
+    double m_dThreshold{kDefaultTakeoverThreshold};
 };
 
 class SoftTakeoverCtrl {
   public:
-    SoftTakeoverCtrl();
-    ~SoftTakeoverCtrl();
+    SoftTakeoverCtrl() = default;
 
     // Enable soft-takeover for the given Control.
     // This does nothing on a control that already has soft-takeover enabled.
-    void enable(ControlObject* control);
+    void enable(gsl::not_null<ControlPotmeter*> pControl);
     // Disable soft-takeover for the given Control
-    void disable(ControlObject* control);
+    void disable(ControlObject* control) {
+        m_softTakeoverHash.erase(control);
+    }
     // Check to see if the new value for the Control should be ignored
-    bool ignore(ControlObject* control, double newMidiParameter);
+    bool ignore(ControlObject* pControl, double newParameter) {
+        auto it = m_softTakeoverHash.find(pControl);
+        if (it == m_softTakeoverHash.end()) {
+            return false;
+        }
+        VERIFY_OR_DEBUG_ASSERT(pControl) {
+            return false;
+        }
+        auto& [coKey, refSoftTakeover] = *it;
+        return refSoftTakeover.ignore(*pControl, newParameter);
+    }
+    bool willIgnore(ControlObject* pControl, double newParameter) {
+        auto it = m_softTakeoverHash.find(pControl);
+        if (it == m_softTakeoverHash.end()) {
+            return false;
+        }
+        VERIFY_OR_DEBUG_ASSERT(pControl) {
+            return false;
+        }
+        auto currentTime = SoftTakeover::ClockT::now();
+        auto& [coKey, refSoftTakeover] = *it;
+        return refSoftTakeover.willIgnore(*pControl, newParameter, currentTime);
+    }
     // Ignore the next supplied parameter
-    void ignoreNext(ControlObject* control);
+    void ignoreNext(ControlObject* pControl) {
+        auto it = m_softTakeoverHash.find(pControl);
+        if (it == m_softTakeoverHash.end()) {
+            return;
+        }
+        auto& [coKey, refSoftTakeover] = *it;
+        refSoftTakeover.ignoreNext();
+    }
 
   private:
-    QHash<ControlObject*, SoftTakeover*> m_softTakeoverHash;
+    // ControlObjects are borrowed. They must outlive this object.
+    // Note that even though we can only enable softTakeover on
+    // `ControlPotmeter`s, we store the base ControlObject to not force the user
+    // to downcast for `disable()` and `ignore()`/`ignoreNext()`.
+    std::unordered_map<ControlObject*, SoftTakeover> m_softTakeoverHash;
 };
diff --git a/src/effects/effectbuttonparameterslot.cpp b/src/effects/effectbuttonparameterslot.cpp
index cd700a536b..e31a7ea7ed 100644
--- a/src/effects/effectbuttonparameterslot.cpp
+++ b/src/effects/effectbuttonparameterslot.cpp
@@ -9,15 +9,15 @@ EffectButtonParameterSlot::EffectButtonParameterSlot(const QString& group,
         const unsigned int iParameterSlotNumber)
         : EffectParameterSlotBase(group, iParameterSlotNumber, EffectParameterType::Button) {
     QString itemPrefix = formatItemPrefix(iParameterSlotNumber);
-    m_pControlLoaded = new ControlObject(
+    m_pControlLoaded = std::make_unique<ControlObject>(
             ConfigKey(m_group, itemPrefix + QString("_loaded")));
-    m_pControlValue = new ControlPushButton(
+    m_pControlValue = std::make_unique<ControlPushButton>(
             ConfigKey(m_group, itemPrefix));
-    m_pControlValue->setButtonMode(ControlPushButton::POWERWINDOW);
-    m_pControlType = new ControlObject(
+    m_pControlValue->setButtonMode(mixxx::control::ButtonMode::PowerWindow);
+    m_pControlType = std::make_unique<ControlObject>(
             ConfigKey(m_group, itemPrefix + QString("_type")));
 
-    connect(m_pControlValue,
+    connect(m_pControlValue.get(),
             &ControlObject::valueChanged,
             this,
             &EffectButtonParameterSlot::slotValueChanged);
@@ -29,10 +29,7 @@ EffectButtonParameterSlot::EffectButtonParameterSlot(const QString& group,
     clear();
 }
 
-EffectButtonParameterSlot::~EffectButtonParameterSlot() {
-    // m_pControlLoaded and m_pControlType are deleted by ~EffectParameterSlotBase
-    delete m_pControlValue;
-}
+EffectButtonParameterSlot::~EffectButtonParameterSlot() = default;
 
 void EffectButtonParameterSlot::loadParameter(EffectParameterPointer pEffectParameter) {
     if (m_pEffectParameter) {
diff --git a/src/effects/effectbuttonparameterslot.h b/src/effects/effectbuttonparameterslot.h
index c984b8e2da..c4652ee9ed 100644
--- a/src/effects/effectbuttonparameterslot.h
+++ b/src/effects/effectbuttonparameterslot.h
@@ -13,7 +13,7 @@ class EffectButtonParameterSlot : public EffectParameterSlotBase {
     Q_OBJECT
   public:
     EffectButtonParameterSlot(const QString& group, const unsigned int iParameterSlotNumber);
-    virtual ~EffectButtonParameterSlot();
+    ~EffectButtonParameterSlot() override;
 
     static QString formatItemPrefix(const unsigned int iParameterSlotNumber) {
         return QString("button_parameter%1").arg(iParameterSlotNumber + 1);
@@ -31,7 +31,7 @@ class EffectButtonParameterSlot : public EffectParameterSlotBase {
     }
 
     // Control exposed to the rest of Mixxx
-    ControlPushButton* m_pControlValue;
+    std::unique_ptr<ControlPushButton> m_pControlValue;
 
     DISALLOW_COPY_AND_ASSIGN(EffectButtonParameterSlot);
 };
diff --git a/src/effects/effectchain.cpp b/src/effects/effectchain.cpp
index e580aa75c4..0199b538de 100644
--- a/src/effects/effectchain.cpp
+++ b/src/effects/effectchain.cpp
@@ -52,7 +52,7 @@ EffectChain::EffectChain(const QString& group,
 
     m_pControlChainEnabled =
             std::make_unique<ControlPushButton>(ConfigKey(m_group, "enabled"));
-    m_pControlChainEnabled->setButtonMode(ControlPushButton::POWERWINDOW);
+    m_pControlChainEnabled->setButtonMode(mixxx::control::ButtonMode::PowerWindow);
     // Default to enabled. The skin might not show these buttons.
     m_pControlChainEnabled->setDefaultValue(true);
     m_pControlChainEnabled->set(true);
@@ -82,8 +82,8 @@ EffectChain::EffectChain(const QString& group,
 
     m_pControlChainMixMode =
             std::make_unique<ControlPushButton>(ConfigKey(m_group, "mix_mode"));
-    m_pControlChainMixMode->setButtonMode(ControlPushButton::TOGGLE);
-    m_pControlChainMixMode->setStates(EffectChainMixMode::kNumModes);
+    m_pControlChainMixMode->setBehavior(
+            mixxx::control::ButtonMode::Toggle, EffectChainMixMode::kNumModes);
     double mixModeCODefault = static_cast<double>(EffectChainMixMode::DrySlashWet);
     m_pControlChainMixMode->setDefaultValue(mixModeCODefault);
     m_pControlChainMixMode->set(mixModeCODefault);
@@ -127,21 +127,21 @@ EffectChain::EffectChain(const QString& group,
     // Refer to comment in header for full explanation.
     m_pControlChainShowFocus = std::make_unique<ControlPushButton>(
             ConfigKey(m_group, "show_focus"));
-    m_pControlChainShowFocus->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlChainShowFocus->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_pControlChainHasControllerFocus = std::make_unique<ControlPushButton>(
             ConfigKey(m_group, "controller_input_active"));
-    m_pControlChainHasControllerFocus->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlChainHasControllerFocus->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_pControlChainShowParameters = std::make_unique<ControlPushButton>(
             ConfigKey(m_group, "show_parameters"),
             true);
-    m_pControlChainShowParameters->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlChainShowParameters->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_pControlChainFocusedEffect = std::make_unique<ControlPushButton>(
             ConfigKey(m_group, "focused_effect"),
             true);
-    m_pControlChainFocusedEffect->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlChainFocusedEffect->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     addToEngine();
 }
@@ -306,7 +306,7 @@ void EffectChain::registerInputChannel(const ChannelHandleAndGroup& handleGroup,
             true,
             initialValue);
     m_channelEnableButtons.insert(handleGroup, pEnableControl);
-    pEnableControl->setButtonMode(ControlPushButton::POWERWINDOW);
+    pEnableControl->setButtonMode(mixxx::control::ButtonMode::PowerWindow);
     if (pEnableControl->toBool()) {
         enableForInputChannel(handleGroup);
     }
diff --git a/src/effects/effectknobparameterslot.cpp b/src/effects/effectknobparameterslot.cpp
index 4f3fb704d6..9f5e2dfae2 100644
--- a/src/effects/effectknobparameterslot.cpp
+++ b/src/effects/effectknobparameterslot.cpp
@@ -13,49 +13,39 @@ EffectKnobParameterSlot::EffectKnobParameterSlot(
                   group, iParameterSlotNumber, EffectParameterType::Knob) {
     QString itemPrefix = formatItemPrefix(iParameterSlotNumber);
 
-    m_pControlValue = new ControlEffectKnob(
+    m_pControlValue = std::make_unique<ControlEffectKnob>(
             ConfigKey(m_group, itemPrefix));
-    connect(m_pControlValue,
+    connect(m_pControlValue.get(),
             &ControlObject::valueChanged,
             this,
             &EffectKnobParameterSlot::slotValueChanged);
 
-    m_pControlLoaded = new ControlObject(
+    m_pControlLoaded = std::make_unique<ControlObject>(
             ConfigKey(m_group, itemPrefix + QString("_loaded")));
     m_pControlLoaded->setReadOnly();
 
-    m_pControlType = new ControlObject(
+    m_pControlType = std::make_unique<ControlObject>(
             ConfigKey(m_group, itemPrefix + QString("_type")));
     m_pControlType->setReadOnly();
 
-    m_pControlLinkType = new ControlPushButton(
+    m_pControlLinkType = std::make_unique<ControlPushButton>(
             ConfigKey(m_group, itemPrefix + QString("_link_type")));
-    m_pControlLinkType->setButtonMode(ControlPushButton::TOGGLE);
-    m_pControlLinkType->setStates(
+    m_pControlLinkType->setBehavior(mixxx::control::ButtonMode::Toggle,
             static_cast<int>(EffectManifestParameter::LinkType::NumLinkTypes));
     m_pControlLinkType->connectValueChangeRequest(
             this, &EffectKnobParameterSlot::slotLinkTypeChanging);
 
-    m_pControlLinkInverse = new ControlPushButton(
+    m_pControlLinkInverse = std::make_unique<ControlPushButton>(
             ConfigKey(m_group, itemPrefix + QString("_link_inverse")));
-    m_pControlLinkInverse->setButtonMode(ControlPushButton::TOGGLE);
-    connect(m_pControlLinkInverse,
+    m_pControlLinkInverse->setButtonMode(mixxx::control::ButtonMode::Toggle);
+    connect(m_pControlLinkInverse.get(),
             &ControlObject::valueChanged,
             this,
             &EffectKnobParameterSlot::slotLinkInverseChanged);
-
-    m_pMetaknobSoftTakeover = new SoftTakeover();
-
     clear();
 }
 
-EffectKnobParameterSlot::~EffectKnobParameterSlot() {
-    delete m_pControlValue;
-    // m_pControlLoaded and m_pControlType are deleted by ~EffectParameterSlotBase
-    delete m_pControlLinkType;
-    delete m_pControlLinkInverse;
-    delete m_pMetaknobSoftTakeover;
-}
+EffectKnobParameterSlot::~EffectKnobParameterSlot() = default;
 
 void EffectKnobParameterSlot::loadParameter(EffectParameterPointer pEffectParameter) {
     clear();
@@ -102,7 +92,7 @@ void EffectKnobParameterSlot::clear() {
     m_pControlType->forceSet(0.0);
     m_pControlLinkType->setAndConfirm(
             static_cast<double>(EffectManifestParameter::LinkType::None));
-    m_pMetaknobSoftTakeover->setThreshold(SoftTakeover::kDefaultTakeoverThreshold);
+    m_metaknobSoftTakeover.setThreshold(SoftTakeover::kDefaultTakeoverThreshold);
     m_pControlLinkInverse->set(0.0);
     emit updated();
 }
@@ -112,7 +102,7 @@ void EffectKnobParameterSlot::setParameter(double value) {
 }
 
 void EffectKnobParameterSlot::slotLinkTypeChanging(double v) {
-    m_pMetaknobSoftTakeover->ignoreNext();
+    m_metaknobSoftTakeover.ignoreNext();
     EffectManifestParameter::LinkType newType =
             static_cast<EffectManifestParameter::LinkType>(
                     static_cast<int>(v));
@@ -130,10 +120,10 @@ void EffectKnobParameterSlot::slotLinkTypeChanging(double v) {
     }
     if (newType == EffectManifestParameter::LinkType::LinkedLeft ||
             newType == EffectManifestParameter::LinkType::LinkedRight) {
-        m_pMetaknobSoftTakeover->setThreshold(
+        m_metaknobSoftTakeover.setThreshold(
                 SoftTakeover::kDefaultTakeoverThreshold * 2.0);
     } else {
-        m_pMetaknobSoftTakeover->setThreshold(SoftTakeover::kDefaultTakeoverThreshold);
+        m_metaknobSoftTakeover.setThreshold(SoftTakeover::kDefaultTakeoverThreshold);
     }
     m_pControlLinkType->setAndConfirm(static_cast<double>(newType));
     m_pEffectParameter->setLinkType(newType);
@@ -141,7 +131,7 @@ void EffectKnobParameterSlot::slotLinkTypeChanging(double v) {
 
 void EffectKnobParameterSlot::slotLinkInverseChanged(double v) {
     Q_UNUSED(v);
-    m_pMetaknobSoftTakeover->ignoreNext();
+    m_metaknobSoftTakeover.ignoreNext();
     m_pEffectParameter->setLinkInversion(
             static_cast<EffectManifestParameter::LinkInversion>(
                     static_cast<int>(v)));
@@ -149,91 +139,93 @@ void EffectKnobParameterSlot::slotLinkInverseChanged(double v) {
 
 void EffectKnobParameterSlot::onEffectMetaParameterChanged(double parameter, bool force) {
     m_dChainParameter = parameter;
-    if (m_pEffectParameter != nullptr) {
-        // Intermediate cast to integer is needed for VC++.
-        EffectManifestParameter::LinkType type =
-                static_cast<EffectManifestParameter::LinkType>(
-                        static_cast<int>(m_pControlLinkType->get()));
+    if (m_pEffectParameter == nullptr) {
+        return;
+    }
+    // Intermediate cast to integer is needed for VC++.
+    EffectManifestParameter::LinkType type =
+            static_cast<EffectManifestParameter::LinkType>(
+                    static_cast<int>(m_pControlLinkType->get()));
 
-        bool inverse = m_pControlLinkInverse->toBool();
-        double neutral = m_pManifestParameter->neutralPointOnScale();
+    bool inverse = m_pControlLinkInverse->toBool();
+    double neutral = m_pManifestParameter->neutralPointOnScale();
 
-        switch (type) {
-        case EffectManifestParameter::LinkType::Linked:
-            if (parameter < 0.0 || parameter > 1.0) {
-                return;
-            }
-            if (neutral > 0.0 && neutral < 1.0) {
-                if (inverse) {
-                    // the neutral position must stick where it is
-                    neutral = 1.0 - neutral;
-                }
-                // Knob is already a split knob
-                // Match to center position of meta knob
-                if (parameter <= 0.5) {
-                    parameter /= 0.5;
-                    parameter *= neutral;
-                } else {
-                    parameter -= 0.5;
-                    parameter /= 0.5;
-                    parameter *= 1 - neutral;
-                    parameter += neutral;
-                }
-            }
-            break;
-        case EffectManifestParameter::LinkType::LinkedLeft:
-            if (parameter >= 0.5 && parameter <= 1.0) {
-                parameter = 1;
-            } else if (parameter >= 0.0 && parameter <= 0.5) {
-                parameter *= 2;
-            } else {
-                return;
+    switch (type) {
+    case EffectManifestParameter::LinkType::Linked:
+        if (parameter < 0.0 || parameter > 1.0) {
+            return;
+        }
+        if (neutral > 0.0 && neutral < 1.0) {
+            if (inverse) {
+                // the neutral position must stick where it is
+                neutral = 1.0 - neutral;
             }
-            break;
-        case EffectManifestParameter::LinkType::LinkedRight:
-            if (parameter >= 0.5 && parameter <= 1.0) {
-                parameter -= 0.5;
-                parameter *= 2;
-            } else if (parameter >= 0.0 && parameter < 0.5) {
-                parameter = 0.0;
+            // Knob is already a split knob
+            // Match to center position of meta knob
+            if (parameter <= 0.5) {
+                parameter /= 0.5;
+                parameter *= neutral;
             } else {
-                return;
-            }
-            break;
-        case EffectManifestParameter::LinkType::LinkedLeftRight:
-            if (parameter >= 0.5 && parameter <= 1.0) {
                 parameter -= 0.5;
-                parameter *= 2;
-            } else if (parameter >= 0.0 && parameter < 0.5) {
-                parameter *= 2;
-                parameter = 1.0 - parameter;
-            } else {
-                return;
+                parameter /= 0.5;
+                parameter *= 1 - neutral;
+                parameter += neutral;
             }
-            break;
-        case EffectManifestParameter::LinkType::None:
-        default:
+        }
+        break;
+    case EffectManifestParameter::LinkType::LinkedLeft:
+        if (parameter >= 0.5 && parameter <= 1.0) {
+            parameter = 1;
+        } else if (parameter >= 0.0 && parameter <= 0.5) {
+            parameter *= 2;
+        } else {
             return;
         }
-
-        if (inverse) {
+        break;
+    case EffectManifestParameter::LinkType::LinkedRight:
+        if (parameter >= 0.5 && parameter <= 1.0) {
+            parameter -= 0.5;
+            parameter *= 2;
+        } else if (parameter >= 0.0 && parameter < 0.5) {
+            parameter = 0.0;
+        } else {
+            return;
+        }
+        break;
+    case EffectManifestParameter::LinkType::LinkedLeftRight:
+        if (parameter >= 0.5 && parameter <= 1.0) {
+            parameter -= 0.5;
+            parameter *= 2;
+        } else if (parameter >= 0.0 && parameter < 0.5) {
+            parameter *= 2;
             parameter = 1.0 - parameter;
+        } else {
+            return;
         }
+        break;
+    case EffectManifestParameter::LinkType::None:
+    default:
+        return;
+    }
 
-        //qDebug() << "onEffectMetaParameterChanged" << debugString() << parameter << "force?" << force;
-        if (force) {
-            m_pControlValue->setParameterFrom(parameter, nullptr);
-            // This ensures that softtakover is in sync for following updates
-            m_pMetaknobSoftTakeover->ignore(m_pControlValue, parameter);
-        } else if (!m_pMetaknobSoftTakeover->ignore(m_pControlValue, parameter)) {
-            m_pControlValue->setParameterFrom(parameter, nullptr);
-        }
+    if (inverse) {
+        parameter = 1.0 - parameter;
+    }
+
+    // qDebug() << "onEffectMetaParameterChanged" << debugString() << parameter
+    // << "force?" << force;
+    if (force) {
+        m_pControlValue->setParameterFrom(parameter, nullptr);
+        // This ensures that softtakover is in sync for following updates
+        m_metaknobSoftTakeover.ignore(*m_pControlValue, parameter);
+    } else if (!m_metaknobSoftTakeover.ignore(*m_pControlValue, parameter)) {
+        m_pControlValue->setParameterFrom(parameter, nullptr);
     }
 }
 
 void EffectKnobParameterSlot::syncSofttakeover() {
     double parameter = m_pControlValue->getParameter();
-    m_pMetaknobSoftTakeover->ignore(m_pControlValue, parameter);
+    m_metaknobSoftTakeover.ignore(*m_pControlValue, parameter);
 }
 
 double EffectKnobParameterSlot::getValueParameter() const {
diff --git a/src/effects/effectknobparameterslot.h b/src/effects/effectknobparameterslot.h
index 1fff8cbdb3..b73abdcefd 100644
--- a/src/effects/effectknobparameterslot.h
+++ b/src/effects/effectknobparameterslot.h
@@ -3,21 +3,21 @@
 #include <QObject>
 #include <QString>
 #include <QVariant>
-#include <optional>
+#include <memory>
 
+#include "controllers/softtakeover.h"
 #include "effects/effectparameterslotbase.h"
 #include "util/class.h"
 
 class ControlPushButton;
 class ControlEffectKnob;
-class SoftTakeover;
 
 /// Refer to EffectParameterSlotBase for documentation
 class EffectKnobParameterSlot : public EffectParameterSlotBase {
     Q_OBJECT
   public:
     EffectKnobParameterSlot(const QString& group, const unsigned int iParameterSlotNumber);
-    virtual ~EffectKnobParameterSlot();
+    ~EffectKnobParameterSlot() override;
 
     static QString formatItemPrefix(const unsigned int iParameterSlotNumber) {
         return QString("parameter%1").arg(iParameterSlotNumber + 1);
@@ -49,12 +49,12 @@ class EffectKnobParameterSlot : public EffectParameterSlotBase {
         return QString("EffectKnobParameterSlot(%1,%2)").arg(m_group).arg(m_iParameterSlotNumber);
     }
 
-    SoftTakeover* m_pMetaknobSoftTakeover;
+    SoftTakeover m_metaknobSoftTakeover;
 
     // Control exposed to the rest of Mixxx
-    ControlEffectKnob* m_pControlValue;
-    ControlPushButton* m_pControlLinkType;
-    ControlPushButton* m_pControlLinkInverse;
+    std::unique_ptr<ControlEffectKnob> m_pControlValue;
+    std::unique_ptr<ControlPushButton> m_pControlLinkType;
+    std::unique_ptr<ControlPushButton> m_pControlLinkInverse;
 
     DISALLOW_COPY_AND_ASSIGN(EffectKnobParameterSlot);
 };
diff --git a/src/effects/effectparameterslotbase.cpp b/src/effects/effectparameterslotbase.cpp
index 6cd170fdfb..0af70ba9d6 100644
--- a/src/effects/effectparameterslotbase.cpp
+++ b/src/effects/effectparameterslotbase.cpp
@@ -17,12 +17,7 @@ EffectParameterSlotBase::EffectParameterSlotBase(const QString& group,
           m_dChainParameter(0.0) {
 }
 
-EffectParameterSlotBase::~EffectParameterSlotBase() {
-    m_pEffectParameter = nullptr;
-    m_pManifestParameter.clear();
-    delete m_pControlLoaded;
-    delete m_pControlType;
-}
+EffectParameterSlotBase::~EffectParameterSlotBase() = default;
 
 QString EffectParameterSlotBase::name() const {
     if (m_pManifestParameter) {
diff --git a/src/effects/effectparameterslotbase.h b/src/effects/effectparameterslotbase.h
index c962536da5..7ab26bbdfe 100644
--- a/src/effects/effectparameterslotbase.h
+++ b/src/effects/effectparameterslotbase.h
@@ -25,7 +25,7 @@ class EffectParameterSlotBase : public QObject {
             const unsigned int iParameterSlotNumber,
             const EffectParameterType parameterType);
 
-    virtual ~EffectParameterSlotBase();
+    ~EffectParameterSlotBase() override;
 
     virtual void loadParameter(EffectParameterPointer pEffectParameter) = 0;
 
@@ -75,8 +75,8 @@ class EffectParameterSlotBase : public QObject {
     EffectParameterType m_parameterType;
 
     // Controls exposed to the rest of Mixxx
-    ControlObject* m_pControlLoaded;
-    ControlObject* m_pControlType;
+    std::unique_ptr<ControlObject> m_pControlLoaded;
+    std::unique_ptr<ControlObject> m_pControlType;
     double m_dChainParameter;
 
     DISALLOW_COPY_AND_ASSIGN(EffectParameterSlotBase);
diff --git a/src/effects/effectslot.cpp b/src/effects/effectslot.cpp
index 639c4f1a65..4cc0284766 100644
--- a/src/effects/effectslot.cpp
+++ b/src/effects/effectslot.cpp
@@ -68,7 +68,7 @@ EffectSlot::EffectSlot(const QString& group,
     // Default to disabled to prevent accidental activation of effects
     // at the beginning of a set.
     m_pControlEnabled = std::make_unique<ControlPushButton>(ConfigKey(m_group, "enabled"));
-    m_pControlEnabled->setButtonMode(ControlPushButton::POWERWINDOW);
+    m_pControlEnabled->setButtonMode(mixxx::control::ButtonMode::PowerWindow);
     connect(m_pControlEnabled.get(),
             &ControlObject::valueChanged,
             this,
@@ -211,13 +211,11 @@ void EffectSlot::addEffectParameterSlot(EffectParameterType parameterType) {
     EffectParameterSlotBasePointer pParameterSlot =
             EffectParameterSlotBasePointer();
     if (parameterType == EffectParameterType::Knob) {
-        pParameterSlot = static_cast<EffectParameterSlotBasePointer>(
-                new EffectKnobParameterSlot(
-                        m_group, m_iNumParameterSlots[parameterType]));
+        pParameterSlot = QSharedPointer<EffectKnobParameterSlot>::create(
+                m_group, m_iNumParameterSlots[parameterType]);
     } else if (parameterType == EffectParameterType::Button) {
-        pParameterSlot = static_cast<EffectParameterSlotBasePointer>(
-                new EffectButtonParameterSlot(
-                        m_group, m_iNumParameterSlots[parameterType]));
+        pParameterSlot = QSharedPointer<EffectButtonParameterSlot>::create(
+                m_group, m_iNumParameterSlots[parameterType]);
     }
     ++m_iNumParameterSlots[parameterType];
     const auto pCONumParameterSlots = m_pControlNumParameterSlots[parameterType];
@@ -561,7 +559,7 @@ double EffectSlot::getMetaParameter() const {
 // This function is for the superknob to update individual effects' meta knobs
 // slotEffectMetaParameter does not need to update m_pControlMetaParameter's value
 void EffectSlot::setMetaParameter(double v, bool force) {
-    if (!m_metaknobSoftTakeover.ignore(m_pControlMetaParameter.get(), v) ||
+    if (!m_metaknobSoftTakeover.ignore(*m_pControlMetaParameter, v) ||
             !m_pControlEnabled->toBool() || force) {
         m_pControlMetaParameter->set(v);
         slotEffectMetaParameter(v, force);
diff --git a/src/effects/effectsmanager.cpp b/src/effects/effectsmanager.cpp
index 9db93627fb..148c7353a3 100644
--- a/src/effects/effectsmanager.cpp
+++ b/src/effects/effectsmanager.cpp
@@ -60,6 +60,7 @@ EffectsManager::~EffectsManager() {
     // ~LV2GroupState calls lilv_instance_free, which will segfault if called
     // after ~LV2Backend calls lilv_world_free.
     m_equalizerEffectChains.clear();
+    m_quickStemEffectChains.clear();
     m_quickEffectChains.clear();
     m_standardEffectChains.clear();
     m_outputEffectChain.clear();
@@ -146,6 +147,24 @@ void EffectsManager::addDeck(const ChannelHandleAndGroup& deckHandleGroup) {
     }
 }
 
+void EffectsManager::addStem(const ChannelHandleAndGroup& stemHandleGroup) {
+    VERIFY_OR_DEBUG_ASSERT(!m_quickStemEffectChains.contains(
+            QuickEffectChain::formatEffectChainGroup(stemHandleGroup.name()))) {
+        return;
+    }
+    auto pChainSlot = QuickEffectChainPointer(
+            new QuickEffectChain(stemHandleGroup, this, m_pMessenger));
+    m_quickStemEffectChains.insert(stemHandleGroup.name(), pChainSlot);
+    m_effectChainSlotsByGroup.insert(pChainSlot->group(), pChainSlot);
+
+    // If a stem is added after setup() was run we need to read effects.xml
+    // again to initialize its QuickEffect chain, either with defaults or the
+    // previous state.
+    if (m_initializedFromEffectsXml) {
+        readEffectsXmlSingleDeckStem(stemHandleGroup.m_name);
+    }
+}
+
 void EffectsManager::addEqualizerEffectChain(const ChannelHandleAndGroup& deckHandleGroup) {
     VERIFY_OR_DEBUG_ASSERT(!m_equalizerEffectChains.contains(
             EqualizerEffectChain::formatEffectChainGroup(deckHandleGroup.name()))) {
@@ -243,6 +262,15 @@ void EffectsManager::readEffectsXml() {
         }
     }
 
+    QHashIterator<QString, EffectChainPresetPointer> qseDataIt(data.quickStemEffectChainPresets);
+    while (qseDataIt.hasNext()) {
+        qseDataIt.next();
+        auto pChainSlot = m_quickStemEffectChains.value(qseDataIt.key());
+        if (pChainSlot) {
+            pChainSlot->loadChainPreset(qseDataIt.value());
+        }
+    }
+
     m_pVisibleEffectsList->readEffectsXml(doc, m_pBackendManager);
 }
 
@@ -276,6 +304,25 @@ void EffectsManager::readEffectsXmlSingleDeck(const QString& deckGroup) {
     }
 }
 
+void EffectsManager::readEffectsXmlSingleDeckStem(const QString& deckStemGroup) {
+    QDir settingsPath(m_pConfig->getSettingsPath());
+    QFile file(settingsPath.absoluteFilePath(kEffectsXmlFile));
+    QDomDocument doc;
+
+    if (file.open(QIODevice::ReadOnly)) {
+        doc.setContent(&file);
+    }
+    file.close();
+
+    EffectChainPresetPointer pPreset =
+            m_pChainPresetManager->readEffectsXmlSingleDeckStem(doc, deckStemGroup);
+
+    auto pQuickEffectChainSlot = m_quickStemEffectChains.value(deckStemGroup);
+    if (pQuickEffectChainSlot) {
+        pQuickEffectChainSlot->loadChainPreset(pPreset);
+    }
+}
+
 void EffectsManager::saveEffectsXml() {
     QDomDocument doc(EffectXml::kRoot);
     doc.setContent(EffectXml::kFileHeader);
@@ -307,8 +354,18 @@ void EffectsManager::saveEffectsXml() {
         quickEffectChainPresets.insert(qeIt.key(), pPreset);
     }
 
+    QHash<QString, EffectChainPresetPointer> quickStemEffectChainPresets;
+    quickStemEffectChainPresets.reserve(m_quickStemEffectChains.size());
+    QHashIterator<QString, QuickEffectChainPointer> sqeIt(m_quickStemEffectChains);
+    while (sqeIt.hasNext()) {
+        sqeIt.next();
+        auto* pQuickEffectChain = sqeIt.value().data();
+        auto pPreset = EffectChainPresetPointer::create(pQuickEffectChain);
+        quickStemEffectChainPresets.insert(sqeIt.key(), pPreset);
+    }
+
     QList<EffectChainPresetPointer> standardEffectChainPresets;
-    standardEffectChainPresets.reserve(m_quickEffectChains.size());
+    standardEffectChainPresets.reserve(m_standardEffectChains.size());
     for (const auto& pChainSlot : std::as_const(m_standardEffectChains)) {
         auto* pChain = pChainSlot.data();
         auto pPreset = EffectChainPresetPointer::create(pChain);
@@ -326,6 +383,7 @@ void EffectsManager::saveEffectsXml() {
             EffectsXmlData{
                     eqEffectManifests,
                     quickEffectChainPresets,
+                    quickStemEffectChainPresets,
                     standardEffectChainPresets,
                     outputChainPreset});
 
diff --git a/src/effects/effectsmanager.h b/src/effects/effectsmanager.h
index f2b579e486..29a7960eaa 100644
--- a/src/effects/effectsmanager.h
+++ b/src/effects/effectsmanager.h
@@ -27,6 +27,7 @@ class EffectsManager {
 
     void setup();
     void addDeck(const ChannelHandleAndGroup& deckHandleGroup);
+    void addStem(const ChannelHandleAndGroup& stemHandleGroup);
 
     void loadDefaultEqsAndQuickEffects();
 
@@ -88,6 +89,7 @@ class EffectsManager {
 
     void readEffectsXml();
     void readEffectsXmlSingleDeck(const QString& deckGroup);
+    void readEffectsXmlSingleDeckStem(const QString& deckStemGroup);
     void saveEffectsXml();
 
     QSet<ChannelHandleAndGroup> m_registeredInputChannels;
@@ -100,6 +102,7 @@ class EffectsManager {
     // These two store <deck group, effect chain pointer>
     QHash<QString, EqualizerEffectChainPointer> m_equalizerEffectChains;
     QHash<QString, QuickEffectChainPointer> m_quickEffectChains;
+    QHash<QString, QuickEffectChainPointer> m_quickStemEffectChains;
 
     EffectsBackendManagerPointer m_pBackendManager;
     std::shared_ptr<ChannelHandleFactory> m_pChannelHandleFactory;
diff --git a/src/effects/presets/effectchainpresetmanager.cpp b/src/effects/presets/effectchainpresetmanager.cpp
index 43d7407756..59d0f92fe6 100644
--- a/src/effects/presets/effectchainpresetmanager.cpp
+++ b/src/effects/presets/effectchainpresetmanager.cpp
@@ -680,7 +680,7 @@ bool EffectChainPresetManager::savePresetXml(EffectChainPresetPointer pPreset) {
 // static
 EffectChainPresetPointer EffectChainPresetManager::createEmptyNamelessChainPreset() {
     auto pPreset = EffectChainPresetPointer::create(EffectChainPreset());
-    pPreset->setName("");
+    pPreset->setName(kNoEffectString);
     return pPreset;
 }
 
@@ -708,6 +708,7 @@ EffectsXmlData EffectChainPresetManager::readEffectsXml(
 
     QList<EffectChainPresetPointer> standardEffectChainPresets;
     QHash<QString, EffectChainPresetPointer> quickEffectPresets;
+    QHash<QString, EffectChainPresetPointer> quickStemEffectPresets;
     QHash<QString, EffectManifestPointer> eqEffectManifests;
     // configure default EQs and QuickEffects per deck
     for (const auto& deckString : deckStrings) {
@@ -857,8 +858,30 @@ EffectsXmlData EffectChainPresetManager::readEffectsXml(
         }
     }
 
-    return EffectsXmlData{
-            eqEffectManifests, quickEffectPresets, standardEffectChainPresets, mainEqPreset};
+    // Read names of presets that were loaded into stem QuickEffects on last shutdown
+    QDomElement quickStemEffectPresetsElement =
+            XmlParse::selectElement(root, EffectXml::kQuickStemEffectList);
+    const QDomNodeList quickStemEffectNodeList =
+            quickStemEffectPresetsElement.elementsByTagName(
+                    EffectXml::kChainPresetName);
+    for (int i = 0; i < quickStemEffectNodeList.count(); ++i) {
+        QDomElement presetNameElement = quickStemEffectNodeList.at(i).toElement();
+        if (!presetNameElement.isNull()) {
+            QString deckStemGroup = presetNameElement.attribute(QStringLiteral("group"));
+            auto pPreset = m_effectChainPresets.value(presetNameElement.text());
+            if (pPreset != nullptr) {
+                // Replace defaultQuickEffectChainPreset with pPreset
+                // for this deck group
+                quickStemEffectPresets.insert(deckStemGroup, pPreset);
+            }
+        }
+    }
+
+    return EffectsXmlData{eqEffectManifests,
+            quickEffectPresets,
+            quickStemEffectPresets,
+            standardEffectChainPresets,
+            mainEqPreset};
 }
 
 EffectXmlDataSingleDeck EffectChainPresetManager::readEffectsXmlSingleDeck(
@@ -917,6 +940,37 @@ EffectXmlDataSingleDeck EffectChainPresetManager::readEffectsXmlSingleDeck(
     return EffectXmlDataSingleDeck{pEqEffect, pQuickEffectChainPreset};
 }
 
+EffectChainPresetPointer EffectChainPresetManager::readEffectsXmlSingleDeckStem(
+        const QDomDocument& doc, const QString& deckStemString) {
+    QDomElement root = doc.documentElement();
+
+    // Quick Effect
+    auto pQuickEffectChainPreset = getDefaultQuickEffectPreset();
+
+    // Read name of last loaded QuickEffect preset
+    QDomElement quickEffectPresetsElement =
+            XmlParse::selectElement(root, EffectXml::kQuickStemEffectList);
+    const QDomNodeList quickEffectNodeList =
+            quickEffectPresetsElement.elementsByTagName(
+                    EffectXml::kChainPresetName);
+    for (int i = 0; i < quickEffectNodeList.count(); ++i) {
+        QDomElement presetNameElement = quickEffectNodeList.at(i).toElement();
+        if (presetNameElement.isNull()) {
+            continue;
+        }
+        if (presetNameElement.attribute(QStringLiteral("group")) == deckStemString) {
+            auto pPreset = m_effectChainPresets.value(presetNameElement.text());
+            if (pPreset != nullptr || presetNameElement.text() == kNoEffectString) {
+                // Replace the default preset.
+                // Load empty preset if the chain was cleared explicitly ('---' preset)
+                pQuickEffectChainPreset = pPreset;
+            }
+        }
+    }
+
+    return pQuickEffectChainPreset;
+}
+
 void EffectChainPresetManager::saveEffectsXml(QDomDocument* pDoc, const EffectsXmlData& data) {
     // Save presets for current state of standard chains
     QDomElement rootElement = pDoc->documentElement();
@@ -1007,4 +1061,19 @@ void EffectChainPresetManager::saveEffectsXml(QDomDocument* pDoc, const EffectsX
         quickEffectElement.setAttribute(QStringLiteral("group"), qeIt.key());
     }
     rootElement.appendChild(quickEffectPresetsElement);
+
+    // Save which presets are loaded to stem QuickEffects
+    QDomElement quickStemEffectPresetsElement =
+            pDoc->createElement(EffectXml::kQuickStemEffectList);
+    QHashIterator<QString, EffectChainPresetPointer> qseIt(data.quickStemEffectChainPresets);
+    while (qseIt.hasNext()) {
+        qseIt.next();
+        QDomElement quickEffectElement = XmlParse::addElement(
+                *pDoc,
+                quickStemEffectPresetsElement,
+                EffectXml::kChainPresetName,
+                qseIt.value()->name());
+        quickEffectElement.setAttribute(QStringLiteral("group"), qseIt.key());
+    }
+    rootElement.appendChild(quickStemEffectPresetsElement);
 }
diff --git a/src/effects/presets/effectchainpresetmanager.h b/src/effects/presets/effectchainpresetmanager.h
index 71d8fc4888..a2cc6f6f82 100644
--- a/src/effects/presets/effectchainpresetmanager.h
+++ b/src/effects/presets/effectchainpresetmanager.h
@@ -9,6 +9,7 @@
 struct EffectsXmlData {
     QHash<QString, EffectManifestPointer> eqEffectManifests;
     QHash<QString, EffectChainPresetPointer> quickEffectChainPresets;
+    QHash<QString, EffectChainPresetPointer> quickStemEffectChainPresets;
     QList<EffectChainPresetPointer> standardEffectChainPresets;
     EffectChainPresetPointer outputChainPreset;
 };
@@ -81,6 +82,8 @@ class EffectChainPresetManager : public QObject {
     EffectsXmlData readEffectsXml(const QDomDocument& doc, const QStringList& deckStrings);
     EffectXmlDataSingleDeck readEffectsXmlSingleDeck(
             const QDomDocument& doc, const QString& deckString);
+    EffectChainPresetPointer readEffectsXmlSingleDeckStem(
+            const QDomDocument& doc, const QString& deckStemString);
     void saveEffectsXml(QDomDocument* pDoc, const EffectsXmlData& data);
 
   signals:
diff --git a/src/effects/presets/effectxmlelements.h b/src/effects/presets/effectxmlelements.h
index 156ab6210a..5468a9127f 100644
--- a/src/effects/presets/effectxmlelements.h
+++ b/src/effects/presets/effectxmlelements.h
@@ -15,6 +15,7 @@ const QString kRackGroup(QStringLiteral("Group"));
 
 const QString kChainPresetList(QStringLiteral("ChainPresetList"));
 const QString kQuickEffectList(QStringLiteral("QuickEffectPresetList"));
+const QString kQuickStemEffectList(QStringLiteral("QuickStemEffectPresetList"));
 const QString kQuickEffectChainPresets(QStringLiteral("QuickEffectChains"));
 const QString kEqualizerEffects(QStringLiteral("EqualizerEffects"));
 const QString kChainPresetName(QStringLiteral("ChainPresetName"));
diff --git a/src/effects/visibleeffectslist.cpp b/src/effects/visibleeffectslist.cpp
index 84b75259e0..bc7350799c 100644
--- a/src/effects/visibleeffectslist.cpp
+++ b/src/effects/visibleeffectslist.cpp
@@ -66,7 +66,7 @@ void VisibleEffectsList::readEffectsXml(
     for (const EffectManifestPointer& pManifest : std::as_const(manifests)) {
         if (!visibleEffects.contains(pManifest) &&
                 !hiddenEffects.contains(pManifest)) {
-            // pre-pend so un-hidden effects are discoverable
+            // prepend so un-hidden effects are discoverable
             visibleEffects.prepend(pManifest);
         }
     }
diff --git a/src/encoder/encoder.cpp b/src/encoder/encoder.cpp
index 8cee16a0ff..069bf7d1ad 100644
--- a/src/encoder/encoder.cpp
+++ b/src/encoder/encoder.cpp
@@ -40,17 +40,17 @@ const EncoderFactory& EncoderFactory::getFactory()
 
 EncoderFactory::EncoderFactory() {
     // Add new supported formats here. Also modify the getNewEncoder/getEncoderSettings method.
-    m_formats.append(Encoder::Format("WAV PCM", ENCODING_WAVE, true, "wav"));
-    m_formats.append(Encoder::Format("AIFF PCM", ENCODING_AIFF, true, "aiff"));
-    m_formats.append(Encoder::Format("FLAC", ENCODING_FLAC, true, "flac"));
-    m_formats.append(Encoder::Format("MP3", ENCODING_MP3, false, "mp3"));
-    m_formats.append(Encoder::Format("OGG Vorbis", ENCODING_OGG, false, "ogg"));
+    m_formats.append(Encoder::Format{"WAV PCM", ENCODING_WAVE, true, "wav"});
+    m_formats.append(Encoder::Format{"AIFF PCM", ENCODING_AIFF, true, "aiff"});
+    m_formats.append(Encoder::Format{"FLAC", ENCODING_FLAC, true, "flac"});
+    m_formats.append(Encoder::Format{"MP3", ENCODING_MP3, false, "mp3"});
+    m_formats.append(Encoder::Format{"OGG Vorbis", ENCODING_OGG, false, "ogg"});
 #ifdef __OPUS__
-    m_formats.append(Encoder::Format("Opus", ENCODING_OPUS, false, "opus"));
+    m_formats.append(Encoder::Format{"Opus", ENCODING_OPUS, false, "opus"});
 #endif
-    m_formats.append(Encoder::Format("AAC", ENCODING_AAC, false, "aac"));
-    m_formats.append(Encoder::Format("HE-AAC", ENCODING_HEAAC, false, "aac"));
-    m_formats.append(Encoder::Format("HE-AACv2", ENCODING_HEAACV2, false, "aac"));
+    m_formats.append(Encoder::Format{"AAC", ENCODING_AAC, false, "aac"});
+    m_formats.append(Encoder::Format{"HE-AAC", ENCODING_HEAAC, false, "aac"});
+    m_formats.append(Encoder::Format{"HE-AACv2", ENCODING_HEAACV2, false, "aac"});
 }
 
 const QList<Encoder::Format> EncoderFactory::getFormats() const
diff --git a/src/encoder/encoder.h b/src/encoder/encoder.h
index 4cfbf5d06c..14c9af91d1 100644
--- a/src/encoder/encoder.h
+++ b/src/encoder/encoder.h
@@ -17,22 +17,12 @@ class SampleRate;
 
 class Encoder {
   public:
-        class Format {
-            public:
-              Format(const QString& labelIn,
-                      const QString& nameIn,
-                      bool losslessIn,
-                      const QString& fileExtIn)
-                      : label(labelIn),
-                        internalName(nameIn),
-                        lossless(losslessIn),
-                        fileExtension(fileExtIn) {
-              }
-            QString label;
-            QString internalName;
-            bool lossless;
-            QString fileExtension;
-        };
+    struct Format {
+        QString label;
+        QString internalName;
+        bool lossless;
+        QString fileExtension;
+    };
 
     Encoder() {}
     virtual ~Encoder() = default;
diff --git a/src/engine/cachingreader/cachingreader.cpp b/src/engine/cachingreader/cachingreader.cpp
index d2b868fa35..8f4d780d18 100644
--- a/src/engine/cachingreader/cachingreader.cpp
+++ b/src/engine/cachingreader/cachingreader.cpp
@@ -205,7 +205,11 @@ CachingReaderChunkForOwner* CachingReader::lookupChunkAndFreshen(SINT chunkIndex
 }
 
 // Invoked from the UI thread!!
+#ifdef __STEM__
+void CachingReader::newTrack(TrackPointer pTrack, uint stemIdx) {
+#else
 void CachingReader::newTrack(TrackPointer pTrack) {
+#endif
     auto newState = pTrack ? STATE_TRACK_LOADING : STATE_TRACK_UNLOADING;
     auto oldState = m_state.fetchAndStoreAcquire(newState);
 
@@ -220,7 +224,12 @@ void CachingReader::newTrack(TrackPointer pTrack) {
         kLogger.warning()
                 << "Loading a new track while loading a track may lead to inconsistent states";
     }
-    m_worker.newTrack(std::move(pTrack));
+    m_worker.newTrack(std::move(pTrack)
+#ifdef __STEM__
+                              ,
+            stemIdx
+#endif
+    );
 }
 
 // Called from the engine thread
diff --git a/src/engine/cachingreader/cachingreader.h b/src/engine/cachingreader/cachingreader.h
index 384f12a804..97854f4cf7 100644
--- a/src/engine/cachingreader/cachingreader.h
+++ b/src/engine/cachingreader/cachingreader.h
@@ -116,7 +116,12 @@ class CachingReader : public QObject {
     // Request that the CachingReader load a new track. These requests are
     // processed in the work thread, so the reader must be woken up via wake()
     // for this to take effect.
-    void newTrack(TrackPointer pTrack);
+    void newTrack(TrackPointer pTrack
+#ifdef __STEM__
+            ,
+            uint stemIdx = 0
+#endif
+    );
 
     void setScheduler(EngineWorkerScheduler* pScheduler) {
         m_worker.setScheduler(pScheduler);
diff --git a/src/engine/cachingreader/cachingreaderworker.cpp b/src/engine/cachingreader/cachingreaderworker.cpp
index cb4d12488e..41d2583a78 100644
--- a/src/engine/cachingreader/cachingreaderworker.cpp
+++ b/src/engine/cachingreader/cachingreaderworker.cpp
@@ -92,10 +92,21 @@ ReaderStatusUpdate CachingReaderWorker::processReadRequest(
 }
 
 // WARNING: Always called from a different thread (GUI)
-void CachingReaderWorker::newTrack(TrackPointer pTrack) {
+void CachingReaderWorker::newTrack(TrackPointer pTrack
+#ifdef __STEM__
+        ,
+        uint stemIdx
+#endif
+) {
     {
         const auto locker = lockMutex(&m_newTrackMutex);
+#ifdef __STEM__
+        m_pNewTrack = NewTrackRequest{
+                pTrack,
+                stemIdx};
+#else
         m_pNewTrack = pTrack;
+#endif
         m_newTrackAvailable.storeRelease(1);
     }
     workReady();
@@ -113,16 +124,25 @@ void CachingReaderWorker::run() {
         // Request is initialized by reading from FIFO
         CachingReaderChunkReadRequest request;
         if (m_newTrackAvailable.loadAcquire()) {
+#ifdef __STEM__
+            NewTrackRequest pLoadTrack;
+#else
             TrackPointer pLoadTrack;
+#endif
             { // locking scope
                 const auto locker = lockMutex(&m_newTrackMutex);
                 pLoadTrack = m_pNewTrack;
-                m_pNewTrack.reset();
                 m_newTrackAvailable.storeRelease(0);
             } // implicitly unlocks the mutex
+#ifdef __STEM__
+            if (pLoadTrack.track) {
+                // in this case the engine is still running with the old track
+                loadTrack(pLoadTrack.track, pLoadTrack.stemIdx);
+#else
             if (pLoadTrack) {
                 // in this case the engine is still running with the old track
                 loadTrack(pLoadTrack);
+#endif
             } else {
                 // here, the engine is already stopped
                 unloadTrack();
@@ -168,7 +188,12 @@ void CachingReaderWorker::unloadTrack() {
     m_pReaderStatusFIFO->writeBlocking(&update, 1);
 }
 
-void CachingReaderWorker::loadTrack(const TrackPointer& pTrack) {
+void CachingReaderWorker::loadTrack(const TrackPointer& pTrack
+#ifdef __STEM__
+        ,
+        uint stemIdx
+#endif
+) {
     // This emit is directly connected and returns synchronized
     // after the engine has been stopped.
     emit trackLoading();
@@ -190,6 +215,9 @@ void CachingReaderWorker::loadTrack(const TrackPointer& pTrack) {
 
     mixxx::AudioSource::OpenParams config;
     config.setChannelCount(m_maxSupportedChannel);
+#ifdef __STEM__
+    config.setStemIdx(stemIdx);
+#endif
     m_pAudioSource = SoundSourceProxy(pTrack).openAudioSource(config);
     if (!m_pAudioSource) {
         kLogger.warning()
diff --git a/src/engine/cachingreader/cachingreaderworker.h b/src/engine/cachingreader/cachingreaderworker.h
index a99bbb150a..12e044cb04 100644
--- a/src/engine/cachingreader/cachingreaderworker.h
+++ b/src/engine/cachingreader/cachingreaderworker.h
@@ -104,7 +104,12 @@ class CachingReaderWorker : public EngineWorker {
     ~CachingReaderWorker() override = default;
 
     // Request to load a new track. wake() must be called afterwards.
-    void newTrack(TrackPointer pTrack);
+    void newTrack(TrackPointer pTrack
+#ifdef __STEM__
+            ,
+            uint stemIdx
+#endif
+    );
 
     // Run upkeep operations like loading tracks and reading from file. Run by a
     // thread pool via the EngineWorkerScheduler.
@@ -122,6 +127,12 @@ class CachingReaderWorker : public EngineWorker {
     void trackLoadFailed(TrackPointer pTrack, const QString& reason);
 
   private:
+#ifdef __STEM__
+    struct NewTrackRequest {
+        TrackPointer track;
+        uint stemIdx;
+    };
+#endif
     const QString m_group;
     QString m_tag;
 
@@ -134,7 +145,11 @@ class CachingReaderWorker : public EngineWorker {
     // lock to touch.
     QMutex m_newTrackMutex;
     QAtomicInt m_newTrackAvailable;
+#ifdef __STEM__
+    NewTrackRequest m_pNewTrack;
+#else
     TrackPointer m_pNewTrack;
+#endif
 
     void discardAllPendingRequests();
 
@@ -147,7 +162,12 @@ class CachingReaderWorker : public EngineWorker {
     void unloadTrack();
 
     /// Internal method to load a track. Emits trackLoaded when finished.
-    void loadTrack(const TrackPointer& pTrack);
+    void loadTrack(const TrackPointer& pTrack
+#ifdef __STEM__
+            ,
+            uint stemIdx
+#endif
+    );
 
     ReaderStatusUpdate processReadRequest(
             const CachingReaderChunkReadRequest& request);
diff --git a/src/engine/channels/enginechannel.cpp b/src/engine/channels/enginechannel.cpp
index 59c80d45d3..8be2acc7c3 100644
--- a/src/engine/channels/enginechannel.cpp
+++ b/src/engine/channels/enginechannel.cpp
@@ -20,15 +20,14 @@ EngineChannel::EngineChannel(const ChannelHandleAndGroup& handleGroup,
           m_bIsTalkoverChannel(isTalkoverChannel),
           m_channelIndex(-1) {
     m_pPFL = new ControlPushButton(ConfigKey(getGroup(), "pfl"));
-    m_pPFL->setButtonMode(ControlPushButton::TOGGLE);
+    m_pPFL->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pMainMix = new ControlPushButton(ConfigKey(getGroup(), "main_mix"));
-    m_pMainMix->setButtonMode(ControlPushButton::POWERWINDOW);
+    m_pMainMix->setButtonMode(mixxx::control::ButtonMode::PowerWindow);
     m_pMainMix->addAlias(ConfigKey(getGroup(), QStringLiteral("master")));
     // crossfader assignment is persistent
     m_pOrientation = new ControlPushButton(
             ConfigKey(getGroup(), "orientation"), true, defaultOrientation);
-    m_pOrientation->setButtonMode(ControlPushButton::TOGGLE);
-    m_pOrientation->setStates(3);
+    m_pOrientation->setBehavior(mixxx::control::ButtonMode::Toggle, 3);
     m_pOrientationLeft = new ControlPushButton(ConfigKey(getGroup(), "orientation_left"));
     connect(m_pOrientationLeft, &ControlObject::valueChanged,
             this, &EngineChannel::slotOrientationLeft, Qt::DirectConnection);
@@ -39,7 +38,7 @@ EngineChannel::EngineChannel(const ChannelHandleAndGroup& handleGroup,
     connect(m_pOrientationCenter, &ControlObject::valueChanged,
             this, &EngineChannel::slotOrientationCenter, Qt::DirectConnection);
     m_pTalkover = new ControlPushButton(ConfigKey(getGroup(), "talkover"));
-    m_pTalkover->setButtonMode(ControlPushButton::POWERWINDOW);
+    m_pTalkover->setButtonMode(mixxx::control::ButtonMode::PowerWindow);
 
     if (m_pEffectsManager != nullptr) {
         m_pEffectsManager->registerInputChannel(handleGroup);
diff --git a/src/engine/channels/enginedeck.cpp b/src/engine/channels/enginedeck.cpp
index 09f2474e4b..59ad658526 100644
--- a/src/engine/channels/enginedeck.cpp
+++ b/src/engine/channels/enginedeck.cpp
@@ -2,7 +2,9 @@
 
 #include "control/controlpushbutton.h"
 #include "effects/effectsmanager.h"
+#include "engine/controls/bpmcontrol.h"
 #include "engine/effects/engineeffectsmanager.h"
+#include "engine/effects/groupfeaturestate.h"
 #include "engine/enginebuffer.h"
 #include "engine/enginepregain.h"
 #include "engine/enginevumeter.h"
@@ -12,8 +14,6 @@
 
 #ifdef __STEM__
 namespace {
-constexpr int kMaxSupportedStems = 4;
-
 QString getGroupForStem(const QString& deckGroup, int stemIdx) {
     DEBUG_ASSERT(deckGroup.endsWith("]"));
     return QStringLiteral("%1Stem%2]")
@@ -38,7 +38,7 @@ EngineDeck::EngineDeck(
           m_pPassing(new ControlPushButton(ConfigKey(getGroup(), "passthrough"))) {
     m_pInputConfigured->setReadOnly();
     // Set up passthrough utilities and fields
-    m_pPassing->setButtonMode(ControlPushButton::POWERWINDOW);
+    m_pPassing->setButtonMode(mixxx::control::ButtonMode::PowerWindow);
     m_bPassthroughIsActive = false;
     m_bPassthroughWasActive = false;
 
@@ -72,9 +72,9 @@ EngineDeck::EngineDeck(
     m_pStemCount = std::make_unique<ControlObject>(ConfigKey(getGroup(), "stem_count"));
     m_pStemCount->setReadOnly();
 
-    m_stemGain.reserve(kMaxSupportedStems);
-    m_stemMute.reserve(kMaxSupportedStems);
-    for (int stemIdx = 1; stemIdx <= kMaxSupportedStems; stemIdx++) {
+    m_stemGain.reserve(mixxx::kMaxSupportedStems);
+    m_stemMute.reserve(mixxx::kMaxSupportedStems);
+    for (int stemIdx = 1; stemIdx <= mixxx::kMaxSupportedStems; stemIdx++) {
         m_stemGain.emplace_back(std::make_unique<ControlPotmeter>(
                 ConfigKey(getGroupForStem(getGroup(), stemIdx), QStringLiteral("volume"))));
         // The default value is ignored and override with the medium value by
@@ -96,7 +96,7 @@ void EngineDeck::slotTrackLoaded(TrackPointer pNewTrack,
     }
     if (m_pConfig->getValue(
                 ConfigKey("[Mixer Profile]", "stem_auto_reset"), true)) {
-        for (int stemIdx = 0; stemIdx < kMaxSupportedStems; stemIdx++) {
+        for (int stemIdx = 0; stemIdx < mixxx::kMaxSupportedStems; stemIdx++) {
             m_stemGain[stemIdx]->set(1.0);
             m_stemMute[stemIdx]->set(0.0);
             ;
@@ -118,31 +118,66 @@ EngineDeck::~EngineDeck() {
 }
 
 #ifdef __STEM__
+void EngineDeck::addStemHandle(const ChannelHandleAndGroup& stemHandleGroup) {
+    m_stems.emplace_back(ChannelHandleAndGroup(stemHandleGroup.handle(), stemHandleGroup.name()));
+    m_stemsGainCache.push_back(CSAMPLE_GAIN_ONE);
+    if (m_pEffectsManager != nullptr) {
+        m_pEffectsManager->registerInputChannel(stemHandleGroup);
+    }
+}
+
 void EngineDeck::processStem(CSAMPLE* pOut, const int iBufferSize) {
-    int stemCount = m_pBuffer->getChannelCount() / mixxx::kEngineChannelOutputCount;
+    mixxx::audio::ChannelCount chCount = m_pBuffer->getChannelCount();
+    VERIFY_OR_DEBUG_ASSERT(m_stems.size() <= chCount &&
+            m_stemMute.size() <= chCount && m_stemGain.size() <= chCount) {
+        return;
+    };
+    mixxx::audio::SampleRate sampleRate = mixxx::audio::SampleRate::fromDouble(m_sampleRate.get());
+    int stemCount = chCount / mixxx::kEngineChannelOutputCount;
+    int numFrames = iBufferSize / mixxx::kEngineChannelOutputCount;
     auto allChannelBufferSize = iBufferSize * stemCount;
     if (m_stemBuffer.size() < allChannelBufferSize) {
         m_stemBuffer = mixxx::SampleBuffer(allChannelBufferSize);
     }
     m_pBuffer->process(m_stemBuffer.data(), allChannelBufferSize);
 
-    // TODO(XXX): process effects per stems
-    SampleUtil::clear(pOut, iBufferSize);
-    const CSAMPLE* pIn = m_stemBuffer.data();
-    for (int i = 0; i < iBufferSize; i += mixxx::kEngineChannelOutputCount) {
+    CSAMPLE* pIn = m_stemBuffer.data();
+    EngineEffectsManager* pEngineEffectsManager = m_pEffectsManager->getEngineEffectsManager();
+    if (pEngineEffectsManager != nullptr) {
+        GroupFeatureState featureState;
+        collectFeatures(&featureState);
         for (int stemIdx = 0; stemIdx < stemCount;
                 stemIdx++) {
-            if (m_stemMute[stemIdx]->toBool()) {
-                continue;
-            }
-            float gain = static_cast<float>(m_stemGain[stemIdx]->get());
-            pOut[i] += pIn[stemCount * i + mixxx::kEngineChannelOutputCount * stemIdx] * gain;
-            pOut[i + 1] +=
-                    pIn[stemCount * i +
-                            mixxx::kEngineChannelOutputCount * stemIdx + 1] *
-                    gain;
+            int chOffset = stemIdx * mixxx::audio::ChannelCount::stereo();
+            float gain = m_stemMute[stemIdx]->toBool()
+                    ? 0.0f
+                    : static_cast<float>(m_stemGain[stemIdx]->get());
+            SampleUtil::copyOneStereoFromMulti(
+                    pOut,
+                    pIn,
+                    numFrames,
+                    chCount,
+                    chOffset);
+            pEngineEffectsManager->processPostFaderInPlace(m_stems[stemIdx].handle(),
+                    m_pEffectsManager->getMainHandle(),
+                    pOut,
+                    iBufferSize,
+                    sampleRate,
+                    featureState,
+                    m_stemsGainCache[stemIdx],
+                    gain,
+                    false);
+            m_stemsGainCache[stemIdx] = gain;
+            SampleUtil::copyStereoToMulti(
+                    pIn,
+                    pOut,
+                    numFrames,
+                    chCount,
+                    chOffset);
         }
     }
+
+    SampleUtil::mixMultichannelToStereo(pOut, pIn, numFrames, chCount);
     // TODO(XXX): process stem DSP
 }
 
@@ -150,7 +185,7 @@ void EngineDeck::cloneStemState(const EngineDeck* deckToClone) {
     VERIFY_OR_DEBUG_ASSERT(deckToClone) {
         return;
     }
-    for (int stemIdx = 0; stemIdx < kMaxSupportedStems; stemIdx++) {
+    for (int stemIdx = 0; stemIdx < mixxx::kMaxSupportedStems; stemIdx++) {
         m_stemGain[stemIdx]->set(deckToClone->m_stemGain[stemIdx]->get());
         m_stemMute[stemIdx]->set(deckToClone->m_stemMute[stemIdx]->get());
     }
diff --git a/src/engine/channels/enginedeck.h b/src/engine/channels/enginedeck.h
index 607c853e95..d99624984a 100644
--- a/src/engine/channels/enginedeck.h
+++ b/src/engine/channels/enginedeck.h
@@ -70,6 +70,7 @@ class EngineDeck : public EngineChannel, public AudioDestination {
     // check if the loaded track is a stem so this should only be used in case
     // of stem track
     void cloneStemState(const EngineDeck* deckToClone);
+    void addStemHandle(const ChannelHandleAndGroup& stemHandleGroup);
 #endif
 
   signals:
@@ -88,6 +89,9 @@ class EngineDeck : public EngineChannel, public AudioDestination {
     void processStem(CSAMPLE* pOutput, const int iBufferSize);
 #endif
 
+    std::vector<ChannelHandleAndGroup> m_stems;
+    std::vector<CSAMPLE_GAIN> m_stemsGainCache;
+
     UserSettingsPointer m_pConfig;
     EngineBuffer* m_pBuffer;
     EnginePregain* m_pPregain;
diff --git a/src/engine/controls/bpmcontrol.cpp b/src/engine/controls/bpmcontrol.cpp
index e249bb09bd..c6a3dda614 100644
--- a/src/engine/controls/bpmcontrol.cpp
+++ b/src/engine/controls/bpmcontrol.cpp
@@ -241,7 +241,7 @@ BpmControl::BpmControl(const QString& group,
 
     m_pBpmLock = std::make_unique<ControlPushButton>(
             ConfigKey(group, "bpmlock"), false);
-    m_pBpmLock->setButtonMode(ControlPushButton::TOGGLE);
+    m_pBpmLock->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pBpmLock->connectValueChangeRequest(
             this,
             &BpmControl::slotToggleBpmLock,
diff --git a/src/engine/controls/cuecontrol.cpp b/src/engine/controls/cuecontrol.cpp
index f99a781603..00fdadd8a1 100644
--- a/src/engine/controls/cuecontrol.cpp
+++ b/src/engine/controls/cuecontrol.cpp
@@ -138,9 +138,9 @@ CueControl::~CueControl() {
 
 void CueControl::createControls() {
     m_pCueSet = std::make_unique<ControlPushButton>(ConfigKey(m_group, "cue_set"));
-    m_pCueSet->setButtonMode(ControlPushButton::TRIGGER);
+    m_pCueSet->setButtonMode(mixxx::control::ButtonMode::Trigger);
     m_pCueClear = std::make_unique<ControlPushButton>(ConfigKey(m_group, "cue_clear"));
-    m_pCueClear->setButtonMode(ControlPushButton::TRIGGER);
+    m_pCueClear->setButtonMode(mixxx::control::ButtonMode::Trigger);
     m_pCueGoto = std::make_unique<ControlPushButton>(ConfigKey(m_group, "cue_goto"));
     m_pCueGotoAndPlay = std::make_unique<ControlPushButton>(ConfigKey(m_group, "cue_gotoandplay"));
     m_pCuePlay = std::make_unique<ControlPushButton>(ConfigKey(m_group, "cue_play"));
diff --git a/src/engine/controls/keycontrol.cpp b/src/engine/controls/keycontrol.cpp
index a759486176..5d28cf58d6 100644
--- a/src/engine/controls/keycontrol.cpp
+++ b/src/engine/controls/keycontrol.cpp
@@ -53,9 +53,9 @@ KeyControl::KeyControl(const QString& group,
     // Fine adjust with semitone / 10 = 10 ct;.
     m_pPitchAdjust->setSmallStepCount(60);
 
-    m_keylockMode->setButtonMode(ControlPushButton::TOGGLE);
+    m_keylockMode->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
-    m_keyunlockMode->setButtonMode(ControlPushButton::TOGGLE);
+    m_keyunlockMode->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     connect(m_pPitch.get(),
             &ControlObject::valueChanged,
diff --git a/src/engine/controls/loopingcontrol.cpp b/src/engine/controls/loopingcontrol.cpp
index fdb2cdc089..b4120cf8da 100644
--- a/src/engine/controls/loopingcontrol.cpp
+++ b/src/engine/controls/loopingcontrol.cpp
@@ -137,7 +137,7 @@ LoopingControl::LoopingControl(const QString& group,
     m_pCOLoopAnchor = new ControlPushButton(ConfigKey(group, "loop_anchor"),
             true,
             static_cast<double>(LoopAnchorPoint::Start));
-    m_pCOLoopAnchor->setButtonMode(ControlPushButton::TOGGLE);
+    m_pCOLoopAnchor->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_pCOBeatLoopSize = new ControlObject(ConfigKey(group, "beatloop_size"),
                                           true, false, false, 4.0);
@@ -237,7 +237,7 @@ LoopingControl::LoopingControl(const QString& group,
             this, &LoopingControl::slotLoopDouble);
 
     m_pLoopRemoveButton = new ControlPushButton(ConfigKey(group, "loop_remove"));
-    m_pLoopRemoveButton->setButtonMode(ControlPushButton::TRIGGER);
+    m_pLoopRemoveButton->setButtonMode(mixxx::control::ButtonMode::Trigger);
     connect(m_pLoopRemoveButton,
             &ControlObject::valueChanged,
             this,
@@ -2013,7 +2013,7 @@ BeatLoopingControl::BeatLoopingControl(const QString& group, double size)
     // is the state of the beatloop control (1 for enabled, 0 for disabled).
     m_pLegacy = std::make_unique<ControlPushButton>(
             keyForControl(group, "beatloop_%1", size));
-    m_pLegacy->setButtonMode(ControlPushButton::TOGGLE);
+    m_pLegacy->setButtonMode(mixxx::control::ButtonMode::Toggle);
     connect(m_pLegacy.get(),
             &ControlObject::valueChanged,
             this,
diff --git a/src/engine/controls/quantizecontrol.cpp b/src/engine/controls/quantizecontrol.cpp
index 9cf89a2044..233fc707cd 100644
--- a/src/engine/controls/quantizecontrol.cpp
+++ b/src/engine/controls/quantizecontrol.cpp
@@ -12,7 +12,7 @@ QuantizeControl::QuantizeControl(const QString& group,
         : EngineControl(group, pConfig) {
     // Turn quantize OFF by default. See Bug #898213
     m_pCOQuantizeEnabled = new ControlPushButton(ConfigKey(group, "quantize"), true);
-    m_pCOQuantizeEnabled->setButtonMode(ControlPushButton::TOGGLE);
+    m_pCOQuantizeEnabled->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pCONextBeat = new ControlObject(ConfigKey(group, "beat_next"));
     m_pCONextBeat->setKbdRepeatable(true);
     m_pCONextBeat->set(mixxx::audio::kInvalidFramePos.toEngineSamplePosMaybeInvalid());
diff --git a/src/engine/controls/vinylcontrolcontrol.cpp b/src/engine/controls/vinylcontrolcontrol.cpp
index df4bc1bf74..12fc85280c 100644
--- a/src/engine/controls/vinylcontrolcontrol.cpp
+++ b/src/engine/controls/vinylcontrolcontrol.cpp
@@ -31,22 +31,20 @@ VinylControlControl::VinylControlControl(const QString& group, UserSettingsPoint
     m_pControlVinylRate = new ControlObject(ConfigKey(group, "vinylcontrol_rate"));
     m_pControlVinylScratching = new ControlPushButton(ConfigKey(group, "vinylcontrol_scratching"));
     m_pControlVinylScratching->set(0);
-    m_pControlVinylScratching->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlVinylScratching->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pControlVinylEnabled = new ControlPushButton(ConfigKey(group, "vinylcontrol_enabled"));
     m_pControlVinylEnabled->set(0);
-    m_pControlVinylEnabled->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlVinylEnabled->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pControlVinylWantEnabled = new ControlPushButton(ConfigKey(group, "vinylcontrol_wantenabled"));
     m_pControlVinylWantEnabled->set(0);
-    m_pControlVinylWantEnabled->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlVinylWantEnabled->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pControlVinylMode = new ControlPushButton(ConfigKey(group, "vinylcontrol_mode"));
-    m_pControlVinylMode->setStates(3);
-    m_pControlVinylMode->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlVinylMode->setBehavior(mixxx::control::ButtonMode::Toggle, 3);
     m_pControlVinylCueing = new ControlPushButton(ConfigKey(group, "vinylcontrol_cueing"));
-    m_pControlVinylCueing->setStates(3);
-    m_pControlVinylCueing->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlVinylCueing->setBehavior(mixxx::control::ButtonMode::Toggle, 3);
     m_pControlVinylSignalEnabled = new ControlPushButton(ConfigKey(group, "vinylcontrol_signal_enabled"));
     m_pControlVinylSignalEnabled->set(1);
-    m_pControlVinylSignalEnabled->setButtonMode(ControlPushButton::TOGGLE);
+    m_pControlVinylSignalEnabled->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_pPlayEnabled = new ControlProxy(group, "play", this);
 }
diff --git a/src/engine/engine.h b/src/engine/engine.h
index 4df4ab6c27..9de33d6143 100644
--- a/src/engine/engine.h
+++ b/src/engine/engine.h
@@ -8,6 +8,10 @@ static constexpr audio::ChannelCount kEngineChannelOutputCount =
         audio::ChannelCount::stereo();
 static constexpr audio::ChannelCount kMaxEngineChannelInputCount =
         audio::ChannelCount::stem();
+#ifdef __STEM__
+constexpr int kMaxSupportedStems = 4;
+constexpr uint kNoStemSelectedIdx = 0;
+#endif
 
 // Contains the information needed to process a buffer of audio
 class EngineParameters final {
diff --git a/src/engine/enginebuffer.cpp b/src/engine/enginebuffer.cpp
index 4bfc4a3cf3..d8665d8ce1 100644
--- a/src/engine/enginebuffer.cpp
+++ b/src/engine/enginebuffer.cpp
@@ -116,7 +116,7 @@ EngineBuffer::EngineBuffer(const QString& group,
 
     // Play button
     m_playButton = new ControlPushButton(ConfigKey(m_group, "play"));
-    m_playButton->setButtonMode(ControlPushButton::TOGGLE);
+    m_playButton->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_playButton->connectValueChangeRequest(
             this, &EngineBuffer::slotControlPlayRequest,
             Qt::DirectConnection);
@@ -141,7 +141,7 @@ EngineBuffer::EngineBuffer(const QString& group,
 
     // Start button
     m_startButton = new ControlPushButton(ConfigKey(m_group, "start"));
-    m_startButton->setButtonMode(ControlPushButton::TRIGGER);
+    m_startButton->setButtonMode(mixxx::control::ButtonMode::Trigger);
     connect(m_startButton, &ControlObject::valueChanged,
             this, &EngineBuffer::slotControlStart,
             Qt::DirectConnection);
@@ -153,7 +153,7 @@ EngineBuffer::EngineBuffer(const QString& group,
             Qt::DirectConnection);
 
     m_pSlipButton = new ControlPushButton(ConfigKey(m_group, "slip_enabled"));
-    m_pSlipButton->setButtonMode(ControlPushButton::TOGGLE);
+    m_pSlipButton->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_playposSlider = new ControlLinPotmeter(
         ConfigKey(m_group, "playposition"), 0.0, 1.0, 0, 0, true);
@@ -165,15 +165,31 @@ EngineBuffer::EngineBuffer(const QString& group,
     m_visualPlayPos = VisualPlayPosition::getVisualPlayPosition(m_group);
 
     m_pRepeat = new ControlPushButton(ConfigKey(m_group, "repeat"));
-    m_pRepeat->setButtonMode(ControlPushButton::TOGGLE);
+    m_pRepeat->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_pSampleRate = new ControlProxy(kAppGroup, QStringLiteral("samplerate"), this);
 
     m_pTrackSamples = new ControlObject(ConfigKey(m_group, "track_samples"));
     m_pTrackSampleRate = new ControlObject(ConfigKey(m_group, "track_samplerate"));
 
+    m_pTrackType = new ControlObject(ConfigKey(m_group, "track_type"));
+    m_pTrackTypeLength = new ControlObject(ConfigKey(m_group, "track_type_length"));
+    m_pTrackArtistLength = new ControlObject(ConfigKey(m_group, "track_artist_length"));
+    m_pTrackArtist_1 = new ControlObject(ConfigKey(m_group, "track_artist_1"));
+    m_pTrackArtist_2 = new ControlObject(ConfigKey(m_group, "track_artist_2"));
+    m_pTrackArtist_3 = new ControlObject(ConfigKey(m_group, "track_artist_3"));
+    m_pTrackArtist_4 = new ControlObject(ConfigKey(m_group, "track_artist_4"));
+    m_pTrackArtist_5 = new ControlObject(ConfigKey(m_group, "track_artist_5"));
+
+    m_pTrackTitleLength = new ControlObject(ConfigKey(m_group, "track_title_length"));
+    m_pTrackTitle_1 = new ControlObject(ConfigKey(m_group, "track_title_1"));
+    m_pTrackTitle_2 = new ControlObject(ConfigKey(m_group, "track_title_2"));
+    m_pTrackTitle_3 = new ControlObject(ConfigKey(m_group, "track_title_3"));
+    m_pTrackTitle_4 = new ControlObject(ConfigKey(m_group, "track_title_4"));
+    m_pTrackTitle_5 = new ControlObject(ConfigKey(m_group, "track_title_5"));
+
     m_pKeylock = new ControlPushButton(ConfigKey(m_group, "keylock"), true);
-    m_pKeylock->setButtonMode(ControlPushButton::TOGGLE);
+    m_pKeylock->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_pReplayGain = new ControlProxy(m_group, QStringLiteral("replaygain"), this);
 
@@ -311,6 +327,22 @@ EngineBuffer::~EngineBuffer() {
     delete m_pTrackSamples;
     delete m_pTrackSampleRate;
 
+    delete m_pTrackType;
+    delete m_pTrackTypeLength;
+    delete m_pTrackArtistLength;
+    delete m_pTrackArtist_1;
+    delete m_pTrackArtist_2;
+    delete m_pTrackArtist_3;
+    delete m_pTrackArtist_4;
+    delete m_pTrackArtist_5;
+
+    delete m_pTrackTitleLength;
+    delete m_pTrackTitle_1;
+    delete m_pTrackTitle_2;
+    delete m_pTrackTitle_3;
+    delete m_pTrackTitle_4;
+    delete m_pTrackTitle_5;
+
     delete m_pScaleLinear;
     delete m_pScaleST;
 #ifdef __RUBBERBAND__
@@ -562,6 +594,118 @@ void EngineBuffer::slotTrackLoaded(TrackPointer pTrack,
     m_pTrackSampleRate->set(trackSampleRate.toDouble());
     m_pTrackLoaded->forceSet(1);
 
+    // Eve start
+    // Type
+    QString TrackInfoType = pTrack->getType();
+    QString TrackInfoTypeTest = TrackInfoType;
+    int TrackInfoTypeTestLength = TrackInfoTypeTest.length();
+    if (TrackInfoTypeTestLength > 5) {
+        TrackInfoType = TrackInfoTypeTest.mid(0, 5);
+    };
+    m_pTrackTypeLength->set(TrackInfoTypeTestLength);
+
+    int CharType[5];
+    for (int i = 1; i <= 5; i++) {
+        CharType[i - 1] = 0;
+    }
+
+    for (int i = 1; i <= TrackInfoType.length(); i++) {
+        if ((TrackInfoType.at(i - 1).toLatin1()) < 0) {
+            CharType[i - 1] = ((TrackInfoType.at(i - 1).toLatin1()) + 300);
+        } else {
+            CharType[i - 1] = (TrackInfoType.at(i - 1).toLatin1());
+        };
+    }
+
+    double TrackTypePart = 0.0;
+    TrackTypePart = (1.0 * CharType[0] * 1000000000000) + (1.0 * CharType[1] * 1000000000) + (1.0 * CharType[2] * 1000000) + (1.0 * CharType[3] * 1000) + (1.0 * CharType[4] * 1);
+    m_pTrackType->set(TrackTypePart);
+
+    // Title
+    QString TrackInfoTitle = pTrack->getTitle();
+    QString TrackInfoTitleTest = TrackInfoTitle;
+    int TrackInfoTitleTestLength = TrackInfoTitleTest.length();
+    if (TrackInfoTitleTestLength > 200) {
+        TrackInfoTitle = TrackInfoTitleTest.mid(0, 200);
+    };
+    m_pTrackTitleLength->set(TrackInfoTitleTestLength);
+
+    int CharTitle[200];
+    for (int i = 1; i <= 200; i++) {
+        CharTitle[i - 1] = 0;
+    }
+
+//    for (int i = 1; i <= TrackInfoTitle.length(); i++) {
+    for (int i = 1; i <= 25; i++) {
+        if ((TrackInfoTitle.at(i - 1).toLatin1()) < 0) {
+            CharTitle[i - 1] = ((TrackInfoTitle.at(i - 1).toLatin1()) + 300);
+        } else {
+            CharTitle[i - 1] = (TrackInfoTitle.at(i - 1).toLatin1());
+        };
+    }
+
+    // Artist
+    QString TrackInfoArtist = pTrack->getArtist();
+    QString TrackInfoArtistTest = TrackInfoArtist;
+    int TrackInfoArtistTestLength = TrackInfoArtistTest.length();
+    if (TrackInfoArtistTestLength > 200) {
+        TrackInfoArtist = TrackInfoArtist.mid(0, 200);
+    };
+    m_pTrackArtistLength->set(TrackInfoArtistTestLength);
+
+    int CharArtist[200];
+    for (int i = 1; i <= 200; i++) {
+        CharArtist[i - 1] = 0;
+    }
+
+//    for (int i = 1; i <= TrackInfoArtist.length(); i++) {
+    for (int i = 1; i <= 25; i++) {
+        if ((TrackInfoArtist.at(i - 1).toLatin1()) < 0) {
+            CharArtist[i - 1] = ((TrackInfoArtist.at(i - 1).toLatin1()) + 300);
+        } else {
+            CharArtist[i - 1] = (TrackInfoArtist.at(i - 1).toLatin1());
+        };
+    }
+
+    double TrackTitlePart_1 = 0.0;
+    double TrackTitlePart_2 = 0.0;
+    double TrackTitlePart_3 = 0.0;
+    double TrackTitlePart_4 = 0.0;
+    double TrackTitlePart_5 = 0.0;
+
+
+    TrackTitlePart_1 = (1.0 * CharTitle[0] * 1000000000000) + (1.0 * CharTitle[1] * 1000000000) + (1.0 * CharTitle[2] * 1000000) + (1.0 * CharTitle[3] * 1000) + (1.0 * CharTitle[4] * 1);
+    TrackTitlePart_2 = (1.0 * CharTitle[5] * 1000000000000) + (1.0 * CharTitle[6] * 1000000000) + (1.0 * CharTitle[7] * 1000000) + (1.0 * CharTitle[8] * 1000) + (1.0 * CharTitle[9] * 1);
+    TrackTitlePart_3 = (1.0 * CharTitle[10] * 1000000000000) + (1.0 * CharTitle[11] * 1000000000) + (1.0 * CharTitle[12] * 1000000) + (1.0 * CharTitle[13] * 1000) + (1.0 * CharTitle[14] * 1);
+    TrackTitlePart_4 = (1.0 * CharTitle[15] * 1000000000000) + (1.0 * CharTitle[16] * 1000000000) + (1.0 * CharTitle[17] * 1000000) + (1.0 * CharTitle[18] * 1000) + (1.0 * CharTitle[19] * 1);
+    TrackTitlePart_5 = (1.0 * CharTitle[20] * 1000000000000) + (1.0 * CharTitle[21] * 1000000000) + (1.0 * CharTitle[22] * 1000000) + (1.0 * CharTitle[23] * 1000) + (1.0 * CharTitle[24] * 1);
+
+    m_pTrackTitle_1->set(TrackTitlePart_1);
+    m_pTrackTitle_2->set(TrackTitlePart_2);
+    m_pTrackTitle_3->set(TrackTitlePart_3);
+    m_pTrackTitle_4->set(TrackTitlePart_4);
+    m_pTrackTitle_5->set(TrackTitlePart_5);
+
+    double TrackArtistPart_1 = 0.0;
+    double TrackArtistPart_2 = 0.0;
+    double TrackArtistPart_3 = 0.0;
+    double TrackArtistPart_4 = 0.0;
+    double TrackArtistPart_5 = 0.0;
+
+    TrackArtistPart_1 = (1.0 * CharArtist[0] * 1000000000000) + (1.0 * CharArtist[1] * 1000000000) + (1.0 * CharArtist[2] * 1000000) + (1.0 * CharArtist[3] * 1000) + (1.0 * CharArtist[4] * 1);
+    TrackArtistPart_2 = (1.0 * CharArtist[5] * 1000000000000) + (1.0 * CharArtist[6] * 1000000000) + (1.0 * CharArtist[7] * 1000000) + (1.0 * CharArtist[8] * 1000) + (1.0 * CharArtist[9] * 1);
+    TrackArtistPart_3 = (1.0 * CharArtist[10] * 1000000000000) + (1.0 * CharArtist[11] * 1000000000) + (1.0 * CharArtist[12] * 1000000) + (1.0 * CharArtist[13] * 1000) + (1.0 * CharArtist[14] * 1);
+    TrackArtistPart_4 = (1.0 * CharArtist[15] * 1000000000000) + (1.0 * CharArtist[16] * 1000000000) + (1.0 * CharArtist[17] * 1000000) + (1.0 * CharArtist[18] * 1000) + (1.0 * CharArtist[19] * 1);
+    TrackArtistPart_5 = (1.0 * CharArtist[20] * 1000000000000) + (1.0 * CharArtist[21] * 1000000000) + (1.0 * CharArtist[22] * 1000000) + (1.0 * CharArtist[23] * 1000) + (1.0 * CharArtist[24] * 1);
+
+    m_pTrackArtist_1->set(TrackArtistPart_1);
+    m_pTrackArtist_2->set(TrackArtistPart_2);
+    m_pTrackArtist_3->set(TrackArtistPart_3);
+    m_pTrackArtist_4->set(TrackArtistPart_4);
+    m_pTrackArtist_5->set(TrackArtistPart_5);
+
+    // Eve end
+
     // Reset slip mode
     m_pSlipButton->set(0);
     m_bSlipEnabledProcessing = false;
@@ -631,6 +775,22 @@ void EngineBuffer::ejectTrack() {
     m_pTrackSampleRate->set(0);
     m_pTrackLoaded->forceSet(0);
 
+    m_pTrackType->set(0);
+    m_pTrackTypeLength->set(0);
+    m_pTrackArtistLength->set(0);
+    m_pTrackArtist_1->set(0);
+    m_pTrackArtist_2->set(0);
+    m_pTrackArtist_3->set(0);
+    m_pTrackArtist_4->set(0);
+    m_pTrackArtist_5->set(0);
+
+    m_pTrackTitleLength->set(0);
+    m_pTrackTitle_1->set(0);
+    m_pTrackTitle_2->set(0);
+    m_pTrackTitle_3->set(0);
+    m_pTrackTitle_4->set(0);
+    m_pTrackTitle_5->set(0);
+
     m_playButton->set(0.0);
     m_playposSlider->set(0);
     m_pCueControl->resetIndicators();
@@ -1540,12 +1700,22 @@ void EngineBuffer::hintReader(const double dRate) {
 }
 
 // WARNING: This method runs in the GUI thread
-void EngineBuffer::loadTrack(TrackPointer pTrack, bool play, EngineChannel* pChannelToCloneFrom) {
+void EngineBuffer::loadTrack(TrackPointer pTrack,
+#ifdef __STEM__
+        uint stemIdx,
+#endif
+        bool play,
+        EngineChannel* pChannelToCloneFrom) {
     if (pTrack) {
         // Signal to the reader to load the track. The reader will respond with
         // trackLoading and then either with trackLoaded or trackLoadFailed signals.
         m_bPlayAfterLoading = play;
-        m_pReader->newTrack(pTrack);
+        m_pReader->newTrack(pTrack
+#ifdef __STEM__
+                ,
+                stemIdx
+#endif
+        );
         atomicStoreRelaxed(m_pChannelToCloneFrom, pChannelToCloneFrom);
     } else {
         // Loading a null track means "eject"
diff --git a/src/engine/enginebuffer.h b/src/engine/enginebuffer.h
index 202d64dd5a..109fefc175 100644
--- a/src/engine/enginebuffer.h
+++ b/src/engine/enginebuffer.h
@@ -215,7 +215,12 @@ class EngineBuffer : public EngineObject {
     // Request that the EngineBuffer load a track. Since the process is
     // asynchronous, EngineBuffer will emit a trackLoaded signal when the load
     // has completed.
-    void loadTrack(TrackPointer pTrack, bool play, EngineChannel* pChannelToCloneFrom);
+    void loadTrack(TrackPointer pTrack,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play,
+            EngineChannel* pChannelToCloneFrom);
 
     void setChannelIndex(int channelIndex) {
         m_channelIndex = channelIndex;
@@ -389,6 +394,26 @@ class EngineBuffer : public EngineObject {
     ControlObject* m_pTrackSamples;
     ControlObject* m_pTrackSampleRate;
 
+        // TrackType
+    ControlObject* m_pTrackType;
+    ControlObject* m_pTrackTypeLength;
+
+    // TrackArtist
+    ControlObject* m_pTrackArtistLength;
+    ControlObject* m_pTrackArtist_1;
+    ControlObject* m_pTrackArtist_2;
+    ControlObject* m_pTrackArtist_3;
+    ControlObject* m_pTrackArtist_4;
+    ControlObject* m_pTrackArtist_5;
+
+    // TrackTitle
+    ControlObject* m_pTrackTitleLength;
+    ControlObject* m_pTrackTitle_1;
+    ControlObject* m_pTrackTitle_2;
+    ControlObject* m_pTrackTitle_3;
+    ControlObject* m_pTrackTitle_4;
+    ControlObject* m_pTrackTitle_5;
+
     ControlPushButton* m_playButton;
     ControlPushButton* m_playStartButton;
     ControlPushButton* m_stopStartButton;
diff --git a/src/engine/enginemixer.cpp b/src/engine/enginemixer.cpp
index fe68d85f0b..a322d60dd0 100644
--- a/src/engine/enginemixer.cpp
+++ b/src/engine/enginemixer.cpp
@@ -138,7 +138,7 @@ EngineMixer::EngineMixer(
 
     // Main / Headphone split-out mode (for devices with only one output).
     m_pHeadSplitEnabled = new ControlPushButton(ConfigKey(group, "headSplit"));
-    m_pHeadSplitEnabled->setButtonMode(ControlPushButton::TOGGLE);
+    m_pHeadSplitEnabled->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pHeadSplitEnabled->set(0.0);
 
     m_pTalkoverDucking = new EngineTalkoverDucking(pConfig, group);
@@ -170,7 +170,7 @@ EngineMixer::EngineMixer(
     // X-Fader Setup
     m_pXFaderMode = new ControlPushButton(
             ConfigKey(EngineXfader::kXfaderConfigKey, "xFaderMode"));
-    m_pXFaderMode->setButtonMode(ControlPushButton::TOGGLE);
+    m_pXFaderMode->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_pXFaderCurve = new ControlPotmeter(
             ConfigKey(EngineXfader::kXfaderConfigKey, "xFaderCurve"),
@@ -180,7 +180,7 @@ EngineMixer::EngineMixer(
             0.3, 1., true);
     m_pXFaderReverse = new ControlPushButton(
             ConfigKey(EngineXfader::kXfaderConfigKey, "xFaderReverse"));
-    m_pXFaderReverse->setButtonMode(ControlPushButton::TOGGLE);
+    m_pXFaderReverse->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_pKeylockEngine = new ControlObject(ConfigKey(kAppGroup, QStringLiteral("keylock_engine")));
     m_pKeylockEngine->set(static_cast<double>(
@@ -887,7 +887,7 @@ void EngineMixer::addChannel(EngineChannel* pChannel) {
     pChannelInfo->m_pVolumeControl->set(1.0);
     pChannelInfo->m_pMuteControl = new ControlPushButton(
             ConfigKey(group, "mute"));
-    pChannelInfo->m_pMuteControl->setButtonMode(ControlPushButton::POWERWINDOW);
+    pChannelInfo->m_pMuteControl->setButtonMode(mixxx::control::ButtonMode::PowerWindow);
     pChannelInfo->m_pBuffer = mixxx::SampleBuffer(kMaxEngineSamples);
     pChannelInfo->m_pBuffer.clear();
     m_channels.append(pChannelInfo);
diff --git a/src/engine/enginetalkoverducking.cpp b/src/engine/enginetalkoverducking.cpp
index 75253d9f72..60246a3b06 100644
--- a/src/engine/enginetalkoverducking.cpp
+++ b/src/engine/enginetalkoverducking.cpp
@@ -37,8 +37,7 @@ EngineTalkoverDucking::EngineTalkoverDucking(
             static_cast<unsigned int>(m_pSampleRate->get() / 2));
 
     m_pTalkoverDucking = new ControlPushButton(ConfigKey(m_group, "talkoverDucking"));
-    m_pTalkoverDucking->setButtonMode(ControlPushButton::TOGGLE);
-    m_pTalkoverDucking->setStates(3);
+    m_pTalkoverDucking->setBehavior(mixxx::control::ButtonMode::Toggle, 3);
     m_pTalkoverDucking->set(
             m_pConfig->getValue<double>(
                 ConfigKey(m_group, "duckMode"), AUTO));
diff --git a/src/engine/sidechain/enginenetworkstream.cpp b/src/engine/sidechain/enginenetworkstream.cpp
index 1b555145ae..84c52d9ba5 100644
--- a/src/engine/sidechain/enginenetworkstream.cpp
+++ b/src/engine/sidechain/enginenetworkstream.cpp
@@ -134,8 +134,8 @@ qint64 EngineNetworkStream::getInputStreamTimeUs() {
 qint64 EngineNetworkStream::getNetworkTimeUs() {
     // This matches the GPL2 implementation found in
     // https://github.com/codders/libshout/blob/a17fb84671d3732317b0353d7281cc47e2df6cf6/src/timing/timing.c
-    // Instead of ms resolution we use a us resolution to allow low latency settings
-    // will overflow > 200,000 years
+    // Instead of ms resolution we use a us resolution to
+    // allow low latency settings will overflow > 200,000 years
 #ifdef __WINDOWS__
     FILETIME ft;
     // no GetSystemTimePreciseAsFileTime available, fall
diff --git a/src/engine/sidechain/engineoscclient.cpp b/src/engine/sidechain/engineoscclient.cpp
new file mode 100644
index 0000000000..8aa80b1aae
--- /dev/null
+++ b/src/engine/sidechain/engineoscclient.cpp
@@ -0,0 +1,118 @@
+/***************************************************************************
+                          EngineOscClient.cpp  -  class to record the mix
+                             -------------------
+    copyright            : (C) 2007 by John Sully
+    copyright            : (C) 2010 by Tobias Rafreider
+    email                :
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "engine/sidechain/engineoscclient.h"
+
+#include <QDebug>
+
+#include "control/controlobject.h"
+#include "control/controlproxy.h"
+#include "errordialoghandler.h"
+#include "mixer/playerinfo.h"
+#include "mixer/playermanager.h"
+#include "oscclient/defs_oscclient.h"
+#include "preferences/usersettings.h"
+#include "util/event.h"
+
+EngineOscClient::EngineOscClient(UserSettingsPointer& pConfig)
+        : m_pConfig(pConfig),
+          m_prefUpdate(ConfigKey("[Preferences]", "updated")) {
+    connectServer();
+
+    ControlProxy* xfader =
+            new ControlProxy(ConfigKey("[Master]", "crossfader"), this);
+    xfader->connectValueChanged(this, &EngineOscClient::maybeSendState);
+    m_connectedControls.append(xfader);
+
+    // connect play buttons
+    for (int deckNr = 0; deckNr < (int)PlayerManager::numDecks(); deckNr++) {
+        ControlProxy* play = new ControlProxy(
+                ConfigKey(PlayerManager::groupForDeck(deckNr), "play"), this);
+        play->connectValueChanged(this, &EngineOscClient::maybeSendState);
+        m_connectedControls.append(play);
+
+        ControlProxy* volume = new ControlProxy(
+                ConfigKey(PlayerManager::groupForDeck(deckNr), "volume"), this);
+        volume->connectValueChanged(this, &EngineOscClient::maybeSendState);
+        m_connectedControls.append(volume);
+    }
+
+    // connect to settings changes
+    connect(&m_prefUpdate, SIGNAL(valueChanged(double)), this, SLOT(connectServer()));
+}
+
+EngineOscClient::~EngineOscClient() {
+}
+
+void EngineOscClient::process(const CSAMPLE* pBuffer, const int iBufferSize) {
+    if (m_time.elapsed() < 10)
+        return;
+    sendState();
+}
+
+void EngineOscClient::sendState() {
+    PlayerInfo& playerInfo = PlayerInfo::instance();
+    int numDecks = (int)PlayerManager::numDecks();
+    lo_send(m_serverAddress, "/mixxx/numDecks", "i", numDecks);
+
+    for (int deckNr = 0; deckNr < numDecks; deckNr++) {
+        lo_send(m_serverAddress, "/mixxx/deck/playing", "ii", deckNr, (int)playerInfo.isDeckPlaying(deckNr));
+        lo_send(m_serverAddress, "/mixxx/deck/volume", "if", deckNr, playerInfo.getDeckVolume(deckNr));
+
+        // speed
+        ControlProxy rate(ConfigKey(PlayerManager::groupForDeck(deckNr), "rate"));
+        ControlProxy rateRange(
+                ConfigKey(PlayerManager::groupForDeck(deckNr), "rateRange"));
+        ControlProxy rev(ConfigKey(PlayerManager::groupForDeck(deckNr), "reverse"));
+        float speed = 1 + float(rate.get()) * float(rateRange.get());
+        if (rev.get())
+            speed *= -1;
+        lo_send(m_serverAddress, "/mixxx/deck/speed", "if", deckNr, speed);
+
+        ControlProxy posRel(
+                ConfigKey(PlayerManager::groupForDeck(deckNr), "playposition"));
+        lo_send(m_serverAddress, "/mixxx/deck/pos", "if", deckNr, float(posRel.get()));
+
+        ControlProxy dur(
+                ConfigKey(PlayerManager::groupForDeck(deckNr), "duration"));
+        lo_send(m_serverAddress, "/mixxx/deck/duration", "if", deckNr, float(dur.get()));
+
+        QString title = "";
+        TrackPointer pTrack =
+                playerInfo.getTrackInfo(PlayerManager::groupForDeck(deckNr));
+        if (pTrack) {
+            title = pTrack->getTitle();
+        }
+        lo_send(m_serverAddress, "/mixxx/deck/title", "is", deckNr, title.toUtf8().data());
+    }
+    m_time.restart();
+}
+
+void EngineOscClient::maybeSendState() {
+    if (m_time.elapsed() < 10)
+        return;
+    sendState();
+}
+
+void EngineOscClient::connectServer() {
+    QString server =
+            m_pConfig->getValueString(ConfigKey(OSC_CLIENT_PREF_KEY, "Server"));
+    QString port =
+            m_pConfig->getValueString(ConfigKey(OSC_CLIENT_PREF_KEY, "Port"));
+    m_serverAddress =
+            lo_address_new(server.toLatin1().data(), port.toLatin1().data());
+}
\ No newline at end of file
diff --git a/src/engine/sidechain/engineoscclient.h b/src/engine/sidechain/engineoscclient.h
new file mode 100644
index 0000000000..e93b8b4829
--- /dev/null
+++ b/src/engine/sidechain/engineoscclient.h
@@ -0,0 +1,57 @@
+/***************************************************************************
+                          EngineOscClient.h  -  description
+                             -------------------
+    copyright            : (C) 2007 by John Sully
+    email                :
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef EngineOscClient_H
+#define EngineOscClient_H
+
+#include <QList>
+#include <QTime>
+
+#include "control/controlobject.h"
+#include "control/controlproxy.h"
+#include "engine/sidechain/sidechainworker.h"
+#include "lo/lo.h"
+#include "preferences/usersettings.h"
+#include "track/track.h"
+
+class ConfigKey;
+class Encoder;
+
+class EngineOscClient : public QObject, public SideChainWorker {
+    Q_OBJECT
+  public:
+    EngineOscClient(UserSettingsPointer& pConfig);
+    virtual ~EngineOscClient();
+
+  public slots:
+    void sendState();
+    void maybeSendState();
+    void connectServer();
+
+    // interface SideChainWorker
+    void process(const CSAMPLE* pBuffer, const int iBufferSize);
+    void shutdown() {
+    }
+
+  private:
+    QTime m_time;
+    lo_address m_serverAddress;
+    UserSettingsPointer m_pConfig;
+    QList<ControlProxy*> m_connectedControls;
+    ControlProxy m_prefUpdate;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/engine/sync/internalclock.cpp b/src/engine/sync/internalclock.cpp
index e5ba10d363..2a2ed0c290 100644
--- a/src/engine/sync/internalclock.cpp
+++ b/src/engine/sync/internalclock.cpp
@@ -44,8 +44,7 @@ InternalClock::InternalClock(const QString& group, SyncableListener* pEngineSync
 
     m_pSyncLeaderEnabled.reset(
             new ControlPushButton(ConfigKey(m_group, "sync_leader")));
-    m_pSyncLeaderEnabled->setButtonMode(ControlPushButton::TOGGLE);
-    m_pSyncLeaderEnabled->setStates(3);
+    m_pSyncLeaderEnabled->setBehavior(mixxx::control::ButtonMode::Toggle, 3);
     m_pSyncLeaderEnabled->connectValueChangeRequest(
             this, &InternalClock::slotSyncLeaderEnabledChangeRequest, Qt::DirectConnection);
     m_pSyncLeaderEnabled->addAlias(ConfigKey(m_group, QStringLiteral("sync_master")));
diff --git a/src/engine/sync/synccontrol.cpp b/src/engine/sync/synccontrol.cpp
index 66655a3465..2ed856443d 100644
--- a/src/engine/sync/synccontrol.cpp
+++ b/src/engine/sync/synccontrol.cpp
@@ -45,22 +45,21 @@ SyncControl::SyncControl(const QString& group,
     m_pPlayButton->connectValueChanged(this, &SyncControl::slotControlPlay, Qt::DirectConnection);
 
     m_pSyncMode.reset(new ControlPushButton(ConfigKey(group, "sync_mode")));
-    m_pSyncMode->setButtonMode(ControlPushButton::TOGGLE);
-    m_pSyncMode->setStates(static_cast<int>(SyncMode::NumModes));
+    m_pSyncMode->setBehavior(mixxx::control::ButtonMode::Toggle,
+            static_cast<int>(SyncMode::NumModes));
     m_pSyncMode->connectValueChangeRequest(
             this, &SyncControl::slotSyncModeChangeRequest, Qt::DirectConnection);
 
     m_pSyncLeaderEnabled.reset(
             new ControlPushButton(ConfigKey(group, "sync_leader")));
-    m_pSyncLeaderEnabled->setButtonMode(ControlPushButton::TOGGLE);
-    m_pSyncLeaderEnabled->setStates(3);
+    m_pSyncLeaderEnabled->setBehavior(mixxx::control::ButtonMode::Toggle, 3);
     m_pSyncLeaderEnabled->connectValueChangeRequest(
             this, &SyncControl::slotSyncLeaderEnabledChangeRequest, Qt::DirectConnection);
     m_pSyncLeaderEnabled->addAlias(ConfigKey(group, QStringLiteral("sync_master")));
 
     m_pSyncEnabled.reset(
             new ControlPushButton(ConfigKey(group, "sync_enabled")));
-    m_pSyncEnabled->setButtonMode(ControlPushButton::LONGPRESSLATCHING);
+    m_pSyncEnabled->setButtonMode(mixxx::control::ButtonMode::LongPressLatching);
     m_pSyncEnabled->connectValueChangeRequest(
             this, &SyncControl::slotSyncEnabledChangeRequest, Qt::DirectConnection);
 
diff --git a/src/library/analysis/analysisfeature.cpp b/src/library/analysis/analysisfeature.cpp
index a713f57ddf..1ecb67efeb 100644
--- a/src/library/analysis/analysisfeature.cpp
+++ b/src/library/analysis/analysisfeature.cpp
@@ -81,7 +81,11 @@ void AnalysisFeature::bindLibraryWidget(WLibrary* libraryWidget,
             &DlgAnalysis::loadTrackToPlayer,
             this,
             [=, this](TrackPointer track, const QString& group) {
-                emit loadTrackToPlayer(track, group, false);
+                emit loadTrackToPlayer(track, group,
+#ifdef __STEM__
+                        mixxx::kNoStemSelectedIdx,
+#endif
+                        false);
             });
     connect(m_pAnalysisView,
             &DlgAnalysis::analyzeTracks,
diff --git a/src/library/autodj/autodjfeature.cpp b/src/library/autodj/autodjfeature.cpp
index cdca01516a..6ddba3d861 100644
--- a/src/library/autodj/autodjfeature.cpp
+++ b/src/library/autodj/autodjfeature.cpp
@@ -15,6 +15,7 @@
 #include "sources/soundsourceproxy.h"
 #include "track/track.h"
 #include "util/clipboard.h"
+#include "util/defs.h"
 #include "util/dnd.h"
 #include "widget/wlibrary.h"
 #include "widget/wlibrarysidebar.h"
@@ -94,17 +95,28 @@ AutoDJFeature::AutoDJFeature(Library* pLibrary,
             this,
             &AutoDJFeature::slotCrateChanged);
 
+    m_pClearQueueAction = make_parented<QAction>(tr("Clear Auto DJ Queue"), this);
+    const auto removeKeySequence =
+            // TODO(XXX): Qt6 replace enum | with QKeyCombination
+            QKeySequence(static_cast<int>(kHideRemoveShortcutModifier) |
+                    kHideRemoveShortcutKey);
+    m_pClearQueueAction->setShortcut(removeKeySequence);
+    connect(m_pClearQueueAction.get(),
+            &QAction::triggered,
+            this,
+            &AutoDJFeature::slotClearQueue);
     // Create context-menu items to allow crates to be added to, and removed
     // from, the auto-DJ queue.
-    m_pRemoveCrateFromAutoDj = new QAction(tr("Remove Crate as Track Source"), this);
-    connect(m_pRemoveCrateFromAutoDj,
+    m_pRemoveCrateFromAutoDjAction =
+            make_parented<QAction>(tr("Remove Crate as Track Source"), this);
+    m_pRemoveCrateFromAutoDjAction->setShortcut(removeKeySequence);
+    connect(m_pRemoveCrateFromAutoDjAction.get(),
             &QAction::triggered,
             this,
             &AutoDJFeature::slotRemoveCrateFromAutoDj);
 }
 
 AutoDJFeature::~AutoDJFeature() {
-    delete m_pRemoveCrateFromAutoDj;
     delete m_pAutoDJProcessor;
 }
 
@@ -164,13 +176,38 @@ void AutoDJFeature::activate() {
 }
 
 void AutoDJFeature::clear() {
-    m_playlistDao.clearAutoDJQueue();
+    QMessageBox::StandardButton btn = QMessageBox::question(nullptr,
+            tr("Confirmation Clear"),
+            tr("Do you really want to remove all tracks from the Auto DJ queue?") +
+                    tr("This can not be undone."),
+            QMessageBox::Yes | QMessageBox::No,
+            QMessageBox::No);
+    if (btn == QMessageBox::Yes) {
+            m_playlistDao.clearAutoDJQueue();
+    }
 }
 
 void AutoDJFeature::paste() {
     emit pasteFromSidebar();
 }
 
+// Called by SidebarModel
+void AutoDJFeature::deleteItem(const QModelIndex& index) {
+    TreeItem* pSelectedItem = static_cast<TreeItem*>(index.internalPointer());
+    if (!pSelectedItem || pSelectedItem == m_pCratesTreeItem) {
+            return;
+    }
+    CrateId crateId(pSelectedItem->getData());
+    removeCrateFromAutoDj(crateId);
+}
+
+// Called by deleteItem and slotRemoveCrateFromAutoDj()
+void AutoDJFeature::removeCrateFromAutoDj(CrateId crateId) {
+    DEBUG_ASSERT(crateId.isValid());
+    // TODO Confirm dialog?
+    m_pTrackCollection->updateAutoDjCrate(crateId, false);
+}
+
 bool AutoDJFeature::dropAccept(const QList<QUrl>& urls, QObject* pSource) {
     // If a track is dropped onto the Auto DJ tree node, but the track isn't in the
     // library, then add the track to the library before adding it to the
@@ -192,15 +229,18 @@ bool AutoDJFeature::dragMoveAccept(const QUrl& url) {
             Parser::isPlaylistFilenameSupported(url.toLocalFile());
 }
 
+void AutoDJFeature::slotClearQueue() {
+    clear();
+}
+
 // Add a crate to the auto-DJ queue.
 void AutoDJFeature::slotAddCrateToAutoDj(CrateId crateId) {
     m_pTrackCollection->updateAutoDjCrate(crateId, true);
 }
 
 void AutoDJFeature::slotRemoveCrateFromAutoDj() {
-    CrateId crateId(m_pRemoveCrateFromAutoDj->data());
-    DEBUG_ASSERT(crateId.isValid());
-    m_pTrackCollection->updateAutoDjCrate(crateId, false);
+    CrateId crateId(m_pRemoveCrateFromAutoDjAction->data().value<CrateId>());
+    removeCrateFromAutoDj(crateId);
 }
 
 void AutoDJFeature::slotCrateChanged(CrateId crateId) {
@@ -294,6 +334,12 @@ void AutoDJFeature::constructCrateChildModel() {
     }
 }
 
+void AutoDJFeature::onRightClick(const QPoint& globalPos) {
+    QMenu menu(m_pSidebarWidget);
+    menu.addAction(m_pClearQueueAction.get());
+    menu.exec(globalPos);
+}
+
 void AutoDJFeature::onRightClickChild(const QPoint& globalPos,
         const QModelIndex& index) {
     TreeItem* pClickedItem = static_cast<TreeItem*>(index.internalPointer());
@@ -319,8 +365,8 @@ void AutoDJFeature::onRightClickChild(const QPoint& globalPos,
     } else {
         // A crate child item was right-clicked.
         // Bring up the context menu.
-        m_pRemoveCrateFromAutoDj->setData(pClickedItem->getData()); // the selected CrateId
-        menu.addAction(m_pRemoveCrateFromAutoDj);
+        m_pRemoveCrateFromAutoDjAction->setData(pClickedItem->getData()); // the selected CrateId
+        menu.addAction(m_pRemoveCrateFromAutoDjAction);
         menu.exec(globalPos);
     }
 }
diff --git a/src/library/autodj/autodjfeature.h b/src/library/autodj/autodjfeature.h
index 70451a49d7..d343186b91 100644
--- a/src/library/autodj/autodjfeature.h
+++ b/src/library/autodj/autodjfeature.h
@@ -34,6 +34,7 @@ class AutoDJFeature : public LibraryFeature {
 
     void clear() override;
     void paste() override;
+    void deleteItem(const QModelIndex& index) override;
 
     bool dropAccept(const QList<QUrl>& urls, QObject* pSource) override;
     bool dragMoveAccept(const QUrl& url) override;
@@ -51,6 +52,7 @@ class AutoDJFeature : public LibraryFeature {
   public slots:
     void activate() override;
 
+    void onRightClick(const QPoint& globalPos) override;
     // Temporary, until WCrateTableView can be written.
     void onRightClickChild(const QPoint& globalPos, const QModelIndex& index) override;
 
@@ -66,6 +68,7 @@ class AutoDJFeature : public LibraryFeature {
 
     // Initialize the list of crates loaded into the auto-DJ queue.
     void constructCrateChildModel();
+    void removeCrateFromAutoDj(CrateId crateId = CrateId());
 
     // The "Crates" tree-item under the "Auto DJ" tree-item.
     TreeItem* m_pCratesTreeItem;
@@ -78,24 +81,22 @@ class AutoDJFeature : public LibraryFeature {
     // How we access the auto-DJ-crates database.
     AutoDJCratesDAO m_autoDjCratesDao;
 
+    parented_ptr<QAction> m_pClearQueueAction;
     // A context-menu item that allows crates to be removed from the
     // auto-DJ list.
-    QAction* m_pRemoveCrateFromAutoDj;
+    parented_ptr<QAction> m_pRemoveCrateFromAutoDjAction;
 
     QPointer<WLibrarySidebar> m_pSidebarWidget;
 
   private slots:
+    void slotClearQueue();
     // Add a crate to the auto-DJ queue.
     void slotAddCrateToAutoDj(CrateId crateId);
-
     // Implements the context-menu item.
     void slotRemoveCrateFromAutoDj();
-
     void slotCrateChanged(CrateId crateId);
-
     // Adds a random track from all loaded crates to the auto-DJ queue.
     void slotAddRandomTrack();
-
     // Adds a random track from the queue upon hitting minimum number
     // of tracks in the playlist
     void slotRandomQueue(int numTracksToAdd);
diff --git a/src/library/autodj/autodjprocessor.cpp b/src/library/autodj/autodjprocessor.cpp
index f1fc74f250..165d2c6c4c 100644
--- a/src/library/autodj/autodjprocessor.cpp
+++ b/src/library/autodj/autodjprocessor.cpp
@@ -149,7 +149,7 @@ AutoDJProcessor::AutoDJProcessor(
 
     m_pEnabledAutoDJ = new ControlPushButton(
             ConfigKey("[AutoDJ]", "enabled"));
-    m_pEnabledAutoDJ->setButtonMode(ControlPushButton::TOGGLE);
+    m_pEnabledAutoDJ->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pEnabledAutoDJ->connectValueChangeRequest(this,
             &AutoDJProcessor::controlEnableChangeRequest);
 
diff --git a/src/library/autodj/autodjprocessor.h b/src/library/autodj/autodjprocessor.h
index 600cf7bfb7..38d0de3b67 100644
--- a/src/library/autodj/autodjprocessor.h
+++ b/src/library/autodj/autodjprocessor.h
@@ -201,7 +201,11 @@ class AutoDJProcessor : public QObject {
     AutoDJError toggleAutoDJ(bool enable);
 
   signals:
-    void loadTrackToPlayer(TrackPointer pTrack, const QString& group, bool play);
+    void loadTrackToPlayer(TrackPointer pTrack, const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play);
     void autoDJStateChanged(AutoDJProcessor::AutoDJState state);
     void autoDJError(AutoDJProcessor::AutoDJError error);
     void transitionTimeChanged(int time);
@@ -229,7 +233,11 @@ class AutoDJProcessor : public QObject {
   protected:
     // The following virtual signal wrappers are used for testing
     virtual void emitLoadTrackToPlayer(TrackPointer pTrack, const QString& group, bool play) {
-        emit loadTrackToPlayer(pTrack, group, play);
+        emit loadTrackToPlayer(pTrack, group,
+#ifdef __STEM__
+                mixxx::kNoStemSelectedIdx,
+#endif
+                play);
     }
     virtual void emitAutoDJStateChanged(AutoDJProcessor::AutoDJState state) {
         emit autoDJStateChanged(state);
diff --git a/src/library/autodj/dlgautodj.h b/src/library/autodj/dlgautodj.h
index 9ac38a1e72..47a585f599 100644
--- a/src/library/autodj/dlgautodj.h
+++ b/src/library/autodj/dlgautodj.h
@@ -49,7 +49,11 @@ class DlgAutoDJ : public QWidget, public Ui::DlgAutoDJ, public LibraryView {
   signals:
     void addRandomTrackButton(bool buttonChecked);
     void loadTrack(TrackPointer tio);
-    void loadTrackToPlayer(TrackPointer tio, const QString& group, bool);
+    void loadTrackToPlayer(TrackPointer tio, const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool);
     void trackSelected(TrackPointer pTrack);
 
   private:
diff --git a/src/library/basetracktablemodel.cpp b/src/library/basetracktablemodel.cpp
index 7b5d76cb18..32a70fe403 100644
--- a/src/library/basetracktablemodel.cpp
+++ b/src/library/basetracktablemodel.cpp
@@ -7,12 +7,12 @@
 #include "library/dao/trackschema.h"
 #include "library/starrating.h"
 #include "library/tabledelegates/bpmdelegate.h"
+#include "library/tabledelegates/checkboxdelegate.h"
 #include "library/tabledelegates/colordelegate.h"
 #include "library/tabledelegates/coverartdelegate.h"
 #include "library/tabledelegates/keydelegate.h"
 #include "library/tabledelegates/locationdelegate.h"
 #include "library/tabledelegates/multilineeditdelegate.h"
-#include "library/tabledelegates/playcountdelegate.h"
 #include "library/tabledelegates/previewbuttondelegate.h"
 #include "library/tabledelegates/stardelegate.h"
 #include "library/trackcollection.h"
@@ -24,6 +24,8 @@
 #include "track/track.h"
 #include "util/assert.h"
 #include "util/clipboard.h"
+#include "util/color/colorpalette.h"
+#include "util/color/predefinedcolorpalettes.h"
 #include "util/datetime.h"
 #include "util/db/sqlite.h"
 #include "util/logger.h"
@@ -106,6 +108,8 @@ constexpr bool BaseTrackTableModel::kKeyColorsEnabledDefault;
 int BaseTrackTableModel::s_bpmColumnPrecision =
         kBpmColumnPrecisionDefault;
 bool BaseTrackTableModel::s_keyColorsEnabled = kKeyColorsEnabledDefault;
+ColorPalette BaseTrackTableModel::s_keyColorPalette =
+        mixxx::PredefinedColorPalettes::kDefaultKeyColorPalette;
 
 // static
 void BaseTrackTableModel::setBpmColumnPrecision(int precision) {
@@ -120,10 +124,14 @@ void BaseTrackTableModel::setBpmColumnPrecision(int precision) {
 
 // static
 void BaseTrackTableModel::setKeyColorsEnabled(bool keyColorsEnabled) {
-    // todo: need to refresh the key column when this setting changes
     s_keyColorsEnabled = keyColorsEnabled;
 }
 
+// static
+void BaseTrackTableModel::setKeyColorPalette(const ColorPalette& palette) {
+    s_keyColorPalette = palette;
+}
+
 bool BaseTrackTableModel::s_bApplyPlayedTrackColor =
         kApplyPlayedTrackColorDefault;
 
@@ -492,7 +500,7 @@ QAbstractItemDelegate* BaseTrackTableModel::delegateForColumn(
     } else if (index == fieldIndex(ColumnCache::COLUMN_LIBRARYTABLE_BPM)) {
         return new BPMDelegate(pTableView);
     } else if (index == fieldIndex(ColumnCache::COLUMN_LIBRARYTABLE_TIMESPLAYED)) {
-        return new PlayCountDelegate(pTableView);
+        return new CheckboxDelegate(pTableView, QStringLiteral("LibraryPlayedCheckbox"));
     } else if (PlayerManager::numPreviewDecks() > 0 &&
             index == fieldIndex(ColumnCache::COLUMN_LIBRARYTABLE_PREVIEW)) {
         return new PreviewButtonDelegate(pTableView, index);
@@ -589,7 +597,7 @@ QVariant BaseTrackTableModel::data(
             role != Qt::ToolTipRole &&
             role != kDataExportRole &&
             role != Qt::TextAlignmentRole &&
-            role != Qt::UserRole) {
+            role != Qt::DecorationRole) {
         return QVariant();
     }
 
@@ -720,7 +728,7 @@ QVariant BaseTrackTableModel::roleValue(
         int role) const {
     const auto field = mapColumn(index.column());
     if (field == ColumnCache::COLUMN_LIBRARYTABLE_INVALID) {
-        return std::move(rawValue);
+        return rawValue;
     }
     switch (role) {
     case Qt::ToolTipRole:
@@ -734,7 +742,7 @@ QVariant BaseTrackTableModel::roleValue(
             return QVariant();
         case ColumnCache::COLUMN_LIBRARYTABLE_RATING:
         case ColumnCache::COLUMN_LIBRARYTABLE_TIMESPLAYED:
-            return std::move(rawValue);
+            return rawValue;
         default:
             // Same value as for Qt::DisplayRole (see below)
             break;
@@ -812,7 +820,7 @@ QVariant BaseTrackTableModel::roleValue(
                 return dt;
             }
             if (field == ColumnCache::COLUMN_PLAYLISTTRACKSTABLE_DATETIMEADDED) {
-                // Timstamp column in history feature:
+                // Timestamp column in history feature:
                 // Use localized date/time format without text: "5/20/98 03:40 AM"
                 return mixxx::displayLocalDateTime(dt);
             }
@@ -880,7 +888,7 @@ QVariant BaseTrackTableModel::roleValue(
             }
             if (rawValue.canConvert<mixxx::audio::Bitrate>()) {
                 // return value as is
-                return std::move(rawValue);
+                return rawValue;
             } else {
                 VERIFY_OR_DEBUG_ASSERT(rawValue.canConvert<int>()) {
                     return QVariant();
@@ -892,7 +900,7 @@ QVariant BaseTrackTableModel::roleValue(
                 }
                 if (mixxx::audio::Bitrate(bitrateValue).isValid()) {
                     // return value as is
-                    return std::move(rawValue);
+                    return rawValue;
                 } else {
                     // clear invalid values
                     return QVariant();
@@ -902,13 +910,14 @@ QVariant BaseTrackTableModel::roleValue(
         case ColumnCache::COLUMN_LIBRARYTABLE_KEY: {
             // If we know the semantic key via the LIBRARYTABLE_KEY_ID
             // column (as opposed to the string representation of the key
-            // currently stored in the DB) then lookup the key and return it
+            // currently stored in the DB) then lookup the key and render it
+            // using the user's selected notation.
             const QVariant keyCodeValue = rawSiblingValue(
                     index,
                     ColumnCache::COLUMN_LIBRARYTABLE_KEY_ID);
             if (keyCodeValue.isNull()) {
                 // Otherwise, just use the column value as is
-                return std::move(rawValue);
+                return rawValue;
             }
             bool ok;
             const auto keyCode = keyCodeValue.toInt(&ok);
@@ -919,7 +928,7 @@ QVariant BaseTrackTableModel::roleValue(
             if (key == mixxx::track::io::key::INVALID) {
                 return QVariant();
             }
-            return QVariant::fromValue(key);
+            return QVariant::fromValue(KeyUtils::keyToString(key));
         }
         case ColumnCache::COLUMN_LIBRARYTABLE_REPLAYGAIN: {
             if (rawValue.isNull()) {
@@ -1027,14 +1036,32 @@ QVariant BaseTrackTableModel::roleValue(
             return QVariant(); // default AlignLeft for all other columns
         }
     }
-    case Qt::UserRole: {
+    case Qt::DecorationRole: {
         switch (field) {
         case ColumnCache::COLUMN_LIBRARYTABLE_KEY: {
-            // return whether or not to display the color rectangle
-            return QVariant::fromValue(s_keyColorsEnabled);
+            // return color of key
+            if (!s_keyColorsEnabled) {
+                return QVariant();
+            }
+            const QVariant keyCodeValue = rawSiblingValue(
+                    index,
+                    ColumnCache::COLUMN_LIBRARYTABLE_KEY_ID);
+            if (keyCodeValue.isNull()) {
+                return QVariant();
+            }
+            bool ok;
+            const auto keyCode = keyCodeValue.toInt(&ok);
+            VERIFY_OR_DEBUG_ASSERT(ok) {
+                return QVariant();
+            }
+            const auto key = KeyUtils::keyFromNumericValue(keyCode);
+            if (key == mixxx::track::io::key::INVALID) {
+                return QVariant();
+            }
+            return QVariant::fromValue(KeyUtils::keyToColor(key, s_keyColorPalette));
         }
         default:
-            DEBUG_ASSERT(!"unexpected field for UserRole");
+            return QVariant();
         }
         break;
     }
@@ -1042,7 +1069,7 @@ QVariant BaseTrackTableModel::roleValue(
         DEBUG_ASSERT(!"unexpected role");
         break;
     }
-    return std::move(rawValue);
+    return rawValue;
 }
 
 bool BaseTrackTableModel::isBpmLocked(
diff --git a/src/library/basetracktablemodel.h b/src/library/basetracktablemodel.h
index 8025d088d1..2b023a71c0 100644
--- a/src/library/basetracktablemodel.h
+++ b/src/library/basetracktablemodel.h
@@ -7,6 +7,7 @@
 #include "library/columncache.h"
 #include "library/trackmodel.h"
 #include "track/track_decl.h"
+#include "util/color/colorpalette.h"
 
 class TrackCollectionManager;
 
@@ -108,6 +109,8 @@ class BaseTrackTableModel : public QAbstractTableModel, public TrackModel {
     static constexpr bool kKeyColorsEnabledDefault = true;
     static void setKeyColorsEnabled(bool keyColorsEnabled);
 
+    static void setKeyColorPalette(const ColorPalette& palette);
+
     static constexpr bool kApplyPlayedTrackColorDefault = true;
     static void setApplyPlayedTrackColor(bool apply);
 
@@ -297,6 +300,7 @@ class BaseTrackTableModel : public QAbstractTableModel, public TrackModel {
 
     static int s_bpmColumnPrecision;
     static bool s_keyColorsEnabled;
+    static ColorPalette s_keyColorPalette;
 
     static bool s_bApplyPlayedTrackColor;
 };
diff --git a/src/library/export/engineprimeexportjob.cpp b/src/library/export/engineprimeexportjob.cpp
index b1e4775ae5..d45fded1a9 100644
--- a/src/library/export/engineprimeexportjob.cpp
+++ b/src/library/export/engineprimeexportjob.cpp
@@ -563,7 +563,11 @@ void EnginePrimeExportJob::run() {
             qWarning() << "Failed to export track"
                        << m_pLastLoadedTrack->getId().toString() << ":"
                        << e.what();
-            m_lastErrorMessage = e.what();
+            //: %1 is the artist %2 is the title and %3 is the original error message
+            m_lastErrorMessage = tr("Failed to export track %1 - %2:\n%3")
+                                         .arg(m_pLastLoadedTrack->getArtist(),
+                                                 m_pLastLoadedTrack->getTitle(),
+                                                 e.what());
             emit failed(m_lastErrorMessage);
             return;
         }
diff --git a/src/library/export/libraryexporter.cpp b/src/library/export/libraryexporter.cpp
index 5cefd97dfa..fd46f841cd 100644
--- a/src/library/export/libraryexporter.cpp
+++ b/src/library/export/libraryexporter.cpp
@@ -64,9 +64,7 @@ void LibraryExporter::beginEnginePrimeExport(
             &EnginePrimeExportJob::failed,
             this,
             [](const QString& message) {
-                QMessageBox::critical(nullptr,
-                        tr("Export Failed"),
-                        QString{tr("Export failed: %1")}.arg(message));
+                QMessageBox::critical(nullptr, tr("Export Failed"), message);
             });
 
     // Construct a dialog to monitor job progress and offer cancellation.
diff --git a/src/library/library.cpp b/src/library/library.cpp
index 21f82be564..71bff659c0 100644
--- a/src/library/library.cpp
+++ b/src/library/library.cpp
@@ -552,13 +552,25 @@ void Library::slotLoadLocationToPlayer(const QString& location, const QString& g
     auto trackRef = TrackRef::fromFilePath(location);
     TrackPointer pTrack = m_pTrackCollectionManager->getOrAddTrack(trackRef);
     if (pTrack) {
-        emit loadTrackToPlayer(pTrack, group, play);
+        emit loadTrackToPlayer(pTrack, group,
+#ifdef __STEM__
+                mixxx::kNoStemSelectedIdx,
+#endif
+                play);
     }
 }
 
 void Library::slotLoadTrackToPlayer(
-        TrackPointer pTrack, const QString& group, bool play) {
-    emit loadTrackToPlayer(pTrack, group, play);
+        TrackPointer pTrack, const QString& group,
+#ifdef __STEM__
+        uint stemIdx,
+#endif
+        bool play) {
+    emit loadTrackToPlayer(pTrack, group,
+#ifdef __STEM__
+            stemIdx,
+#endif
+            play);
 }
 
 void Library::slotRefreshLibraryModels() {
diff --git a/src/library/library.h b/src/library/library.h
index e0190084ee..a4a1bd61ee 100644
--- a/src/library/library.h
+++ b/src/library/library.h
@@ -114,7 +114,11 @@ class Library: public QObject {
     void slotShowTrackModel(QAbstractItemModel* model);
     void slotSwitchToView(const QString& view);
     void slotLoadTrack(TrackPointer pTrack);
-    void slotLoadTrackToPlayer(TrackPointer pTrack, const QString& group, bool play);
+    void slotLoadTrackToPlayer(TrackPointer pTrack, const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play);
     void slotLoadLocationToPlayer(const QString& location, const QString& group, bool play);
     void slotRefreshLibraryModels();
     void slotCreatePlaylist();
@@ -127,7 +131,12 @@ class Library: public QObject {
     void showTrackModel(QAbstractItemModel* model, bool restoreState = true);
     void switchToView(const QString& view);
     void loadTrack(TrackPointer pTrack);
-    void loadTrackToPlayer(TrackPointer pTrack, const QString& group, bool play = false);
+    void loadTrackToPlayer(TrackPointer pTrack,
+            const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play = false);
     void restoreSearch(const QString&);
     void search(const QString& text);
     void disableSearch();
diff --git a/src/library/librarycontrol.cpp b/src/library/librarycontrol.cpp
index 3d5e9cac1f..09ecdd4705 100644
--- a/src/library/librarycontrol.cpp
+++ b/src/library/librarycontrol.cpp
@@ -38,6 +38,33 @@ LoadToGroupController::LoadToGroupController(LibraryControl* pParent, const QStr
             this,
             &LoadToGroupController::slotLoadToGroupAndPlay);
 
+#ifdef __STEM__
+    for (int stemIdx = 1; stemIdx <= mixxx::kMaxSupportedStems; stemIdx++) {
+        m_loadSelectedTrackStemAndPlay.emplace_back(
+                std::make_unique<ControlPushButton>(ConfigKey(group,
+                        QStringLiteral("load_selected_track_stem_%1_and_play").arg(stemIdx))));
+        connect(m_loadSelectedTrackStemAndPlay.back().get(),
+                &ControlObject::valueChanged,
+                this,
+                [this, stemIdx](double value) {
+                    if (value > 0) {
+                        emit loadToGroup(m_group, stemIdx, true);
+                    }
+                });
+        m_loadSelectedTrackStem.emplace_back(
+                std::make_unique<ControlPushButton>(ConfigKey(group,
+                        QStringLiteral("load_selected_track_stem_%1").arg(stemIdx))));
+        connect(m_loadSelectedTrackStem.back().get(),
+                &ControlObject::valueChanged,
+                this,
+                [this, stemIdx](double value) {
+                    if (value > 0) {
+                        emit loadToGroup(m_group, stemIdx, false);
+                    }
+                });
+    }
+#endif
+
     connect(this,
             &LoadToGroupController::loadToGroup,
             pParent,
@@ -48,13 +75,21 @@ LoadToGroupController::~LoadToGroupController() = default;
 
 void LoadToGroupController::slotLoadToGroup(double v) {
     if (v > 0) {
-        emit loadToGroup(m_group, false);
+        emit loadToGroup(m_group,
+#ifdef __STEM__
+                mixxx::kNoStemSelectedIdx,
+#endif
+                false);
     }
 }
 
 void LoadToGroupController::slotLoadToGroupAndPlay(double v) {
     if (v > 0) {
-        emit loadToGroup(m_group, true);
+        emit loadToGroup(m_group,
+#ifdef __STEM__
+                mixxx::kNoStemSelectedIdx,
+#endif
+                true);
     }
 }
 
@@ -221,7 +256,7 @@ LibraryControl::LibraryControl(Library* pLibrary)
     // This CO is never actually set or read so the value just needs to be not 0
     m_pRefocusPrevWidgetCO = std::make_unique<ControlPushButton>(
             ConfigKey("[Library]", "refocus_prev_widget"));
-    m_pRefocusPrevWidgetCO->setButtonMode(ControlPushButton::TRIGGER);
+    m_pRefocusPrevWidgetCO->setButtonMode(mixxx::control::ButtonMode::Trigger);
 #ifdef MIXXX_USE_QML
     if (!CmdlineArgs::Instance().isQml())
 #endif
@@ -285,7 +320,7 @@ LibraryControl::LibraryControl(Library* pLibrary)
     // Sort controls
     m_pSortColumn = std::make_unique<ControlEncoder>(ConfigKey("[Library]", "sort_column"));
     m_pSortOrder = std::make_unique<ControlPushButton>(ConfigKey("[Library]", "sort_order"));
-    m_pSortOrder->setButtonMode(ControlPushButton::TOGGLE);
+    m_pSortOrder->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pSortColumnToggle = std::make_unique<ControlEncoder>(ConfigKey("[Library]", "sort_column_toggle"), false);
     m_pSortFocusedColumn = std::make_unique<ControlPushButton>(
             ConfigKey("[Library]", "sort_focused_column"));
@@ -600,14 +635,22 @@ void LibraryControl::slotUpdateTrackMenuControl(bool visible) {
     m_pShowTrackMenu->setAndConfirm(visible ? 1.0 : 0.0);
 }
 
-void LibraryControl::slotLoadSelectedTrackToGroup(const QString& group, bool play) {
+void LibraryControl::slotLoadSelectedTrackToGroup(const QString& group,
+#ifdef __STEM__
+        uint stemIdx,
+#endif
+        bool play) {
     if (!m_pLibraryWidget) {
         return;
     }
 
     WTrackTableView* pTrackTableView = m_pLibraryWidget->getCurrentTrackTableView();
     if (pTrackTableView) {
-        pTrackTableView->loadSelectedTrackToGroup(group, play);
+        pTrackTableView->loadSelectedTrackToGroup(group,
+#ifdef __STEM__
+                stemIdx,
+#endif
+                play);
     }
 }
 
diff --git a/src/library/librarycontrol.h b/src/library/librarycontrol.h
index 65e21013ea..d0557269a8 100644
--- a/src/library/librarycontrol.h
+++ b/src/library/librarycontrol.h
@@ -23,7 +23,11 @@ class LoadToGroupController : public QObject {
     virtual ~LoadToGroupController();
 
   signals:
-    void loadToGroup(const QString& group, bool);
+    void loadToGroup(const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool);
 
   public slots:
     void slotLoadToGroup(double v);
@@ -33,6 +37,11 @@ class LoadToGroupController : public QObject {
     const QString m_group;
     std::unique_ptr<ControlObject> m_pLoadControl;
     std::unique_ptr<ControlObject> m_pLoadAndPlayControl;
+
+#ifdef __STEM__
+    std::vector<std::unique_ptr<ControlPushButton>> m_loadSelectedTrackStemAndPlay;
+    std::vector<std::unique_ptr<ControlPushButton>> m_loadSelectedTrackStem;
+#endif
 };
 
 class LibraryControl : public QObject {
@@ -54,7 +63,11 @@ class LibraryControl : public QObject {
 
   public slots:
     // Deprecated navigation slots
-    void slotLoadSelectedTrackToGroup(const QString& group, bool play);
+    void slotLoadSelectedTrackToGroup(const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play);
     void slotUpdateTrackMenuControl(bool visible);
 
   private slots:
diff --git a/src/library/libraryfeature.h b/src/library/libraryfeature.h
index 61972192dc..2ceaffbe61 100644
--- a/src/library/libraryfeature.h
+++ b/src/library/libraryfeature.h
@@ -135,7 +135,12 @@ class LibraryFeature : public QObject {
     void showTrackModel(QAbstractItemModel* model, bool restoreState = true);
     void switchToView(const QString& view);
     void loadTrack(TrackPointer pTrack);
-    void loadTrackToPlayer(TrackPointer pTrack, const QString& group, bool play = false);
+    void loadTrackToPlayer(TrackPointer pTrack,
+            const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play = false);
     /// saves the scroll, selection and current state of the library model
     void saveModelState();
     /// restores the scroll, selection and current state of the library model
diff --git a/src/library/recording/dlgrecording.h b/src/library/recording/dlgrecording.h
index 8d71505631..8cd3d74102 100644
--- a/src/library/recording/dlgrecording.h
+++ b/src/library/recording/dlgrecording.h
@@ -37,7 +37,11 @@ class DlgRecording : public QWidget, public Ui::DlgRecording, public virtual Lib
 
   signals:
     void loadTrack(TrackPointer tio);
-    void loadTrackToPlayer(TrackPointer tio, const QString& group, bool play);
+    void loadTrackToPlayer(TrackPointer tio, const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play);
     void restoreSearch(const QString& search);
     void restoreModelState();
 
diff --git a/src/library/sidebarmodel.cpp b/src/library/sidebarmodel.cpp
index 49a13dd9bc..3914c7f468 100644
--- a/src/library/sidebarmodel.cpp
+++ b/src/library/sidebarmodel.cpp
@@ -405,7 +405,8 @@ void SidebarModel::deleteItem(const QModelIndex& index) {
     }
 
     if (index.internalPointer() == this) {
-        // can't delete root features
+        // Used only to call AutoDJFeature::clear()
+        m_sFeatures[index.row()]->clear();
         return;
     } else {
         TreeItem* pTreeItem = static_cast<TreeItem*>(index.internalPointer());
diff --git a/src/library/tabledelegates/bpmdelegate.cpp b/src/library/tabledelegates/bpmdelegate.cpp
index 6fd62efce2..be287f85e4 100644
--- a/src/library/tabledelegates/bpmdelegate.cpp
+++ b/src/library/tabledelegates/bpmdelegate.cpp
@@ -1,11 +1,8 @@
 #include "library/tabledelegates/bpmdelegate.h"
 
-#include <QCheckBox>
 #include <QDoubleSpinBox>
 #include <QItemEditorCreatorBase>
 #include <QItemEditorFactory>
-#include <QPainter>
-#include <QTableView>
 
 #include "moc_bpmdelegate.cpp"
 
@@ -34,14 +31,7 @@ class BpmEditorCreator : public QItemEditorCreatorBase {
 };
 
 BPMDelegate::BPMDelegate(QTableView* pTableView)
-        : TableItemDelegate(pTableView),
-          m_pCheckBox(new QCheckBox(m_pTableView)) {
-    m_pCheckBox->setObjectName("LibraryBPMButton");
-    // NOTE(rryan): Without ensurePolished the first render of the QTableView
-    // shows the checkbox unstyled. Not sure why -- but this fixes it.
-    m_pCheckBox->ensurePolished();
-    m_pCheckBox->hide();
-
+        : CheckboxDelegate(pTableView, QStringLiteral("LibraryBPMButton")) {
     // Register a custom QItemEditorFactory to override the default
     // QDoubleSpinBox editor.
     m_pFactory = new QItemEditorFactory();
@@ -52,72 +42,3 @@ BPMDelegate::BPMDelegate(QTableView* pTableView)
 #endif
     setItemEditorFactory(m_pFactory);
 }
-
-BPMDelegate::~BPMDelegate() {
-    delete m_pFactory;
-}
-
-void BPMDelegate::paintItem(QPainter* painter,const QStyleOptionViewItem &option,
-                        const QModelIndex& index) const {
-    // NOTE(rryan): Qt has a built-in limitation that we cannot style multiple
-    // CheckState indicators in the same QAbstractItemView. The CSS rule
-    // QTableView::indicator:checked applies to all columns with a
-    // CheckState. This is a big pain if we want to use CheckState roles on two
-    // columns (i.e. the played column and the BPM column) with different
-    // styling. We typically want a lock icon for the BPM check-state and a
-    // check-box for the times-played column and may want more in the future.
-    //
-    // This workaround creates a hidden QComboBox named LibraryBPMButton. We use
-    // the parent QTableView's QStyle with the hidden QComboBox as the source of
-    // style rules to draw a CE_ItemViewItem.
-    //
-    // Here's how you would typically style the LibraryBPMButton:
-    // #LibraryBPMButton::indicator:checked {
-    //   image: url(:/images/library/ic_library_locked.svg);
-    // }
-    // #LibraryBPMButton::indicator:unchecked {
-    //  image: url(:/images/library/ic_library_unlocked.svg);
-    // }
-
-    // Actually QAbstractTableModel::data(index, BackgroundRole) provides the
-    // correct custom background color (track color).
-    // Though, since Qt6 the above style rules would not apply for some reason,
-    // (see bug #11630) which can be fixed by also setting
-    // #LibraryBPMButton::item { border: 0px;}
-    // This however enables some default styles and clears the custom background
-    // color (track color), see bug #12355 ¯\_(ツ)_/¯ Qt is fun!
-    // Fix that by setting the bg color explicitly here.
-    paintItemBackground(painter, option, index);
-
-    QStyleOptionViewItem opt = option;
-    initStyleOption(&opt, index);
-
-    // The checkbox uses the QTableView's qss style, therefore it's not picking
-    // up the 'missing' or 'played' text color via ForegroundRole from
-    // BaseTrackTableModel::data().
-    // Enforce it with an explicit stylesheet. Note: the stylesheet persists so
-    // we need to reset it to normal/highlighted.
-    QColor textColor;
-    if (option.state & QStyle::State_Selected) {
-        textColor = option.palette.color(QPalette::Normal, QPalette::HighlightedText);
-    } else {
-        auto colorData = index.data(Qt::ForegroundRole);
-        if (colorData.canConvert<QColor>()) {
-            textColor = colorData.value<QColor>();
-        } else {
-            textColor = option.palette.color(QPalette::Normal, QPalette::Text);
-        }
-    }
-
-    if (textColor.isValid() && textColor != m_cachedTextColor) {
-        m_cachedTextColor = textColor;
-        m_pCheckBox->setStyleSheet(QStringLiteral(
-                "#LibraryBPMButton::item { color: %1; }")
-                                           .arg(textColor.name(QColor::HexRgb)));
-    }
-
-    QStyle* style = m_pTableView->style();
-    if (style != nullptr) {
-        style->drawControl(QStyle::CE_ItemViewItem, &opt, painter, m_pCheckBox);
-    }
-}
diff --git a/src/library/tabledelegates/bpmdelegate.h b/src/library/tabledelegates/bpmdelegate.h
index fac096644a..f70eeb7a8c 100644
--- a/src/library/tabledelegates/bpmdelegate.h
+++ b/src/library/tabledelegates/bpmdelegate.h
@@ -1,21 +1,12 @@
 #pragma once
 
-#include "library/tabledelegates/tableitemdelegate.h"
+#include "library/tabledelegates/checkboxdelegate.h"
 
-class QCheckBox;
-
-class BPMDelegate : public TableItemDelegate {
+class BPMDelegate : public CheckboxDelegate {
     Q_OBJECT
   public:
     explicit BPMDelegate(QTableView* pTableView);
-    virtual ~BPMDelegate();
-
-    void paintItem(QPainter* painter,
-            const QStyleOptionViewItem& option,
-            const QModelIndex& index) const override;
 
   private:
-    QCheckBox* m_pCheckBox;
     QItemEditorFactory* m_pFactory;
-    mutable QColor m_cachedTextColor;
 };
diff --git a/src/library/tabledelegates/checkboxdelegate.cpp b/src/library/tabledelegates/checkboxdelegate.cpp
new file mode 100644
index 0000000000..ca6889321f
--- /dev/null
+++ b/src/library/tabledelegates/checkboxdelegate.cpp
@@ -0,0 +1,87 @@
+#include "library/tabledelegates/checkboxdelegate.h"
+
+#include <QCheckBox>
+#include <QPainter>
+#include <QTableView>
+
+#include "moc_checkboxdelegate.cpp"
+
+CheckboxDelegate::CheckboxDelegate(QTableView* pTableView, const QString& checkboxName)
+        : TableItemDelegate(pTableView),
+          m_pCheckBox(new QCheckBox(m_pTableView)),
+          m_checkboxName(checkboxName) {
+    // Note that object names set here are not picked up by /tools/qsscheck.py
+    // and need to be added there manually
+    m_pCheckBox->setObjectName(checkboxName);
+    // NOTE(rryan): Without ensurePolished the first render of the QTableView
+    // shows the checkbox unstyled. Not sure why -- but this fixes it.
+    m_pCheckBox->ensurePolished();
+    m_pCheckBox->hide();
+}
+
+void CheckboxDelegate::paintItem(QPainter* painter,
+        const QStyleOptionViewItem& option,
+        const QModelIndex& index) const {
+    // NOTE(rryan): Qt has a built-in limitation that we cannot style multiple
+    // CheckState indicators in the same QAbstractItemView. The CSS rule
+    // QTableView::indicator:checked applies to all columns with a
+    // CheckState. This is a big pain if we want to use CheckState roles on two
+    // columns (i.e. the played column and the BPM column) with different
+    // styling. We typically want a lock icon for the BPM check-state and a
+    // check-box for the times-played column and may want more in the future.
+    //
+    // This workaround creates a hidden QComboBox named LibraryBPMButton. We use
+    // the parent QTableView's QStyle with the hidden QComboBox as the source of
+    // style rules to draw a CE_ItemViewItem.
+    //
+    // Here's how you would typically style the LibraryBPMButton:
+    // #LibraryBPMButton::indicator:checked {
+    //   image: url(:/images/library/ic_library_locked.svg);
+    // }
+    // #LibraryBPMButton::indicator:unchecked {
+    //  image: url(:/images/library/ic_library_unlocked.svg);
+    // }
+
+    // Actually QAbstractTableModel::data(index, BackgroundRole) provides the
+    // correct custom background color (track color).
+    // Though, since Qt6 the above style rules would not apply for some reason,
+    // (see bug #11630) which can be fixed by also setting
+    // #LibraryBPMButton::item { border: 0px;}
+    // This however enables some default styles and clears the custom background
+    // color (track color), see bug #12355 ¯\_(ツ)_/¯ Qt is fun!
+    // Fix that by setting the bg color explicitly here.
+    paintItemBackground(painter, option, index);
+
+    QStyleOptionViewItem opt = option;
+    initStyleOption(&opt, index);
+
+    // The checkbox uses the QTableView's qss style, therefore it's not picking
+    // up the 'missing' or 'played' text color via ForegroundRole from
+    // BaseTrackTableModel::data().
+    // Enforce it with an explicit stylesheet. Note: the stylesheet persists so
+    // we need to reset it to normal/highlighted.
+    QColor textColor;
+    if (option.state & QStyle::State_Selected) {
+        textColor = option.palette.color(QPalette::Normal, QPalette::HighlightedText);
+    } else {
+        auto colorData = index.data(Qt::ForegroundRole);
+        if (colorData.canConvert<QColor>()) {
+            textColor = colorData.value<QColor>();
+        } else {
+            textColor = option.palette.color(QPalette::Normal, QPalette::Text);
+        }
+    }
+
+    if (textColor.isValid() && textColor != m_cachedTextColor) {
+        m_cachedTextColor = textColor;
+        m_pCheckBox->setStyleSheet(QStringLiteral(
+                "#%1::item { color: %2; }")
+                                           .arg(m_checkboxName,
+                                                   textColor.name(QColor::HexRgb)));
+    }
+
+    QStyle* style = m_pTableView->style();
+    if (style != nullptr) {
+        style->drawControl(QStyle::CE_ItemViewItem, &opt, painter, m_pCheckBox);
+    }
+}
diff --git a/src/library/tabledelegates/playcountdelegate.h b/src/library/tabledelegates/checkboxdelegate.h
similarity index 55%
rename from src/library/tabledelegates/playcountdelegate.h
rename to src/library/tabledelegates/checkboxdelegate.h
index ce791f733c..9796bc1cab 100644
--- a/src/library/tabledelegates/playcountdelegate.h
+++ b/src/library/tabledelegates/checkboxdelegate.h
@@ -1,19 +1,21 @@
 #pragma once
 
 #include "library/tabledelegates/tableitemdelegate.h"
+#include "util/parented_ptr.h"
 
 class QCheckBox;
 
-class PlayCountDelegate : public TableItemDelegate {
+class CheckboxDelegate : public TableItemDelegate {
     Q_OBJECT
   public:
-    explicit PlayCountDelegate(QTableView* pTableView);
+    explicit CheckboxDelegate(QTableView* pTableView, const QString& checkboxName);
 
     void paintItem(QPainter* painter,
             const QStyleOptionViewItem& option,
             const QModelIndex& index) const override;
 
   private:
-    QTableView* m_pTableView;
     QCheckBox* m_pCheckBox;
+    const QString m_checkboxName;
+    mutable QColor m_cachedTextColor;
 };
diff --git a/src/library/tabledelegates/keydelegate.cpp b/src/library/tabledelegates/keydelegate.cpp
index 52e6c4ed6a..1f370ef5a3 100644
--- a/src/library/tabledelegates/keydelegate.cpp
+++ b/src/library/tabledelegates/keydelegate.cpp
@@ -5,7 +5,6 @@
 #include <QTableView>
 
 #include "moc_keydelegate.cpp"
-#include "track/keyutils.h"
 
 void KeyDelegate::paintItem(
         QPainter* painter,
@@ -13,48 +12,42 @@ void KeyDelegate::paintItem(
         const QModelIndex& index) const {
     paintItemBackground(painter, option, index);
 
-    mixxx::track::io::key::ChromaticKey key =
-            index.data().value<mixxx::track::io::key::ChromaticKey>();
-    if (key != mixxx::track::io::key::INVALID) {
-        // Display the key colors if enabled
-        bool keyColorsEnabled = index.data(Qt::UserRole).value<bool>();
-        if (keyColorsEnabled) {
-            const QColor keyColor = KeyUtils::keyToColor(key);
-            if (keyColor.isValid()) {
-                // Draw the colored rectangle next to the key label
-                painter->fillRect(
-                        option.rect.x(),
-                        option.rect.y() + 2,
-                        4, // width
-                        option.rect.height() - 4,
-                        keyColor);
-            }
-        }
-
-        // Display the key text with the user-provided notation
-        int rectWidth = keyColorsEnabled ? 8 : 0; //  4px width + 4px right padding
-        const QString keyText = KeyUtils::keyToString(key);
-        QString elidedText = option.fontMetrics.elidedText(
-                keyText,
-                Qt::ElideRight,
-                columnWidth(index) - rectWidth);
-
-        if (option.state & QStyle::State_Selected) {
-            // This uses selection-color from stylesheet for the text pen:
-            // #LibraryContainer QTableView {
-            //   selection-color: #fff;
-            // }
-            painter->setPen(QPen(option.palette.highlightedText().color()));
-        }
-
-        painter->drawText(option.rect.x() + rectWidth,
-                option.rect.y(),
-                option.rect.width() - rectWidth,
-                option.rect.height(),
-                Qt::AlignVCenter,
-                elidedText);
+    const QString keyText = index.data().value<QString>();
+    const QColor keyColor = index.data(Qt::DecorationRole).value<QColor>();
+    int rectWidth = 0;
+
+    if (keyColor.isValid()) {
+        // Draw the colored rectangle next to the key label
+        rectWidth = 8; //  4px width + 4px right padding
+        painter->fillRect(
+                option.rect.x(),
+                option.rect.y() + 2,
+                4, // width
+                option.rect.height() - 4,
+                keyColor);
     }
 
+    // Display the key text with the user-provided notation
+    QString elidedText = option.fontMetrics.elidedText(
+            keyText,
+            Qt::ElideRight,
+            columnWidth(index) - rectWidth);
+
+    if (option.state & QStyle::State_Selected) {
+        // This uses selection-color from stylesheet for the text pen:
+        // #LibraryContainer QTableView {
+        //   selection-color: #fff;
+        // }
+        painter->setPen(QPen(option.palette.highlightedText().color()));
+    }
+
+    painter->drawText(option.rect.x() + rectWidth,
+            option.rect.y(),
+            option.rect.width() - rectWidth,
+            option.rect.height(),
+            Qt::AlignVCenter,
+            elidedText);
+
     // Draw a border if the key cell has focus
     if (option.state & QStyle::State_HasFocus) {
         drawBorder(painter, m_focusBorderColor, option.rect);
diff --git a/src/library/tabledelegates/playcountdelegate.cpp b/src/library/tabledelegates/playcountdelegate.cpp
deleted file mode 100644
index 53bac452dc..0000000000
--- a/src/library/tabledelegates/playcountdelegate.cpp
+++ /dev/null
@@ -1,36 +0,0 @@
-#include "library/tabledelegates/playcountdelegate.h"
-
-#include <QCheckBox>
-#include <QPainter>
-#include <QTableView>
-
-#include "moc_playcountdelegate.cpp"
-
-PlayCountDelegate::PlayCountDelegate(QTableView* pTableView)
-        : TableItemDelegate(pTableView),
-          m_pTableView(pTableView),
-          m_pCheckBox(new QCheckBox(m_pTableView)) {
-    m_pCheckBox->setObjectName("LibraryPlayedCheckbox");
-    // NOTE(rryan): Without ensurePolished the first render of the QTableView
-    // shows the checkbox unstyled. Not sure why -- but this fixes it.
-    m_pCheckBox->ensurePolished();
-    m_pCheckBox->hide();
-}
-
-void PlayCountDelegate::paintItem(QPainter* painter,
-        const QStyleOptionViewItem& option,
-        const QModelIndex& index) const {
-    // NOTE(ronso0): For details why we need checkbox delegates, how to style
-    // them and why we need paintItemBackground() here, see bpmdelegate.cpp
-    paintItemBackground(painter, option, index);
-
-    QStyleOptionViewItem opt = option;
-    initStyleOption(&opt, index);
-
-    if (m_pTableView != nullptr) {
-        QStyle* style = m_pTableView->style();
-        if (style != nullptr) {
-            style->drawControl(QStyle::CE_ItemViewItem, &opt, painter, m_pCheckBox);
-        }
-    }
-}
diff --git a/src/library/tabledelegates/previewbuttondelegate.cpp b/src/library/tabledelegates/previewbuttondelegate.cpp
index 87c897ec95..1c8a2c1d91 100644
--- a/src/library/tabledelegates/previewbuttondelegate.cpp
+++ b/src/library/tabledelegates/previewbuttondelegate.cpp
@@ -220,7 +220,11 @@ void PreviewButtonDelegate::buttonClicked() {
     TrackPointer pTrack = pTrackModel->getTrack(m_currentEditedCellIndex);
     if (pTrack && pTrack != pOldTrack) {
         // Load to preview deck and start playing
-        emit loadTrackToPlayer(pTrack, kPreviewDeckGroup, true);
+        emit loadTrackToPlayer(pTrack, kPreviewDeckGroup,
+#ifdef __STEM__
+                mixxx::kNoStemSelectedIdx,
+#endif
+                true);
         startedPlaying = true;
     } else if (pTrack == pOldTrack && !isPreviewDeckPlaying()) {
         // Since the Preview deck might be hidden, starting at the main cue
diff --git a/src/library/tabledelegates/previewbuttondelegate.h b/src/library/tabledelegates/previewbuttondelegate.h
index a42b206bc1..7f50caddb5 100644
--- a/src/library/tabledelegates/previewbuttondelegate.h
+++ b/src/library/tabledelegates/previewbuttondelegate.h
@@ -54,7 +54,12 @@ class PreviewButtonDelegate : public TableItemDelegate {
             const QModelIndex& index) const override;
 
   signals:
-    void loadTrackToPlayer(const TrackPointer& pTrack, const QString& group, bool play);
+    void loadTrackToPlayer(const TrackPointer& pTrack,
+            const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play);
     void buttonSetChecked(bool);
 
   public slots:
diff --git a/src/main.cpp b/src/main.cpp
index 60cb824a7e..9859ed2f3f 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -28,6 +28,15 @@
 #include "util/logging.h"
 #include "util/sandbox.h"
 #include "util/versionstore.h"
+/// Eve OSC
+#include "ip/UdpSocket.h"
+#include "osc/OscOutboundPacketStream.h"
+
+#define ADDRESS "192.168.0.125"
+#define PORT 9000
+#define OUTPUT_BUFFER_SIZE 1024
+/// Eve OSC
+
 
 namespace {
 
@@ -65,9 +74,9 @@ int runMixxx(MixxxApplication* pApp, const CmdlineArgs& args) {
         // This scope ensures that `MixxxMainWindow` is destroyed *before*
         // CoreServices is shut down. Otherwise a debug assertion complaining about
         // leaked COs may be triggered.
-        MixxxMainWindow mainWindow(pCoreServices);
+        MixxxMainWindow* pMainWindow = MixxxMainWindow::createInstance(pCoreServices);
         pApp->processEvents();
-        pApp->installEventFilter(&mainWindow);
+        pApp->installEventFilter(pMainWindow);
 
 #if defined(__WINDOWS__)
         WindowsEventHandler winEventHandler;
@@ -76,7 +85,7 @@ int runMixxx(MixxxApplication* pApp, const CmdlineArgs& args) {
 
         QObject::connect(pCoreServices.get(),
                 &mixxx::CoreServices::initializationProgressUpdate,
-                &mainWindow,
+                pMainWindow,
                 &MixxxMainWindow::initializationProgressUpdate);
 
         // The size of cached pixmaps increases with the square of devicePixelRatio
@@ -89,9 +98,9 @@ int runMixxx(MixxxApplication* pApp, const CmdlineArgs& args) {
 #ifdef MIXXX_USE_QOPENGL
         // Will call initialize when the initial wglwidget's
         // qopenglwindow has been exposed
-        mainWindow.initializeQOpenGL();
+        pMainWindow->initializeQOpenGL();
 #else
-        mainWindow.initialize();
+        pMainWindow->initialize();
 #endif
 
         pCoreServices->getControllerManager()->setUpDevices();
@@ -102,15 +111,35 @@ int runMixxx(MixxxApplication* pApp, const CmdlineArgs& args) {
             exitCode = kFatalErrorOnStartupExitCode;
         } else {
             qDebug() << "Displaying main window";
-            mainWindow.show();
+            pMainWindow->show();
 
             qDebug() << "Running Mixxx";
             exitCode = pApp->exec();
         }
+        MixxxMainWindow::destroy();
     }
     return exitCode;
 }
 
+/// Eve OSC
+// int eveOSC(int argc, char* argv[])
+void eveOSC() {
+    //  int eveosc(int argc, char* argv[]) {
+    //  int eveosc(int argc, char* argv[]) {
+    // (void)argc; // suppress unused parameter warnings
+    // (void)argv; // suppress unused parameter warnings
+
+    UdpTransmitSocket transmitSocket(IpEndpointName(ADDRESS, PORT));
+    char buffer[OUTPUT_BUFFER_SIZE];
+    osc::OutboundPacketStream p(buffer, OUTPUT_BUFFER_SIZE);
+    p << osc::BeginBundleImmediate << osc::BeginMessage("/test1") << true << 23 << (float)3.1415 << "hello" << osc::EndMessage << osc::BeginMessage("/test2") << true << 24 << (float)10.8 << "world" << osc::EndMessage << osc::EndBundle;
+    transmitSocket.Send(p.Data(), p.Size());
+}
+/// Eve OSC
+
+
+
+
 void adjustScaleFactor(CmdlineArgs* pArgs) {
     if (qEnvironmentVariableIsSet(kScaleFactorEnvVar)) {
         bool ok;
diff --git a/src/mixer/basetrackplayer.cpp b/src/mixer/basetrackplayer.cpp
index e6b9d87a74..be951550b3 100644
--- a/src/mixer/basetrackplayer.cpp
+++ b/src/mixer/basetrackplayer.cpp
@@ -18,13 +18,25 @@
 #include "util/sandbox.h"
 #include "vinylcontrol/defs_vinylcontrol.h"
 #include "waveform/renderers/waveformwidgetrenderer.h"
+/// Eve OSC
+#include "ip/UdpSocket.h"
+#include "osc/OscOutboundPacketStream.h"
+#include "osc/OscTypes.h"
+
+#define ADDRESS "192.168.0.125"
+#define PORT 9000
+#define OUTPUT_BUFFER_SIZE 1024
+/// Eve OSC
 
 namespace {
 
 constexpr double kNoTrackColor = -1;
 constexpr double kShiftCuesOffsetMillis = 10;
 constexpr double kShiftCuesOffsetSmallMillis = 1;
+#ifdef __STEM__
 constexpr int kMaxSupportedStems = 4;
+#endif
+
 const QString kEffectGroupFormat = QStringLiteral("[EqualizerRack1_%1_Effect1]");
 
 inline double trackColorToDouble(mixxx::RgbColor::optional_t color) {
@@ -285,9 +297,9 @@ BaseTrackPlayerImpl::BaseTrackPlayerImpl(
     }
 
 #ifdef __STEM__
-    m_pStemColors.reserve(kMaxSupportedStems);
+    m_pStemColors.reserve(mixxx::kMaxSupportedStems);
     QString group = getGroup();
-    for (int stemIdx = 1; stemIdx <= kMaxSupportedStems; stemIdx++) {
+    for (int stemIdx = 1; stemIdx <= mixxx::kMaxSupportedStems; stemIdx++) {
         QString stemGroup = QStringLiteral("%1Stem%2]")
                                     .arg(group.left(group.size() - 1),
                                             QString::number(stemIdx));
@@ -416,7 +428,11 @@ void BaseTrackPlayerImpl::slotEjectTrack(double v) {
     if (elapsed < mixxx::Duration::fromMillis(kUnreplaceDelay)) {
         TrackPointer lastEjected = m_pPlayerManager->getSecondLastEjectedTrack();
         if (lastEjected) {
-            slotLoadTrack(lastEjected, false);
+            slotLoadTrack(lastEjected,
+#ifdef __STEM__
+                    mixxx::kNoStemSelectedIdx,
+#endif
+                    false);
         }
         return;
     }
@@ -425,7 +441,11 @@ void BaseTrackPlayerImpl::slotEjectTrack(double v) {
     if (!m_pLoadedTrack) {
         TrackPointer lastEjected = m_pPlayerManager->getLastEjectedTrack();
         if (lastEjected) {
-            slotLoadTrack(lastEjected, false);
+            slotLoadTrack(lastEjected,
+#ifdef __STEM__
+                    mixxx::kNoStemSelectedIdx,
+#endif
+                    false);
         }
         return;
     }
@@ -539,7 +559,11 @@ void BaseTrackPlayerImpl::disconnectLoadedTrack() {
     disconnect(m_pLoadedTrack.get(), nullptr, m_pKey.get(), nullptr);
 }
 
-void BaseTrackPlayerImpl::slotLoadTrack(TrackPointer pNewTrack, bool bPlay) {
+void BaseTrackPlayerImpl::slotLoadTrack(TrackPointer pNewTrack,
+#ifdef __STEM__
+        uint stemIdx,
+#endif
+        bool bPlay) {
     //qDebug() << "BaseTrackPlayerImpl::slotLoadTrack" << getGroup() << pNewTrack.get();
     // Before loading the track, ensure we have access. This uses lazy
     // evaluation to make sure track isn't NULL before we dereference it.
@@ -562,7 +586,17 @@ void BaseTrackPlayerImpl::slotLoadTrack(TrackPointer pNewTrack, bool bPlay) {
 
     // Request a new track from EngineBuffer
     EngineBuffer* pEngineBuffer = m_pChannel->getEngineBuffer();
+#ifdef __STEM__
+    pEngineBuffer->loadTrack(pNewTrack,
+            stemIdx,
+            bPlay,
+            m_pChannelToCloneFrom);
+
+    // Select a specific stem if requested
+    emit selectedStem(stemIdx);
+#else
     pEngineBuffer->loadTrack(pNewTrack, bPlay, m_pChannelToCloneFrom);
+#endif
 }
 
 void BaseTrackPlayerImpl::slotLoadFailed(TrackPointer pTrack, const QString& reason) {
@@ -694,7 +728,7 @@ void BaseTrackPlayerImpl::slotTrackLoaded(TrackPointer pNewTrack,
 #ifdef __STEM__
         if (m_pStemColors.size()) {
             const auto& stemInfo = m_pLoadedTrack->getStemInfo();
-            DEBUG_ASSERT(stemInfo.size() <= kMaxSupportedStems);
+            DEBUG_ASSERT(stemInfo.size() <= mixxx::kMaxSupportedStems);
             int stemIdx = 0;
             for (const auto& stemColorCo : m_pStemColors) {
                 auto color = kNoTrackColor;
@@ -719,11 +753,65 @@ void BaseTrackPlayerImpl::slotTrackLoaded(TrackPointer pNewTrack,
 
     m_pChannelToCloneFrom = nullptr;
 
-    // Update the PlayerInfo class that is used in EngineBroadcast to replace
+        // Update the PlayerInfo class that is used in EngineBroadcast to replace
     // the metadata of a stream
     PlayerInfo::instance().setTrackInfo(getGroup(), m_pLoadedTrack);
+    QString trackInfoArtist = " ";
+    QString trackInfoTitle = " ";
+    QString DeckStatusTxtLine2 = " ";
+    QString DeckStatusTxtLine3 = " ";
+    QString DeckStatusTxtLine4 = " ";
+    QTime tempStatusTime = QTime::currentTime();
+    QString DeckStatusTime = tempStatusTime.toString("hh:mm:ss");
+
+    if (pNewTrack) {
+        //    QString trackInfo = pNewTrack->getInfo();
+        trackInfoArtist = pNewTrack->getArtist();
+        trackInfoTitle = pNewTrack->getTitle();
+        trackInfoArtist.replace("\"", "''");
+        trackInfoTitle.replace("\"", "''");
+        DeckStatusTxtLine2 = "Artist : \"" + trackInfoArtist + "\",";
+        DeckStatusTxtLine3 = "Title : \"" + trackInfoTitle + "\",";
+        DeckStatusTxtLine4 = "Time : \"" + DeckStatusTime + "\",";
+
+    } else {
+        DeckStatusTxtLine2 = "Artist : \" \",";
+        DeckStatusTxtLine3 = "Title : \" \",";
+        DeckStatusTxtLine4 = "Time : \"" + DeckStatusTime + "\",";
+    }
+    QString trackInfoDeck = getGroup();
+    trackInfoDeck.replace("[Channel", "");
+    trackInfoDeck.replace("]", "");
+    QString DeckStatusFilePath = m_pConfig->getSettingsPath();
+    DeckStatusFilePath.replace("Roaming", "Local");
+    DeckStatusFilePath.replace("\\", "/");
+    QString DeckStatusFileLocation = DeckStatusFilePath + "/controllers/Status" + getGroup() + ".js";
+    //  Different file for each Deck / Sampler
+    QString DeckStatusTxtLine1 = "var TrackDeck" + trackInfoDeck + " = { ";
+    QString DeckStatusTxtLine5 = "};";
+    QFile DeckStatusFile(DeckStatusFileLocation);
+    DeckStatusFile.remove();
+    DeckStatusFile.open(QIODevice::ReadWrite | QIODevice::Append);
+    // DeckStatusFile.open(QIODevice::ReadWrite | QIODevice::Append);
+    QTextStream DeckStatusTxt(&DeckStatusFile);
+    DeckStatusTxt << DeckStatusTxtLine1 << "\n";
+    DeckStatusTxt << DeckStatusTxtLine2 << "\n";
+    DeckStatusTxt << DeckStatusTxtLine3 << "\n";
+    DeckStatusTxt << DeckStatusTxtLine4 << "\n";
+    DeckStatusTxt << DeckStatusTxtLine5 << "\n";
+    DeckStatusFile.close();
+//    main::eveOSC();
+      UdpTransmitSocket transmitSocket(IpEndpointName(ADDRESS, PORT));
+//    UdpTransmitSocket transmitSocket(IpEndpointName("192.168.0.125", "9000"));
+    QChar oscbuffer[OUTPUT_BUFFER_SIZE];
+      osc::OutboundPacketStream p(oscbuffer, OUTPUT_BUFFER_SIZE);
+    p << osc::BeginBundleImmediate << osc::BeginMessage("/test1") << true << 23 << (float)3.1415 << "hello" << osc::EndMessage << osc::BeginMessage("/test2") << true << 24 << (float)10.8 << "world" << osc::EndMessage << osc::EndBundle;
+    transmitSocket.Send(p.Data(), p.Size());
+
 }
 
+
+
 TrackPointer BaseTrackPlayerImpl::getLoadedTrack() const {
     return m_pLoadedTrack;
 }
@@ -773,7 +861,11 @@ void BaseTrackPlayerImpl::slotCloneChannel(EngineChannel* pChannel) {
 
     m_pChannelToCloneFrom = pChannel;
     bool play = ControlObject::toBool(ConfigKey(m_pChannelToCloneFrom->getGroup(), "play"));
-    slotLoadTrack(pTrack, play);
+    slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            play);
 }
 
 void BaseTrackPlayerImpl::slotLoadTrackFromDeck(double d) {
@@ -797,7 +889,11 @@ void BaseTrackPlayerImpl::loadTrackFromGroup(const QString& group) {
         return;
     }
 
-    slotLoadTrack(pTrack, false);
+    slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
 }
 
 bool BaseTrackPlayerImpl::isTrackMenuControlAvailable() {
diff --git a/src/mixer/basetrackplayer.h b/src/mixer/basetrackplayer.h
index 048455edfe..8c6b3812e3 100644
--- a/src/mixer/basetrackplayer.h
+++ b/src/mixer/basetrackplayer.h
@@ -45,7 +45,11 @@ class BaseTrackPlayer : public BasePlayer {
     };
 
   public slots:
-    virtual void slotLoadTrack(TrackPointer pTrack, bool bPlay = false) = 0;
+    virtual void slotLoadTrack(TrackPointer pTrack,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool bPlay = false) = 0;
     virtual void slotCloneFromGroup(const QString& group) = 0;
     virtual void slotCloneDeck() = 0;
     virtual void slotEjectTrack(double) = 0;
@@ -56,6 +60,9 @@ class BaseTrackPlayer : public BasePlayer {
     void newTrackLoaded(TrackPointer pLoadedTrack);
     void trackUnloaded(TrackPointer pUnloadedTrack);
     void loadingTrack(TrackPointer pNewTrack, TrackPointer pOldTrack);
+#ifdef __STEM__
+    void selectedStem(uint stemIdx);
+#endif
     void playerEmpty();
     void noVinylControlInputConfigured();
     void trackRatingChanged(int rating);
@@ -93,7 +100,11 @@ class BaseTrackPlayerImpl : public BaseTrackPlayer {
     TrackPointer loadFakeTrack(bool bPlay, double filebpm);
 
   public slots:
-    void slotLoadTrack(TrackPointer track, bool bPlay) final;
+    void slotLoadTrack(TrackPointer track,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool bPlay) final;
     void slotEjectTrack(double) final;
     void slotCloneFromGroup(const QString& group) final;
     void slotCloneDeck() final;
diff --git a/src/mixer/playermanager.cpp b/src/mixer/playermanager.cpp
index a4f0f1ea15..83a333c712 100644
--- a/src/mixer/playermanager.cpp
+++ b/src/mixer/playermanager.cpp
@@ -453,6 +453,16 @@ void PlayerManager::addDeckInner() {
     // Setup equalizer and QuickEffect chain for this deck.
     m_pEffectsManager->addDeck(handleGroup);
 
+#ifdef __STEM__
+    // Setup stem QuickEffect chain for this deck
+    for (int i = 0; i < 4; i++) {
+        ChannelHandleAndGroup stemHandleGroup =
+                m_pEngine->registerChannelGroup(groupForDeckStem(deckIndex, i));
+        pDeck->getEngineDeck()->addStemHandle(stemHandleGroup);
+        m_pEffectsManager->addStem(stemHandleGroup);
+    }
+#endif
+
     // Setup EQ ControlProxies used for resetting EQs on track load
     pDeck->setupEqControls();
 }
@@ -660,7 +670,12 @@ void PlayerManager::slotCloneDeck(const QString& source_group, const QString& ta
     pPlayer->slotCloneFromGroup(source_group);
 }
 
-void PlayerManager::slotLoadTrackToPlayer(TrackPointer pTrack, const QString& group, bool play) {
+void PlayerManager::slotLoadTrackToPlayer(
+        TrackPointer pTrack, const QString& group,
+#ifdef __STEM__
+        uint stemIdx,
+#endif
+        bool play) {
     // Do not lock mutex in this method unless it is changed to access
     // PlayerManager state.
     BaseTrackPlayer* pPlayer = getPlayer(group);
@@ -711,7 +726,11 @@ void PlayerManager::slotLoadTrackToPlayer(TrackPointer pTrack, const QString& gr
     if (clone) {
         pPlayer->slotCloneDeck();
     } else {
-        pPlayer->slotLoadTrack(pTrack, play);
+        pPlayer->slotLoadTrack(pTrack,
+#ifdef __STEM__
+                stemIdx,
+#endif
+                play);
     }
 
     m_lastLoadedPlayer = group;
@@ -763,7 +782,11 @@ void PlayerManager::slotLoadTrackIntoNextAvailableDeck(TrackPointer pTrack) {
         return;
     }
 
-    pDeck->slotLoadTrack(pTrack, false);
+    pDeck->slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
 }
 
 void PlayerManager::slotLoadLocationIntoNextAvailableDeck(const QString& location, bool play) {
diff --git a/src/mixer/playermanager.h b/src/mixer/playermanager.h
index cbd74d3178..84f9a306ec 100644
--- a/src/mixer/playermanager.h
+++ b/src/mixer/playermanager.h
@@ -154,6 +154,13 @@ class PlayerManager : public QObject, public PlayerManagerInterface {
         return QStringLiteral("[Channel") + QString::number(i + 1) + ']';
     }
 
+    // Returns the group for the ith deck and jth stem where i and j is zero indexed
+    static QString groupForDeckStem(int i, int j) {
+        DEBUG_ASSERT(i >= 0);
+        return QStringLiteral("[Channel") + QString::number(i + 1) +
+                QStringLiteral("Stem") + QString::number(j + 1) + ']';
+    }
+
     // Returns the group for the ith PreviewDeck where i is zero indexed
     static QString groupForPreviewDeck(int i) {
         DEBUG_ASSERT(i >= 0);
@@ -185,7 +192,11 @@ class PlayerManager : public QObject, public PlayerManagerInterface {
 
   public slots:
     // Slots for loading tracks into a Player, which is either a Sampler or a Deck
-    void slotLoadTrackToPlayer(TrackPointer pTrack, const QString& group, bool play);
+    void slotLoadTrackToPlayer(TrackPointer pTrack, const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play);
     void slotLoadLocationToPlayer(const QString& location, const QString& group, bool play);
     void slotLoadLocationToPlayerMaybePlay(const QString& location, const QString& group);
 
diff --git a/src/mixer/samplerbank.cpp b/src/mixer/samplerbank.cpp
index 4e03f6cdea..2ceaf70704 100644
--- a/src/mixer/samplerbank.cpp
+++ b/src/mixer/samplerbank.cpp
@@ -212,7 +212,12 @@ bool SamplerBank::loadSamplerBankFromPath(const QString& samplerBankPath) {
                     }
 
                     if (location.isEmpty()) {
-                        m_pPlayerManager->slotLoadTrackToPlayer(TrackPointer(), group, false);
+                        m_pPlayerManager->slotLoadTrackToPlayer(
+                                TrackPointer(), group,
+#ifdef __STEM__
+                                mixxx::kNoStemSelectedIdx,
+#endif
+                                false);
                     } else {
                         m_pPlayerManager->slotLoadLocationToPlayer(location, group, false);
                     }
diff --git a/src/mixxxmainwindow.cpp b/src/mixxxmainwindow.cpp
index c5b44237bf..fd52669304 100644
--- a/src/mixxxmainwindow.cpp
+++ b/src/mixxxmainwindow.cpp
@@ -57,6 +57,9 @@
 #include "waveform/waveformwidgetfactory.h"
 #include "widget/wglwidget.h"
 #include "widget/wmainmenubar.h"
+//
+//#include "oscclient/oscclientmanager.h"
+//
 
 #ifdef __VINYLCONTROL__
 #include "vinylcontrol/vinylcontrolmanager.h"
@@ -90,6 +93,8 @@ MixxxMainWindow::MixxxMainWindow(std::shared_ptr<mixxx::CoreServices> pCoreServi
         : m_pCoreServices(pCoreServices),
           m_pCentralWidget(nullptr),
           m_pLaunchImage(nullptr),
+//          m_pOscClientManager(nullptr),
+
 #ifndef __APPLE__
           m_prevState(Qt::WindowNoState),
 #endif
@@ -374,6 +379,7 @@ void MixxxMainWindow::initialize() {
     // The user has either reconfigured devices or accepted no outputs,
     // so it's now safe to write the new config to disk.
     m_pCoreServices->getSoundManager()->getConfig().writeToDisk();
+//    m_pOscClientManager = new OscClientManager(pConfig, m_pEngine);
 
     // this has to be after the OpenGL widgets are created or depending on a
     // million different variables the first waveform may be horribly
@@ -518,6 +524,7 @@ MixxxMainWindow::~MixxxMainWindow() {
 
     delete m_pGuiTick;
     delete m_pVisualsManager;
+//    delete m_pOscClientManager;
 }
 
 void MixxxMainWindow::initializeWindow() {
@@ -763,6 +770,19 @@ void MixxxMainWindow::slotUpdateWindowTitle(TrackPointer pTrack) {
         QString trackInfo = pTrack->getInfo();
         if (!trackInfo.isEmpty()) {
             appTitle = QString("%1 | %2").arg(trackInfo, appTitle);
+            //  writing the artist & title of the playing track
+            //  not only to the windowtitle but also to a file
+            //  location and name for nowplayingfile
+            QString StatusNowPlayingFilePath = m_pCoreServices->getSettings()->getSettingsPath();
+            QString StatusNowPlayingFileLocation = StatusNowPlayingFilePath + "/NowPlaying.txt";
+            QFile StatusNowPlayingFile(StatusNowPlayingFileLocation);
+            //          remove previous nowplayingfile
+            StatusNowPlayingFile.remove();
+            StatusNowPlayingFile.open(QIODevice::ReadWrite);
+            QTextStream StatusNowPlayingTxt(&StatusNowPlayingFile);
+            //          write Artist - Trackname to nowplayingfile
+            StatusNowPlayingTxt << QString("%1").arg(trackInfo) << "\n";
+            StatusNowPlayingFile.close();
         }
         filePath = pTrack->getLocation();
     }
diff --git a/src/mixxxmainwindow.h b/src/mixxxmainwindow.h
index 1c673578ce..9e5e1ee6e6 100644
--- a/src/mixxxmainwindow.h
+++ b/src/mixxxmainwindow.h
@@ -8,6 +8,7 @@
 #include "soundio/sounddevicestatus.h"
 #include "track/track_decl.h"
 #include "util/parented_ptr.h"
+#include "util/singleton.h"
 
 class ControlObject;
 class DlgDeveloperTools;
@@ -17,6 +18,7 @@ class GuiTick;
 class LaunchImage;
 class VisualsManager;
 class WMainMenuBar;
+//class OscClientManager;
 
 namespace mixxx {
 
@@ -36,25 +38,31 @@ class LibraryExporter;
 /// It sets up the main window providing a menubar.
 /// For the main view, an instance of class MixxxView is
 /// created which creates your view.
-class MixxxMainWindow : public QMainWindow {
+class MixxxMainWindow : public QMainWindow, public Singleton<MixxxMainWindow> {
     Q_OBJECT
   public:
-    MixxxMainWindow(std::shared_ptr<mixxx::CoreServices> pCoreServices);
-    ~MixxxMainWindow() override;
-
 #ifdef MIXXX_USE_QOPENGL
-    void initializeQOpenGL();
+//    void initializeQOpenGL();
 #endif
     /// Initialize main window after creation. Should only be called once.
     void initialize();
     /// creates the menu_bar and inserts the file Menu
     void createMenuBar();
     void connectMenuBar();
-    void setInhibitScreensaver(mixxx::preferences::ScreenSaver inhibit);
-    mixxx::preferences::ScreenSaver getInhibitScreensaver();
+//    void setInhibitScreensaver(mixxx::preferences::ScreenSaver inhibit);
+//    mixxx::preferences::ScreenSaver getInhibitScreensaver();
 
     inline GuiTick* getGuiTick() { return m_pGuiTick; };
 
+    static void destroy() {
+        Singleton<MixxxMainWindow>::destroy();
+    };
+
+  protected:
+    MixxxMainWindow(std::shared_ptr<mixxx::CoreServices> pCoreServices);
+    ~MixxxMainWindow() override;
+
+    friend class Singleton<MixxxMainWindow>;
   public slots:
     void rebootMixxxView();
 
@@ -142,6 +150,8 @@ class MixxxMainWindow : public QMainWindow {
 
     DlgPreferences* m_pPrefDlg;
     parented_ptr<DlgKeywheel> m_pKeywheel;
+//  oscClientManager
+//  OscClientManager* m_pOscClientManager;
 
 #ifdef __ENGINEPRIME__
     // Library exporter
diff --git a/src/oscclient/defs_oscclient.h b/src/oscclient/defs_oscclient.h
new file mode 100644
index 0000000000..b3fb3f0ac1
--- /dev/null
+++ b/src/oscclient/defs_oscclient.h
@@ -0,0 +1,6 @@
+#ifndef __RECORDING_DEFS_H__
+#define __RECORDING_DEFS_H__
+
+#define OSC_CLIENT_PREF_KEY "[OSCclient]"
+
+#endif
\ No newline at end of file
diff --git a/src/oscclient/oscclientmanager.cpp b/src/oscclient/oscclientmanager.cpp
new file mode 100644
index 0000000000..1091e21b16
--- /dev/null
+++ b/src/oscclient/oscclientmanager.cpp
@@ -0,0 +1,44 @@
+#include <QMutex>
+#include <QDir>
+#include <QtDebug>
+
+#include "oscclient/oscclientmanager.h"
+#include "engine/sidechain/enginesidechain.h"
+#include "engine/sidechain/engineoscclient.h"
+#include "engine/enginemaster.h"
+
+
+OscClientManager::OscClientManager(UserSettingsPointer& pConfig, EngineMaster* pEngine):
+    timer(this)
+         {
+
+    //Register EngineRecord with the engine sidechain.
+    EngineSideChain* pSidechain = pEngine->getSideChain();
+    if (pSidechain) {
+        EngineOscClient* pEngineRecord = new EngineOscClient(pConfig);
+        pSidechain->addSideChainWorker(pEngineRecord);
+    }
+
+
+}
+
+OscClientManager::~OscClientManager()
+{
+    qDebug() << "Delete OscClient";
+}
+
+
+void OscClientManager::sendState(){
+
+}
+
+
+void OscClientManager::connectServer()
+{
+
+}
+
+void OscClientManager::maybeSendState()
+{
+
+}
\ No newline at end of file
diff --git a/src/oscclient/oscclientmanager.h b/src/oscclient/oscclientmanager.h
new file mode 100644
index 0000000000..4ad39b443c
--- /dev/null
+++ b/src/oscclient/oscclientmanager.h
@@ -0,0 +1,34 @@
+#ifndef OscClientManager_H
+#define OscClientManager_H
+
+#include <QDateTime>
+#include <QObject>
+#include <QString>
+
+
+#include "preferences/usersettings.h"
+#include "control/controlobject.h"
+#include "control/controlproxy.h"
+//#include "oscclient/defs_oscclient.h"
+#include <QTimer>
+#include <QList>
+#include <QTime>
+
+
+class EngineMaster;
+
+class OscClientManager : public QObject
+{
+    Q_OBJECT
+  public:
+    OscClientManager(UserSettingsPointer& pConfig, EngineMaster* pEngine);
+    virtual ~OscClientManager();
+public slots:
+    void sendState();
+    void maybeSendState();
+    void connectServer();
+private:
+    QTimer timer;
+};
+
+#endif // OscClientManager_H
\ No newline at end of file
diff --git a/src/oscserver/defs_oscserver.h b/src/oscserver/defs_oscserver.h
new file mode 100644
index 0000000000..53208c7975
--- /dev/null
+++ b/src/oscserver/defs_oscserver.h
@@ -0,0 +1,7 @@
+#ifndef __OSCSERVER_DEFS_H__
+#define __OSCSERVER_DEFS_H__
+
+#define OSC_SERVER_PREF_KEY "[OscServer]"
+#define OSC_SERVER_DEFAULT_PORT "8000"
+
+#endif
\ No newline at end of file
diff --git a/src/oscserver/oscserver.cpp b/src/oscserver/oscserver.cpp
new file mode 100644
index 0000000000..2ecace6d85
--- /dev/null
+++ b/src/oscserver/oscserver.cpp
@@ -0,0 +1,173 @@
+#include "oscserver.h"
+
+namespace {
+void oscErrorHandler(int err, const char *msg, const char *path) {
+  qWarning() << QString("%1. OSC path: %2. Error Code: %3.")
+                    .arg(QString::fromLatin1(msg))
+                    .arg(QString::fromLatin1(path))
+                    .arg(err);
+}
+
+int oscMsgHandler(const char *path, const char *types, lo_arg **argv, int argc,
+                  void *data, void *userData) {
+  Q_UNUSED(userData);
+
+  QRegularExpression pathRegEx("\\/mixxx\\/(.+)\\/(.+)");
+  QRegularExpressionMatch pathMatch =
+      pathRegEx.match(QString::fromLatin1(path));
+
+  if (!pathMatch.hasMatch()) {
+    qWarning() << "Invalid OSC path: " << QString::fromLatin1(path);
+    qWarning() << "Proper OSC path format: /mixxx/<group>/<control>";
+    return 1;
+  }
+
+  ConfigKey key = ConfigKey(pathMatch.captured(1), pathMatch.captured(2));
+
+  if (key.isNull() || key.isEmpty()) {
+    qWarning() << "Invalid group/key pair specified in OSC path: "
+               << QString::fromLatin1(path);
+    return 1;
+  }
+
+  for (int i = 0; i < argc; ++i) {
+    lo_type argType = static_cast<lo_type>(types[i]);
+
+    if ((argType == LO_BLOB) || (argType == LO_TIMETAG) ||
+        (argType == LO_MIDI) || (argType == LO_NIL) ||
+        (argType == LO_INFINITUM)) {
+      continue;
+    }
+
+    if ((argType == LO_STRING) || (argType == LO_SYMBOL)) {
+      if (reinterpret_cast<char *>(argv[i])[0] == '?') {
+        lo_address msgTo = lo_message_get_source(static_cast<lo_message>(data));
+        if (lo_send(msgTo, path, "d", ControlObject::get(key)) == -1) {
+          char *targetUrl = lo_address_get_url(msgTo);
+          qWarning() << "Failed to reply to OSC get parameter message from: "
+                     << QString::fromLatin1(targetUrl);
+          free(targetUrl);
+        }
+      }
+
+      continue;
+    }
+
+    if (argType == LO_INT32) {
+      ControlObject::set(key, static_cast<double>(argv[i]->i));
+      continue;
+    }
+
+    if (argType == LO_FLOAT) {
+      ControlObject::set(key, static_cast<double>(argv[i]->f));
+      continue;
+    }
+
+    if (argType == LO_INT64) {
+      ControlObject::set(key, static_cast<double>(argv[i]->h));
+      continue;
+    }
+
+    if (argType == LO_DOUBLE) {
+      ControlObject::set(key, argv[i]->d);
+      continue;
+    }
+
+    if (argType == LO_CHAR) {
+      ControlObject::set(key, static_cast<double>(argv[i]->c));
+      continue;
+    }
+
+    if (argType == LO_TRUE) {
+      ControlObject::set(key, 1.0);
+      continue;
+    }
+
+    if (argType == LO_FALSE) {
+      ControlObject::set(key, 0.0);
+      continue;
+    }
+  }
+
+  return 0;
+}
+}; // namespace
+
+OscServer::OscServer(UserSettingsPointer pConfig)
+    : m_pConfig(pConfig), m_st(nullptr) {
+  m_pUpdateProxy =
+      std::make_unique<ControlProxy>(OSC_SERVER_PREF_KEY, "NeedsUpdate");
+  m_pUpdateProxy->connectValueChanged(this, &OscServer::slotNeedsUpdate);
+  m_pErrorProxy = std::make_unique<ControlProxy>(OSC_SERVER_PREF_KEY, "Error");
+
+  init();
+}
+
+OscServer::~OscServer() { quit(); }
+
+bool OscServer::init() {
+  // Return true in these two cases because there was no error
+  // (init was simply not necessary in these cases)
+  if (m_st) {
+    return true;
+  }
+
+  if (!m_pConfig->getValue<bool>(ConfigKey(OSC_SERVER_PREF_KEY, "Enabled"))) {
+    return true;
+  }
+
+  QString port =
+      m_pConfig->getValueString(ConfigKey(OSC_SERVER_PREF_KEY, "Port"));
+  // If user has not chosen a port, fall back to default.
+  if (port.isEmpty() || port.isNull()) {
+    port = OSC_SERVER_DEFAULT_PORT;
+  }
+
+  m_st = lo_server_thread_new(port.toLatin1().data(), oscErrorHandler);
+  if (!m_st) {
+    setError(true);
+    return false;
+  }
+
+  lo_server_thread_add_method(m_st, nullptr, nullptr, oscMsgHandler, nullptr);
+  if (lo_server_thread_start(m_st) < 0) {
+    // m_st != nullptr, so call quit() to free it
+    quit();
+
+    setError(true);
+    return false;
+  }
+
+  // Clear any previous failed init errors and update status to show OSC enabled
+  setError(false);
+  return true;
+}
+
+void OscServer::quit() {
+  if (!m_st) {
+    return;
+  }
+
+  lo_server_thread_free(m_st);
+  m_st = nullptr;
+
+  // Clear any previous errors and update status to show OSC disabled
+  setError(false);
+}
+
+void OscServer::slotNeedsUpdate(double needsUpdate) {
+  if (needsUpdate <= 0.0) {
+    return;
+  }
+
+  quit();
+  init();
+
+  setNeedsUpdate(false);
+}
+
+void OscServer::setNeedsUpdate(bool needsUpdate) {
+  m_pUpdateProxy->set(needsUpdate ? 1.0 : 0.0);
+}
+
+void OscServer::setError(bool error) { m_pErrorProxy->set(error ? 1.0 : 0.0); }
\ No newline at end of file
diff --git a/src/oscserver/oscserver.h b/src/oscserver/oscserver.h
new file mode 100644
index 0000000000..8440c37815
--- /dev/null
+++ b/src/oscserver/oscserver.h
@@ -0,0 +1,41 @@
+#ifndef __OSCSERVER_H__
+#define __OSCSERVER_H__
+
+#include "util/memory.h"
+
+#include <QRegularExpression>
+
+#include "control/controlobject.h"
+#include "control/controlproxy.h"
+#include "lo/lo.h"
+#include "oscserver/defs_oscserver.h"
+#include "preferences/usersettings.h"
+
+class OscServer : public QObject {
+  Q_OBJECT
+
+public:
+  OscServer(UserSettingsPointer pConfig);
+  virtual ~OscServer();
+
+  bool init();
+  void quit();
+
+private:
+  void setNeedsUpdate(bool needsUpdate);
+  // Sets whether to display a warning (error = true) or a success message
+  // (error = false) on the OSC preferences page
+  void setError(bool error);
+
+private slots:
+  void slotNeedsUpdate(double needsUpdate);
+
+private:
+  UserSettingsPointer m_pConfig;
+  std::unique_ptr<ControlProxy> m_pUpdateProxy;
+  std::unique_ptr<ControlProxy> m_pErrorProxy;
+
+  lo_server_thread m_st;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/preferences/colorpaletteeditormodel.cpp b/src/preferences/colorpaletteeditormodel.cpp
index d683b3db5e..33b5dd58ac 100644
--- a/src/preferences/colorpaletteeditormodel.cpp
+++ b/src/preferences/colorpaletteeditormodel.cpp
@@ -173,7 +173,7 @@ ColorPalette ColorPaletteEditorModel::getColorPalette(
             }
         }
     }
-    // If we have a non consequitive list of hotcue indexes, indexes are shifted down
+    // If we have a non consecutive list of hotcue indexes, indexes are shifted down
     // due to the sorting nature of QMap. This is intended, this way we have a color for every hotcue.
     return ColorPalette(name, colors, hotcueColorIndices.values());
 }
diff --git a/src/preferences/colorpalettesettings.cpp b/src/preferences/colorpalettesettings.cpp
index 8fdcf0a785..3df1480e1a 100644
--- a/src/preferences/colorpalettesettings.cpp
+++ b/src/preferences/colorpalettesettings.cpp
@@ -15,6 +15,8 @@ const QString kColorPaletteHotcueIndicesConfigSeparator = QStringLiteral(" ");
 const QString kColorPaletteGroup = QStringLiteral("[ColorPalette %1]");
 const ConfigKey kHotcueColorPaletteConfigKey(kColorPaletteConfigGroup, QStringLiteral("HotcueColorPalette"));
 const ConfigKey kTrackColorPaletteConfigKey(kColorPaletteConfigGroup, QStringLiteral("TrackColorPalette"));
+const ConfigKey kKeyColorPaletteConfigKey(
+        kColorPaletteConfigGroup, QStringLiteral("KeyColorPalette"));
 
 int numberOfDecimalDigits(int number) {
     int numDigits = 1;
@@ -164,6 +166,28 @@ void ColorPaletteSettings::setTrackColorPalette(const ColorPalette& colorPalette
     setColorPalette(name, colorPalette);
 }
 
+ColorPalette ColorPaletteSettings::getKeyColorPalette(
+        const QString& name) const {
+    return getColorPalette(
+            name,
+            mixxx::PredefinedColorPalettes::kDefaultKeyColorPalette);
+}
+
+ColorPalette ColorPaletteSettings::getConfigKeyColorPalette() const {
+    QString name = m_pConfig->getValueString(kKeyColorPaletteConfigKey);
+    return getKeyColorPalette(name);
+}
+
+void ColorPaletteSettings::setKeyColorPalette(const ColorPalette& colorPalette) {
+    QString name = colorPalette.getName();
+    VERIFY_OR_DEBUG_ASSERT(!name.isEmpty()) {
+        qWarning() << "Palette name must not be empty!";
+        return;
+    }
+    m_pConfig->setValue(kKeyColorPaletteConfigKey, name);
+    setColorPalette(name, colorPalette);
+}
+
 QSet<QString> ColorPaletteSettings::getColorPaletteNames() const {
     QSet<QString> names;
     const QSet<QString> groups = m_pConfig->getGroups();
diff --git a/src/preferences/colorpalettesettings.h b/src/preferences/colorpalettesettings.h
index 53bdb0d3aa..c0e9725e02 100644
--- a/src/preferences/colorpalettesettings.h
+++ b/src/preferences/colorpalettesettings.h
@@ -18,6 +18,10 @@ class ColorPaletteSettings {
     ColorPalette getTrackColorPalette() const;
     void setTrackColorPalette(const ColorPalette& colorPalette);
 
+    ColorPalette getKeyColorPalette(const QString& name) const;
+    ColorPalette getConfigKeyColorPalette() const;
+    void setKeyColorPalette(const ColorPalette& colorPalette);
+
     ColorPalette getColorPalette(
             const QString& name,
             const ColorPalette& defaultPalette) const;
diff --git a/src/preferences/dialog/dlgprefcolors.cpp b/src/preferences/dialog/dlgprefcolors.cpp
index deedf64da9..18e6fa2673 100644
--- a/src/preferences/dialog/dlgprefcolors.cpp
+++ b/src/preferences/dialog/dlgprefcolors.cpp
@@ -41,6 +41,7 @@ DlgPrefColors::DlgPrefColors(
     setupUi(this);
     comboBoxHotcueColors->setIconSize(kPalettePreviewSize);
     comboBoxTrackColors->setIconSize(kPalettePreviewSize);
+    comboBoxKeyColors->setIconSize(kPalettePreviewSize);
 
     m_pReplaceCueColorDlg->setHidden(true);
     connect(m_pReplaceCueColorDlg,
@@ -53,6 +54,11 @@ DlgPrefColors::DlgPrefColors(
             this,
             &DlgPrefColors::slotHotcuePaletteIndexChanged);
 
+    connect(comboBoxKeyColors,
+            QOverload<int>::of(&QComboBox::currentIndexChanged),
+            this,
+            &DlgPrefColors::slotKeyPaletteIndexChanged);
+
     connect(pushButtonEditHotcuePalette,
             &QPushButton::clicked,
             this,
@@ -84,31 +90,43 @@ DlgPrefColors::~DlgPrefColors() {
 void DlgPrefColors::slotUpdate() {
     comboBoxHotcueColors->clear();
     comboBoxTrackColors->clear();
+    comboBoxKeyColors->clear();
     checkboxKeyColorsEnabled->setChecked(
             m_pConfig->getValue(kKeyColorsEnabledConfigKey,
                     BaseTrackTableModel::kKeyColorsEnabledDefault));
     for (const auto& palette : std::as_const(mixxx::PredefinedColorPalettes::kPalettes)) {
         QString paletteName = palette.getName();
+        QString translatedName = QCoreApplication::translate(
+                "PredefinedColorPalettes", qPrintable(paletteName));
         QIcon paletteIcon = drawPalettePreview(paletteName);
-        comboBoxHotcueColors->addItem(paletteName);
+        comboBoxHotcueColors->addItem(translatedName, paletteName);
         comboBoxHotcueColors->setItemIcon(
                 comboBoxHotcueColors->count() - 1,
                 paletteIcon);
 
-        comboBoxTrackColors->addItem(paletteName);
+        comboBoxTrackColors->addItem(translatedName, paletteName);
         comboBoxTrackColors->setItemIcon(
                 comboBoxTrackColors->count() - 1,
                 paletteIcon);
+
+        if (palette.size() == 12) {
+            comboBoxKeyColors->addItem(translatedName, paletteName);
+            comboBoxKeyColors->setItemIcon(
+                    comboBoxKeyColors->count() - 1,
+                    paletteIcon);
+        }
     }
 
     const QSet<QString> colorPaletteNames = m_colorPaletteSettings.getColorPaletteNames();
     for (const auto& paletteName : colorPaletteNames) {
+        QString translatedName = QCoreApplication::translate(
+                "PredefinedColorPalettes", qPrintable(paletteName));
         QIcon paletteIcon = drawPalettePreview(paletteName);
-        comboBoxHotcueColors->addItem(paletteName);
+        comboBoxHotcueColors->addItem(translatedName, paletteName);
         comboBoxHotcueColors->setItemIcon(
                 comboBoxHotcueColors->count() - 1,
                 paletteIcon);
-        comboBoxTrackColors->addItem(paletteName);
+        comboBoxTrackColors->addItem(translatedName, paletteName);
         comboBoxTrackColors->setItemIcon(
                 comboBoxHotcueColors->count() - 1,
                 paletteIcon);
@@ -116,15 +134,20 @@ void DlgPrefColors::slotUpdate() {
 
     const ColorPalette trackPalette =
             m_colorPaletteSettings.getTrackColorPalette();
-    comboBoxTrackColors->setCurrentText(
-            trackPalette.getName());
+    comboBoxTrackColors->setCurrentText(QCoreApplication::translate(
+            "PredefinedColorPalettes", qPrintable(trackPalette.getName())));
 
     const ColorPalette hotcuePalette =
             m_colorPaletteSettings.getHotcueColorPalette();
-    comboBoxHotcueColors->setCurrentText(
-            hotcuePalette.getName());
+    comboBoxHotcueColors->setCurrentText(QCoreApplication::translate(
+            "PredefinedColorPalettes", qPrintable(hotcuePalette.getName())));
     slotHotcuePaletteIndexChanged(comboBoxHotcueColors->currentIndex());
 
+    const ColorPalette keyPalette =
+            m_colorPaletteSettings.getConfigKeyColorPalette();
+    comboBoxKeyColors->setCurrentText(QCoreApplication::translate(
+            "PredefinedColorPalettes", qPrintable(keyPalette.getName())));
+
     bool autoHotcueColors = m_pConfig->getValue(kAutoHotcueColorsConfigKey, false);
     if (autoHotcueColors) {
         comboBoxHotcueDefaultColor->setCurrentIndex(0);
@@ -161,12 +184,19 @@ void DlgPrefColors::slotUpdate() {
 
 // Set the default values for all the widgets
 void DlgPrefColors::slotResetToDefaults() {
-    comboBoxHotcueColors->setCurrentText(
-            mixxx::PredefinedColorPalettes::kDefaultHotcueColorPalette
-                    .getName());
-    comboBoxTrackColors->setCurrentText(
-            mixxx::PredefinedColorPalettes::kDefaultTrackColorPalette
-                    .getName());
+    comboBoxHotcueColors->setCurrentText(QCoreApplication::translate(
+            "PredefinedColorPalettes",
+            qPrintable(
+                    mixxx::PredefinedColorPalettes::kDefaultHotcueColorPalette
+                            .getName())));
+    comboBoxTrackColors->setCurrentText(QCoreApplication::translate(
+            "PredefinedColorPalettes",
+            qPrintable(mixxx::PredefinedColorPalettes::kDefaultTrackColorPalette
+                               .getName())));
+    comboBoxKeyColors->setCurrentText(QCoreApplication::translate(
+            "PredefinedColorPalettes",
+            qPrintable(mixxx::PredefinedColorPalettes::kDefaultKeyColorPalette
+                               .getName())));
     comboBoxHotcueDefaultColor->setCurrentIndex(
             mixxx::PredefinedColorPalettes::kDefaultTrackColorPalette.size());
     comboBoxLoopDefaultColor->setCurrentIndex(
@@ -176,10 +206,12 @@ void DlgPrefColors::slotResetToDefaults() {
 
 // Apply and save any changes made in the dialog
 void DlgPrefColors::slotApply() {
-    QString hotcueColorPaletteName = comboBoxHotcueColors->currentText();
-    QString trackColorPaletteName = comboBoxTrackColors->currentText();
+    QString hotcueColorPaletteName = comboBoxHotcueColors->currentData().toString();
+    QString trackColorPaletteName = comboBoxTrackColors->currentData().toString();
+    QString keyColorPaletteName = comboBoxKeyColors->currentData().toString();
     bool bHotcueColorPaletteFound = false;
     bool bTrackColorPaletteFound = false;
+    bool bKeyColorPaletteFound = false;
 
     for (const auto& palette :
             std::as_const(mixxx::PredefinedColorPalettes::kPalettes)) {
@@ -193,6 +225,11 @@ void DlgPrefColors::slotApply() {
             m_colorPaletteSettings.setTrackColorPalette(palette);
             bTrackColorPaletteFound = true;
         }
+        if (!bKeyColorPaletteFound &&
+                keyColorPaletteName == palette.getName()) {
+            m_colorPaletteSettings.setKeyColorPalette(palette);
+            bKeyColorPaletteFound = true;
+        }
     }
 
     if (!bHotcueColorPaletteFound) {
@@ -207,6 +244,12 @@ void DlgPrefColors::slotApply() {
                         m_colorPaletteSettings.getTrackColorPalette()));
     }
 
+    if (!bKeyColorPaletteFound) {
+        m_colorPaletteSettings.setKeyColorPalette(
+                m_colorPaletteSettings.getColorPalette(keyColorPaletteName,
+                        m_colorPaletteSettings.getConfigKeyColorPalette()));
+    }
+
     int hotcueColorIndex = comboBoxHotcueDefaultColor->currentIndex();
 
     if (hotcueColorIndex > 0) {
@@ -235,7 +278,7 @@ void DlgPrefColors::slotReplaceCueColorClicked() {
 
     ColorPalette savedPalette = colorPaletteSettings.getHotcueColorPalette();
     ColorPalette newPalette = colorPaletteSettings.getColorPalette(
-            comboBoxHotcueColors->currentText(), savedPalette);
+            comboBoxHotcueColors->currentData().toString(), savedPalette);
     m_pReplaceCueColorDlg->setColorPalette(newPalette);
 
     int savedDefaultColorIndex = m_pConfig->getValue(
@@ -300,7 +343,7 @@ QIcon DlgPrefColors::drawHotcueColorByPaletteIcon(const QString& paletteName) {
 }
 
 void DlgPrefColors::slotHotcuePaletteIndexChanged(int paletteIndex) {
-    QString paletteName = comboBoxHotcueColors->itemText(paletteIndex);
+    QString paletteName = comboBoxHotcueColors->itemData(paletteIndex).toString();
     ColorPalette palette =
             m_colorPaletteSettings.getHotcueColorPalette(paletteName);
 
@@ -348,13 +391,20 @@ void DlgPrefColors::slotHotcuePaletteIndexChanged(int paletteIndex) {
     }
 }
 
+void DlgPrefColors::slotKeyPaletteIndexChanged(int paletteIndex) {
+    QString paletteName = comboBoxKeyColors->itemData(paletteIndex).toString();
+    ColorPalette palette =
+            m_colorPaletteSettings.getKeyColorPalette(paletteName);
+    BaseTrackTableModel::setKeyColorPalette(palette);
+}
+
 void DlgPrefColors::slotEditTrackPaletteClicked() {
-    QString trackColorPaletteName = comboBoxTrackColors->currentText();
+    QString trackColorPaletteName = comboBoxTrackColors->currentData().toString();
     openColorPaletteEditor(trackColorPaletteName, false);
 }
 
 void DlgPrefColors::slotEditHotcuePaletteClicked() {
-    QString hotcueColorPaletteName = comboBoxHotcueColors->currentText();
+    QString hotcueColorPaletteName = comboBoxHotcueColors->currentData().toString();
     openColorPaletteEditor(hotcueColorPaletteName, true);
 }
 
@@ -391,7 +441,7 @@ void DlgPrefColors::openColorPaletteEditor(
 }
 
 void DlgPrefColors::trackPaletteUpdated(const QString& trackColors) {
-    QString hotcueColors = comboBoxHotcueColors->currentText();
+    QString hotcueColors = comboBoxHotcueColors->currentData().toString();
     int defaultHotcueColor = comboBoxHotcueDefaultColor->currentIndex();
     int defaultLoopColor = comboBoxLoopDefaultColor->currentIndex();
 
@@ -400,7 +450,7 @@ void DlgPrefColors::trackPaletteUpdated(const QString& trackColors) {
 }
 
 void DlgPrefColors::hotcuePaletteUpdated(const QString& hotcueColors) {
-    QString trackColors = comboBoxTrackColors->currentText();
+    QString trackColors = comboBoxTrackColors->currentData().toString();
     int defaultHotcueColor = comboBoxHotcueDefaultColor->currentIndex();
     int defaultLoopColor = comboBoxLoopDefaultColor->currentIndex();
 
@@ -409,8 +459,8 @@ void DlgPrefColors::hotcuePaletteUpdated(const QString& hotcueColors) {
 }
 
 void DlgPrefColors::palettesUpdated() {
-    QString hotcueColors = comboBoxHotcueColors->currentText();
-    QString trackColors = comboBoxTrackColors->currentText();
+    QString hotcueColors = comboBoxHotcueColors->currentData().toString();
+    QString trackColors = comboBoxTrackColors->currentData().toString();
     int defaultHotcueColor = comboBoxHotcueDefaultColor->currentIndex();
     int defaultLoopColor = comboBoxLoopDefaultColor->currentIndex();
 
@@ -423,8 +473,10 @@ void DlgPrefColors::restoreComboBoxes(
         const QString& trackColors,
         int defaultHotcueColor,
         int defaultLoopColor) {
-    comboBoxHotcueColors->setCurrentText(hotcueColors);
-    comboBoxTrackColors->setCurrentText(trackColors);
+    comboBoxHotcueColors->setCurrentText(QCoreApplication::translate(
+            "PredefinedColorPalettes", qPrintable(hotcueColors)));
+    comboBoxTrackColors->setCurrentText(QCoreApplication::translate(
+            "PredefinedColorPalettes", qPrintable(trackColors)));
     if (comboBoxHotcueDefaultColor->count() > defaultHotcueColor) {
         comboBoxHotcueDefaultColor->setCurrentIndex(defaultHotcueColor);
     } else {
diff --git a/src/preferences/dialog/dlgprefcolors.h b/src/preferences/dialog/dlgprefcolors.h
index 461cff3828..8ee2709998 100644
--- a/src/preferences/dialog/dlgprefcolors.h
+++ b/src/preferences/dialog/dlgprefcolors.h
@@ -33,6 +33,7 @@ class DlgPrefColors : public DlgPreferencePage, public Ui::DlgPrefColorsDlg {
 
   private slots:
     void slotHotcuePaletteIndexChanged(int paletteIndex);
+    void slotKeyPaletteIndexChanged(int paletteIndex);
     void trackPaletteUpdated(const QString& palette);
     void hotcuePaletteUpdated(const QString& palette);
     void palettesUpdated();
diff --git a/src/preferences/dialog/dlgprefcolorsdlg.ui b/src/preferences/dialog/dlgprefcolorsdlg.ui
index edf79204fe..3feafd4671 100644
--- a/src/preferences/dialog/dlgprefcolorsdlg.ui
+++ b/src/preferences/dialog/dlgprefcolorsdlg.ui
@@ -112,7 +112,25 @@ associated with each key.</string>
      </widget>
     </item>
 
-    <item row="5" column="0" colspan="2">
+    <item row="5" column="0">
+     <widget class="QLabel" name="labelKeyColors">
+      <property name="text">
+       <string>Key palette</string>
+      </property>
+     </widget>
+    </item>
+    <item row="5" column="1">
+     <widget class="QComboBox" name="comboBoxKeyColors">
+      <property name="sizePolicy">
+       <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+        <horstretch>0</horstretch>
+        <verstretch>0</verstretch>
+       </sizepolicy>
+      </property>
+     </widget>
+    </item>
+
+    <item row="6" column="0" colspan="2">
      <spacer>
       <property name="orientation">
        <enum>Qt::Vertical</enum>
diff --git a/src/preferences/dialog/dlgpreferences.cpp b/src/preferences/dialog/dlgpreferences.cpp
index 47b96b9fa0..053ed851e4 100644
--- a/src/preferences/dialog/dlgpreferences.cpp
+++ b/src/preferences/dialog/dlgpreferences.cpp
@@ -29,6 +29,7 @@
 #include "preferences/dialog/dlgprefinterface.h"
 #include "preferences/dialog/dlgprefmixer.h"
 #include "preferences/dialog/dlgprefwaveform.h"
+//#include "preferences/dialog/dlgprefosc.h"
 
 #ifdef __BROADCAST__
 #include "preferences/dialog/dlgprefbroadcast.h"
@@ -227,6 +228,11 @@ DlgPreferences::DlgPreferences(
                           new QTreeWidgetItem(contentsTreeWidget, QTreeWidgetItem::Type)),
             tr("Normalization"),
             "ic_preferences_replaygain.svg");
+//    addPageWidget(PreferencesPage(
+//                          new DlgPrefOsc(this, m_pConfig),
+//                          new QTreeWidgetItem(contentsTreeWidget, QTreeWidgetItem::Type)),
+//            tr("Normalization"),
+//            "ic_preferences_osc.svg");
 
 #ifdef __MODPLUG__
     addPageWidget(PreferencesPage(
diff --git a/src/preferences/dialog/dlgprefrecord.cpp b/src/preferences/dialog/dlgprefrecord.cpp
index d4e39dfcf1..0ae6b19be8 100644
--- a/src/preferences/dialog/dlgprefrecord.cpp
+++ b/src/preferences/dialog/dlgprefrecord.cpp
@@ -17,7 +17,7 @@ constexpr bool kDefaultCueEnabled = true;
 DlgPrefRecord::DlgPrefRecord(QWidget* parent, UserSettingsPointer pConfig)
         : DlgPreferencePage(parent),
           m_pConfig(pConfig),
-          m_selFormat(QString(), QString(), false, QString()) {
+          m_selFormat({QString(), QString(), false, QString()}) {
     setupUi(this);
 
     // Setting recordings path.
diff --git a/src/preferences/dialog/dlgprefsound.cpp b/src/preferences/dialog/dlgprefsound.cpp
index dd7a552c12..eaf86a07d1 100644
--- a/src/preferences/dialog/dlgprefsound.cpp
+++ b/src/preferences/dialog/dlgprefsound.cpp
@@ -216,11 +216,11 @@ DlgPrefSound::DlgPrefSound(QWidget* pParent,
             QOverload<int>::of(&QComboBox::currentIndexChanged),
             this,
             &DlgPrefSound::settingChanged);
+#ifdef __RUBBERBAND__
     connect(keylockComboBox,
             QOverload<int>::of(&QComboBox::currentIndexChanged),
             this,
             &DlgPrefSound::updateKeylockDualThreadingCheckbox);
-#ifdef __RUBBERBAND__
     connect(keylockDualthreadedCheckBox,
             &QCheckBox::clicked,
             this,
@@ -365,7 +365,9 @@ void DlgPrefSound::slotApply() {
     m_bSkipConfigClear = true;
     loadSettings(); // in case SM decided to change anything it didn't like
     checkLatencyCompensation();
+#ifdef __RUBBERBAND__
     updateKeylockDualThreadingCheckbox();
+#endif
     m_bSkipConfigClear = false;
 }
 
@@ -749,10 +751,9 @@ void DlgPrefSound::settingChanged() {
         return; // doesn't count if we're just loading prefs
     }
     m_settingsModified = true;
-
-#ifdef __RUBBERBAND__
 }
 
+#ifdef __RUBBERBAND__
 void DlgPrefSound::updateKeylockDualThreadingCheckbox() {
     bool supportedScaler = keylockComboBox->currentData()
                                    .value<EngineBuffer::KeylockEngine>() !=
@@ -790,8 +791,8 @@ void DlgPrefSound::updateKeylockMultithreading(bool enabled) {
     keylockDualthreadedCheckBox->setChecked(msg.clickedButton() == pYesBtn);
 
     updateKeylockDualThreadingCheckbox();
-#endif
 }
+#endif
 
 /// Slot called when a device from the config can not be selected, i.e. is
 /// currently not available. This may happen during startup when MixxxMainWindow
@@ -910,7 +911,9 @@ void DlgPrefSound::slotResetToDefaults() {
     latencyCompensationSpinBox->setValue(latencyCompensationSpinBox->minimum());
 
     settingChanged();
+#ifdef __RUBBERBAND__
     updateKeylockDualThreadingCheckbox();
+#endif
 }
 
 void DlgPrefSound::bufferUnderflow(double count) {
diff --git a/src/qml/qmlchainpresetmodel.cpp b/src/qml/qmlchainpresetmodel.cpp
new file mode 100644
index 0000000000..9d8c8590af
--- /dev/null
+++ b/src/qml/qmlchainpresetmodel.cpp
@@ -0,0 +1,73 @@
+#include "qml/qmlchainpresetmodel.h"
+
+#include <QModelIndex>
+
+#include "effects/backends/effectmanifest.h"
+#include "effects/effectsmanager.h"
+#include "effects/presets/effectchainpreset.h"
+#include "moc_qmlchainpresetmodel.cpp"
+
+namespace mixxx {
+namespace qml {
+namespace {
+const QHash<int, QByteArray> kRoleNames = {
+        {Qt::DisplayRole, "display"},
+        {Qt::ToolTipRole, "tooltip"},
+};
+}
+
+QmlChainPresetModel::QmlChainPresetModel(
+        EffectChainPresetManagerPointer effectChainPresetManager,
+        QObject* parent)
+        : QAbstractListModel(parent), m_pEffectChainPresetManager(effectChainPresetManager) {
+    slotUpdated();
+    connect(m_pEffectChainPresetManager.get(),
+            &EffectChainPresetManager::quickEffectChainPresetListUpdated,
+            this,
+            &QmlChainPresetModel::slotUpdated);
+}
+
+void QmlChainPresetModel::slotUpdated() {
+    beginResetModel();
+    m_effectChainPresets = m_pEffectChainPresetManager->getQuickEffectPresetsSorted();
+    endResetModel();
+}
+
+QVariant QmlChainPresetModel::data(const QModelIndex& index, int role) const {
+    if (index.row() >= m_effectChainPresets.size()) {
+        return QVariant();
+    }
+
+    const EffectChainPresetPointer pPreset = m_effectChainPresets.at(index.row());
+    switch (role) {
+    case Qt::DisplayRole:
+    case Qt::ToolTipRole:
+        return pPreset->name();
+    default:
+        return QVariant();
+    }
+}
+
+int QmlChainPresetModel::rowCount(const QModelIndex& parent) const {
+    if (parent.isValid()) {
+        return 0;
+    }
+
+    return m_effectChainPresets.size();
+}
+
+QHash<int, QByteArray> QmlChainPresetModel::roleNames() const {
+    return kRoleNames;
+}
+
+QVariant QmlChainPresetModel::get(int row) const {
+    QModelIndex idx = index(row, 0);
+    QVariantMap dataMap;
+    for (auto it = kRoleNames.constBegin(); it != kRoleNames.constEnd(); it++) {
+        dataMap.insert(it.value(), data(idx, it.key()));
+    }
+    return dataMap;
+}
+
+} // namespace qml
+} // namespace mixxx
diff --git a/src/qml/qmlchainpresetmodel.h b/src/qml/qmlchainpresetmodel.h
new file mode 100644
index 0000000000..76db06f75f
--- /dev/null
+++ b/src/qml/qmlchainpresetmodel.h
@@ -0,0 +1,38 @@
+#pragma once
+#include <QAbstractListModel>
+#include <QtQml>
+
+#include "effects/defs.h"
+
+namespace mixxx {
+namespace qml {
+
+class QmlChainPresetModel : public QAbstractListModel {
+    Q_OBJECT
+    QML_NAMED_ELEMENT(ChainPresetModel)
+    QML_UNCREATABLE("Only accessible via Mixxx.EffectsManager.quickEffectPresetsModel")
+  public:
+    enum Roles {
+        EffectIdRole = Qt::UserRole + 1,
+    };
+    Q_ENUM(Roles)
+
+    explicit QmlChainPresetModel(
+            EffectChainPresetManagerPointer effectChainPresetManager,
+            QObject* parent = nullptr);
+
+    QVariant data(const QModelIndex& index, int role) const override;
+    int rowCount(const QModelIndex& parent) const override;
+    QHash<int, QByteArray> roleNames() const override;
+    Q_INVOKABLE QVariant get(int row) const;
+
+  private slots:
+    void slotUpdated();
+
+  private:
+    const EffectChainPresetManagerPointer m_pEffectChainPresetManager;
+    QList<EffectChainPresetPointer> m_effectChainPresets;
+};
+
+} // namespace qml
+} // namespace mixxx
diff --git a/src/qml/qmleffectsmanagerproxy.cpp b/src/qml/qmleffectsmanagerproxy.cpp
index 357fc771aa..927126e0f4 100644
--- a/src/qml/qmleffectsmanagerproxy.cpp
+++ b/src/qml/qmleffectsmanagerproxy.cpp
@@ -5,6 +5,7 @@
 
 #include "effects/effectchain.h"
 #include "moc_qmleffectsmanagerproxy.cpp"
+#include "qml/qmlchainpresetmodel.h"
 
 namespace mixxx {
 namespace qml {
@@ -14,7 +15,9 @@ QmlEffectsManagerProxy::QmlEffectsManagerProxy(
         : QObject(parent),
           m_pEffectsManager(pEffectsManager),
           m_pVisibleEffectsModel(
-                  new QmlVisibleEffectsModel(pEffectsManager, this)) {
+                  new QmlVisibleEffectsModel(pEffectsManager, this)),
+          m_pQuickChainPresetModel(
+                  new QmlChainPresetModel(m_pEffectsManager->getChainPresetManager(), this)) {
 }
 
 QmlEffectSlotProxy* QmlEffectsManagerProxy::getEffectSlot(int unitNumber, int effectNumber) const {
diff --git a/src/qml/qmleffectsmanagerproxy.h b/src/qml/qmleffectsmanagerproxy.h
index 7e49f435f3..219accbb57 100644
--- a/src/qml/qmleffectsmanagerproxy.h
+++ b/src/qml/qmleffectsmanagerproxy.h
@@ -3,16 +3,21 @@
 #include <QtQml>
 
 #include "effects/effectsmanager.h"
+#include "qml/qmlchainpresetmodel.h"
 #include "qml/qmleffectslotproxy.h"
 #include "qml/qmlvisibleeffectsmodel.h"
 
 namespace mixxx {
 namespace qml {
 
+class QmlChainPresetModel;
+
 class QmlEffectsManagerProxy : public QObject {
     Q_OBJECT
     Q_PROPERTY(mixxx::qml::QmlVisibleEffectsModel* visibleEffectsModel
                     MEMBER m_pVisibleEffectsModel CONSTANT);
+    Q_PROPERTY(mixxx::qml::QmlChainPresetModel* quickChainPresetModel
+                    MEMBER m_pQuickChainPresetModel CONSTANT);
     QML_NAMED_ELEMENT(EffectsManager)
     QML_SINGLETON
 
@@ -34,6 +39,7 @@ class QmlEffectsManagerProxy : public QObject {
 
     const std::shared_ptr<EffectsManager> m_pEffectsManager;
     QmlVisibleEffectsModel* m_pVisibleEffectsModel;
+    QmlChainPresetModel* m_pQuickChainPresetModel;
 };
 
 } // namespace qml
diff --git a/src/shaders/slipmodeshader.cpp b/src/shaders/slipmodeshader.cpp
index 0d29309fb3..d2aa1ddfd8 100644
--- a/src/shaders/slipmodeshader.cpp
+++ b/src/shaders/slipmodeshader.cpp
@@ -25,13 +25,13 @@ varying highp vec4 vposition;
 void main()
 {
 
-    float xBorder = abs(dimension.x * vposition.x);
-    float yBorder = dimension.y * vposition.y;
-    float upperBoard = borders.x;
-    float lowerBoard = borders.y;
+    highp float xBorder = abs(dimension.x * vposition.x);
+    highp float yBorder = dimension.y * vposition.y;
+    highp float upperBoard = borders.x;
+    highp float lowerBoard = borders.y;
 
     if (yBorder < 0.0){
-        float borderAlpha = max(
+        highp float borderAlpha = max(
             0.0, 
             lowerBoard + yBorder
         ) / lowerBoard;
@@ -39,7 +39,7 @@ void main()
 
     } else if( (xBorder > dimension.x - upperBoard && yBorder >= 0.0) || yBorder > dimension.y - upperBoard)
     {
-        float borderAlpha = max(0.0, max(
+        highp float borderAlpha = max(0.0, max(
             yBorder - dimension.y, 
             xBorder - dimension.x) + upperBoard) / upperBoard;
         gl_FragColor = vec4(mix(vec3(0.0, 0.0, 0.0), color.rgb, min(color.w, borderAlpha)), 1.0);
diff --git a/src/skin/legacy/legacyskinparser.cpp b/src/skin/legacy/legacyskinparser.cpp
index 467b928c33..b1c148bab3 100644
--- a/src/skin/legacy/legacyskinparser.cpp
+++ b/src/skin/legacy/legacyskinparser.cpp
@@ -74,6 +74,10 @@
 #include "widget/wsplitter.h"
 #include "widget/wstarrating.h"
 #include "widget/wstatuslight.h"
+#ifdef __STEM__
+#include "engine/engine.h"
+#include "widget/wstemcontrol.h"
+#endif
 #include "widget/wtime.h"
 #include "widget/wtrackproperty.h"
 #include "widget/wtrackwidgetgroup.h"
@@ -117,7 +121,7 @@ ControlObject* LegacySkinParser::controlFromConfigKey(
     // Since the usual behavior here is to create a skin-defined push
     // button, actually make it a push button and set it to toggle.
     ControlPushButton* controlButton = new ControlPushButton(key, bPersist);
-    controlButton->setButtonMode(ControlPushButton::TOGGLE);
+    controlButton->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     if (pCreated) {
         *pCreated = true;
@@ -1021,6 +1025,27 @@ QWidget* LegacySkinParser::parseVisual(const QDomElement& node) {
     WaveformWidgetFactory* pFactory = WaveformWidgetFactory::instance();
     pFactory->setWaveformWidget(viewer, node, *m_pContext);
 
+#ifdef __STEM__
+    DEBUG_ASSERT(viewer->stemControlWidget());
+
+    QDomNode child = node.firstChildElement("StemControl");
+    if (!child.isNull()) {
+        setupSize(child, viewer->stemControlWidget());
+        setupConnections(child, viewer->stemControlWidget());
+        QDomElement stem = child.firstChildElement("Stem");
+        DEBUG_ASSERT(group.endsWith("]"));
+        for (int stemIdx = 1; stemIdx <= mixxx::kMaxSupportedStems; stemIdx++) {
+            m_pContext->setVariable("StemGroup",
+                    QStringLiteral("%1Stem%2]")
+                            .arg(group.left(group.size() - 1),
+                                    QString::number(stemIdx)));
+            auto* pWidget = parseWidgetGroup(stem);
+            setupSize(stem, pWidget);
+            viewer->stemControlWidget()->addControl(pWidget);
+        }
+    }
+#endif
+
     //qDebug() << "::parseVisual: parent" << m_pParent << m_pParent->size();
     //qDebug() << "::parseVisual: viewer" << viewer << viewer->size();
 
@@ -1038,6 +1063,17 @@ QWidget* LegacySkinParser::parseVisual(const QDomElement& node) {
             &BaseTrackPlayer::loadingTrack,
             viewer,
             &WWaveformViewer::slotLoadingTrack);
+#ifdef __STEM__
+    QObject::connect(pPlayer,
+            &BaseTrackPlayer::selectedStem,
+            viewer,
+            &WWaveformViewer::slotSelectStem);
+#endif
+
+    QObject::connect(pPlayer,
+            &BaseTrackPlayer::trackUnloaded,
+            viewer,
+            &WWaveformViewer::slotTrackUnloaded);
 
     connect(viewer,
             &WWaveformViewer::trackDropped,
@@ -1570,6 +1606,10 @@ QWidget* LegacySkinParser::parseLibrary(const QDomElement& node) {
                     BaseTrackTableModel::kKeyColorsEnabledDefault);
     BaseTrackTableModel::setKeyColorsEnabled(keyColorsEnabled);
 
+    ColorPaletteSettings colorPaletteSettings(m_pConfig);
+    ColorPalette colorPalette = colorPaletteSettings.getTrackColorPalette();
+    BaseTrackTableModel::setKeyColorPalette(colorPaletteSettings.getConfigKeyColorPalette());
+
     const auto applyPlayedTrackColor =
             m_pConfig->getValue(
                     mixxx::library::prefs::kApplyPlayedTrackColorConfigKey,
@@ -1732,6 +1772,7 @@ QDomElement LegacySkinParser::loadTemplate(const QString& path) {
 
     if (!templateFile.open(QIODevice::ReadOnly)) {
         qWarning() << "Could not open template file:" << absolutePath;
+        return QDomElement();
     }
 
     QDomDocument tmpl("template");
diff --git a/src/skin/legacy/tooltips.cpp b/src/skin/legacy/tooltips.cpp
index bc033a15ff..13ed08a578 100644
--- a/src/skin/legacy/tooltips.cpp
+++ b/src/skin/legacy/tooltips.cpp
@@ -269,6 +269,11 @@ void Tooltips::addStandardTooltips() {
     add("show_beatgrid_controls")
             << tr("Show/hide the beatgrid controls section");
 
+#ifdef __STEM__
+    add("show_stem_controls")
+            << tr("Show/hide the stem controls section for stem decks");
+#endif
+
     add("show_library")
             << tr("Show Library")
             << tr("Show or hide the track library.");
diff --git a/src/skin/skincontrols.cpp b/src/skin/skincontrols.cpp
index 45e0935c16..7bf2bc49a8 100644
--- a/src/skin/skincontrols.cpp
+++ b/src/skin/skincontrols.cpp
@@ -43,18 +43,18 @@ SkinControls::SkinControls()
           m_showVinylControl(ConfigKey(kSkinGroup, QStringLiteral("show_vinylcontrol")),
                   true,
                   false) {
-    m_showEffectRack.setButtonMode(ControlPushButton::TOGGLE);
-    m_showLibraryCoverArt.setButtonMode(ControlPushButton::TOGGLE);
-    m_showMicrophones.setButtonMode(ControlPushButton::TOGGLE);
-    m_showPreviewDecks.setButtonMode(ControlPushButton::TOGGLE);
-    m_showSamplers.setButtonMode(ControlPushButton::TOGGLE);
-    m_show4EffectUnits.setButtonMode(ControlPushButton::TOGGLE);
-    m_showCoverArt.setButtonMode(ControlPushButton::TOGGLE);
-    m_showMaximizedLibrary.setButtonMode(ControlPushButton::TOGGLE);
-    m_showMixer.setButtonMode(ControlPushButton::TOGGLE);
-    m_showSettings.setButtonMode(ControlPushButton::TOGGLE);
-    m_showSpinnies.setButtonMode(ControlPushButton::TOGGLE);
-    m_showVinylControl.setButtonMode(ControlPushButton::TOGGLE);
+    m_showEffectRack.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showLibraryCoverArt.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showMicrophones.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showPreviewDecks.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showSamplers.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_show4EffectUnits.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showCoverArt.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showMaximizedLibrary.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showMixer.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showSettings.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showSpinnies.setButtonMode(mixxx::control::ButtonMode::Toggle);
+    m_showVinylControl.setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     m_showEffectRack.addAlias(ConfigKey(QStringLiteral("[EffectRack1]"), QStringLiteral("show")));
     m_showLibraryCoverArt.addAlias(ConfigKey(
diff --git a/src/skin/skinloader.cpp b/src/skin/skinloader.cpp
index a91a2fda62..a2795f8b4b 100644
--- a/src/skin/skinloader.cpp
+++ b/src/skin/skinloader.cpp
@@ -230,22 +230,22 @@ void SkinLoader::setupSpinnyCoverControls() {
     m_pShowCover = make_parented<ControlProxy>("[Skin]", "show_coverart", this);
     m_pSelectBigSpinnyCover = std::make_unique<ControlPushButton>(
             ConfigKey("[Skin]", "select_big_spinny_or_cover"), true);
-    m_pSelectBigSpinnyCover->setButtonMode(ControlPushButton::TOGGLE);
+    m_pSelectBigSpinnyCover->setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     // This is 1 if [Skin], show_spinnies == 1 OR [Skin],show_coverart == 1
     m_pShowSpinnyAndOrCover = std::make_unique<ControlPushButton>(
             ConfigKey("[Skin]", "show_spinny_or_cover"));
-    m_pShowSpinnyAndOrCover->setButtonMode(ControlPushButton::TOGGLE);
+    m_pShowSpinnyAndOrCover->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pShowSpinnyAndOrCover->setReadOnly();
     // This is 1 if [Skin],show_spinny_cover == 1 AND [Skin],select_big_spinny_coverart == 0
     m_pShowSmallSpinnyCover = std::make_unique<ControlPushButton>(
             ConfigKey("[Skin]", "show_small_spinny_or_cover"));
-    m_pShowSmallSpinnyCover->setButtonMode(ControlPushButton::TOGGLE);
+    m_pShowSmallSpinnyCover->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pShowSmallSpinnyCover->setReadOnly();
     // This is 1 if [Skin],show_spinny_cover == 1 AND [Skin],select_big_spinny_coverart == 1
     m_pShowBigSpinnyCover = std::make_unique<ControlPushButton>(
             ConfigKey("[Skin]", "show_big_spinny_or_cover"));
-    m_pShowBigSpinnyCover->setButtonMode(ControlPushButton::TOGGLE);
+    m_pShowBigSpinnyCover->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pShowBigSpinnyCover->setReadOnly();
 
     m_pShowSpinny->connectValueChanged(this, &SkinLoader::updateSpinnyCoverControls);
@@ -285,7 +285,7 @@ void SkinLoader::setupMicDuckingControls() {
     // This is 1 if at least one microphone device is configured
     m_pShowDuckingControls = std::make_unique<ControlPushButton>(
             ConfigKey("[Skin]", "show_ducking_controls"));
-    m_pShowDuckingControls->setButtonMode(ControlPushButton::TOGGLE);
+    m_pShowDuckingControls->setButtonMode(mixxx::control::ButtonMode::Toggle);
     m_pShowDuckingControls->setReadOnly();
 
     m_pNumMics = make_parented<ControlProxy>(
diff --git a/src/sources/audiosource.h b/src/sources/audiosource.h
index 8c007848d2..4284bff1b5 100644
--- a/src/sources/audiosource.h
+++ b/src/sources/audiosource.h
@@ -193,24 +193,56 @@ class AudioSource : public UrlResource, public virtual /*implements*/ IAudioSour
     // Parameters for opening audio sources
     class OpenParams {
       public:
+#ifdef __STEM__
+        OpenParams()
+                : m_signalInfo(), m_stemIdx(mixxx::kNoStemSelectedIdx) {
+        }
+#else
         OpenParams() = default;
+#endif
         OpenParams(
                 audio::ChannelCount channelCount,
-                audio::SampleRate sampleRate)
+                audio::SampleRate sampleRate
+#ifdef __STEM__
+                ,
+                uint stemIdx = mixxx::kNoStemSelectedIdx
+#endif
+                )
                 : m_signalInfo(
                           channelCount,
-                          sampleRate) {
+                          sampleRate)
+#ifdef __STEM__
+                  ,
+                  m_stemIdx(stemIdx)
+#endif
+        {
         }
 
         const audio::SignalInfo& getSignalInfo() const {
             return m_signalInfo;
         }
 
+#ifdef __STEM__
+        uint stemIdx() const {
+            return m_stemIdx;
+        }
+#endif
+
         void setChannelCount(
                 audio::ChannelCount channelCount) {
             m_signalInfo.setChannelCount(channelCount);
         }
 
+#ifdef __STEM__
+        void setStemIdx(
+                uint stemIdx) {
+            VERIFY_OR_DEBUG_ASSERT(stemIdx <= mixxx::kMaxSupportedStems) {
+                return;
+            }
+            m_stemIdx = stemIdx;
+        }
+#endif
+
         void setSampleRate(
                 audio::SampleRate sampleRate) {
             m_signalInfo.setSampleRate(sampleRate);
@@ -218,6 +250,9 @@ class AudioSource : public UrlResource, public virtual /*implements*/ IAudioSour
 
       private:
         audio::SignalInfo m_signalInfo;
+#ifdef __STEM__
+        uint m_stemIdx;
+#endif
     };
 
     // Opens the AudioSource for reading audio data.
diff --git a/src/sources/soundsourcestem.cpp b/src/sources/soundsourcestem.cpp
index 76105135f2..c4e6edef9d 100644
--- a/src/sources/soundsourcestem.cpp
+++ b/src/sources/soundsourcestem.cpp
@@ -323,6 +323,12 @@ SoundSource::OpenResult SoundSourceSTEM::tryOpen(
 
     AVStream* firstAudioStream = nullptr;
     int stemCount = 0;
+    uint selectedStem = params.stemIdx();
+    VERIFY_OR_DEBUG_ASSERT(selectedStem <= mixxx::kMaxSupportedStems) {
+        kLogger.warning().noquote()
+                << "Invalid selected stem Idx" << selectedStem;
+        return OpenResult::Failed;
+    }
     OpenParams stemParam = params;
     stemParam.setChannelCount(mixxx::audio::ChannelCount::stereo());
     for (unsigned int streamIdx = 0; streamIdx < pavInputFormatContext->nb_streams; streamIdx++) {
@@ -365,6 +371,10 @@ SoundSource::OpenResult SoundSourceSTEM::tryOpen(
             stemCount++;
         }
 
+        if (selectedStem && selectedStem != streamIdx) {
+            continue;
+        }
+
         m_pStereoStreams.emplace_back(std::make_unique<SoundSourceSingleSTEM>(getUrl(), streamIdx));
         if (m_pStereoStreams.back()->open(OpenMode::Strict /*Unused*/,
                     stemParam) != OpenResult::Succeeded) {
@@ -380,7 +390,9 @@ SoundSource::OpenResult SoundSourceSTEM::tryOpen(
         return OpenResult::Failed;
     }
 
-    if (params.getSignalInfo().getChannelCount() == mixxx::audio::ChannelCount::stereo()) {
+    if (params.getSignalInfo().getChannelCount() ==
+                    mixxx::audio::ChannelCount::stereo() ||
+            selectedStem) {
         // Requesting a stereo stream (used for samples and preview decks)
         m_requestedChannelCount = mixxx::audio::ChannelCount::stereo();
         initChannelCountOnce(mixxx::audio::ChannelCount::stereo());
@@ -434,12 +446,17 @@ ReadableSampleFrames SoundSourceSTEM::readSampleFramesClamped(
     int stemCount = m_pStereoStreams.size();
     CSAMPLE* pBuffer = globalSampleFrames.writableData();
 
-    if (m_requestedChannelCount == mixxx::audio::ChannelCount::stereo()) {
+    if (m_requestedChannelCount == mixxx::audio::ChannelCount::stereo() && stemCount != 1) {
         SampleUtil::clear(pBuffer, globalSampleFrames.writableLength());
     } else {
         DEBUG_ASSERT(stemSampleLength * stemCount == globalSampleFrames.writableLength());
     }
 
+    if (stemCount == 1) {
+        m_pStereoStreams[0]->readSampleFrames(globalSampleFrames);
+        return read;
+    }
+
     for (int streamIdx = 0; streamIdx < stemCount; streamIdx++) {
         WritableSampleFrames currentStemFrame = WritableSampleFrames(
                 globalSampleFrames.frameIndexRange(),
diff --git a/src/test/autodjprocessor_test.cpp b/src/test/autodjprocessor_test.cpp
index 4cebd3b7b9..56a1af6b00 100644
--- a/src/test/autodjprocessor_test.cpp
+++ b/src/test/autodjprocessor_test.cpp
@@ -33,7 +33,7 @@ class FakeMixer {
     FakeMixer()
             : crossfader(ConfigKey("[Master]", "crossfader"), -1.0, 1.0),
               crossfaderReverse(ConfigKey("[Mixer Profile]", "xFaderReverse")) {
-        crossfaderReverse.setButtonMode(ControlPushButton::TOGGLE);
+        crossfaderReverse.setButtonMode(mixxx::control::ButtonMode::Toggle);
     }
 
     ControlPotmeter crossfader;
@@ -55,8 +55,8 @@ class FakeDeck : public BaseTrackPlayer {
               outroStartPos(ConfigKey(group, "outro_start_position")),
               outroEndPos(ConfigKey(group, "outro_end_position")),
               orientation(ConfigKey(group, "orientation")) {
-        play.setButtonMode(ControlPushButton::TOGGLE);
-        repeat.setButtonMode(ControlPushButton::TOGGLE);
+        play.setButtonMode(mixxx::control::ButtonMode::Toggle);
+        repeat.setButtonMode(mixxx::control::ButtonMode::Toggle);
         outroStartPos.set(Cue::kNoPosition);
         outroEndPos.set(Cue::kNoPosition);
         orientation.set(orient);
@@ -94,7 +94,11 @@ class FakeDeck : public BaseTrackPlayer {
     // a success or failure signal. To simulate a load success, call
     // fakeTrackLoadedEvent. To simulate a failure, call
     // fakeTrackLoadFailedEvent.
-    void slotLoadTrack(TrackPointer pTrack, bool bPlay) override {
+    void slotLoadTrack(TrackPointer pTrack,
+#ifdef __STEM__
+            uint,
+#endif
+            bool bPlay) override {
         loadedTrack = pTrack;
         samplerate.set(pTrack->getSampleRate());
         play.set(bPlay);
@@ -263,7 +267,11 @@ TEST_F(AutoDJProcessorTest, FullIntroOutro_LongerIntro) {
     // Pretend that track is 1 minute and 40 seconds long.
     pTrack->setDuration(100);
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -280,7 +288,11 @@ TEST_F(AutoDJProcessorTest, FullIntroOutro_LongerIntro) {
     EXPECT_EQ(AutoDJProcessor::ADJ_IDLE, pProcessor->getState());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
 
     // Set intro + outro cues. Outro is 10 seconds long; intro is 30 seconds.
     const double kSamplesPerSecond = kChannelCount * pTrack->getSampleRate();
@@ -337,7 +349,11 @@ TEST_F(AutoDJProcessorTest, FullIntroOutro_LongerOutro) {
     // Pretend that track is 1 minute and 40 seconds long.
     pTrack->setDuration(100);
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -354,7 +370,11 @@ TEST_F(AutoDJProcessorTest, FullIntroOutro_LongerOutro) {
     EXPECT_EQ(AutoDJProcessor::ADJ_IDLE, pProcessor->getState());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
 
     // Set intro + outro cues. Outro is 20 seconds long; intro is 10 seconds.
     const double kSamplesPerSecond = kChannelCount * pTrack->getSampleRate();
@@ -417,7 +437,11 @@ TEST_F(AutoDJProcessorTest, FadeAtOutroStart_LongerIntro) {
     // Pretend that track is 1 minute and 40 seconds long.
     pTrack->setDuration(100);
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -434,7 +458,11 @@ TEST_F(AutoDJProcessorTest, FadeAtOutroStart_LongerIntro) {
     EXPECT_EQ(AutoDJProcessor::ADJ_IDLE, pProcessor->getState());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
 
     // Set intro + outro cues. Outro is 10 seconds long; intro is 20 seconds.
     const double kSamplesPerSecond = kChannelCount * pTrack->getSampleRate();
@@ -493,7 +521,11 @@ TEST_F(AutoDJProcessorTest, FadeAtOutroStart_LongerOutro) {
     // Pretend that track is 1 minute and 40 seconds long.
     pTrack->setDuration(100);
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -510,7 +542,11 @@ TEST_F(AutoDJProcessorTest, FadeAtOutroStart_LongerOutro) {
     EXPECT_EQ(AutoDJProcessor::ADJ_IDLE, pProcessor->getState());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
 
     // Set intro + outro cues. Outro is 20 seconds long; intro is 10 seconds.
     const double kSamplesPerSecond = kChannelCount * pTrack->getSampleRate();
@@ -640,7 +676,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_DecksStopped) {
     // Load the track and mark it playing (as the loadTrackToPlayer signal would
     // have connected to this eventually).
     TrackPointer pTrack = trackCollectionManager()->getTrackById(testId);
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
 
     // Signal that the request to load pTrack succeeded.
     deck1.fakeTrackLoadedEvent(pTrack);
@@ -686,7 +726,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_DecksStopped_TrackLoadFails) {
     // Load the track and mark it playing (as the loadTrackToPlayer signal would
     // have connected to this eventually).
     TrackPointer pTrack(newTestTrack(testId));
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
 
     // Signal that the request to load pTrack failed.
     deck1.fakeTrackLoadFailedEvent(pTrack);
@@ -704,7 +748,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_DecksStopped_TrackLoadFails) {
     EXPECT_DOUBLE_EQ(0.0, deck2.play.get());
 
     // Now pretend that the follow-up load request succeeded.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     deck1.fakeTrackLoadedEvent(pTrack);
 
     // Expect that we will receive a load call for [Channel2] after we get the
@@ -752,7 +800,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_DecksStopped_TrackLoadFailsRightDeck)
     // Load the track and mark it playing (as the loadTrackToPlayer signal would
     // have connected to this eventually).
     TrackPointer pTrack(newTestTrack(testId));
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
 
     // Signal that the request to load pTrack to deck1 succeeded.
     deck1.fakeTrackLoadedEvent(pTrack);
@@ -776,14 +828,22 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_DecksStopped_TrackLoadFailsRightDeck)
     EXPECT_CALL(*pProcessor, emitLoadTrackToPlayer(_, QString("[Channel2]"), false));
 
     // Now pretend that the deck2 load request failed.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadFailedEvent(pTrack);
 
     // Check that we are still in ADJ_IDLE mode.
     EXPECT_EQ(AutoDJProcessor::ADJ_IDLE, pProcessor->getState());
 
     // Pretend the deck2 load request succeeded.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // Check that we are still in ADJ_IDLE mode and the left deck is playing.
@@ -800,7 +860,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck1) {
     // Pretend a track is playing on deck 1.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -822,7 +886,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck1) {
     EXPECT_DOUBLE_EQ(0.0, deck2.play.get());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader or play states.
@@ -839,7 +907,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck1_TrackLoadFailed) {
     // Pretend a track is playing on deck 1.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -868,7 +940,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck1_TrackLoadFailed) {
     EXPECT_CALL(*pProcessor, emitLoadTrackToPlayer(_, QString("[Channel2]"), false));
 
     // Pretend the track load fails.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadFailedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -878,7 +954,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck1_TrackLoadFailed) {
     EXPECT_DOUBLE_EQ(0.0, deck2.play.get());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -895,7 +975,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck2) {
     // Pretend a track is playing on deck 2.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck2.slotLoadTrack(pTrack, true);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck2.fakeTrackLoadedEvent(pTrack);
 
@@ -918,7 +1002,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck2) {
     EXPECT_DOUBLE_EQ(1.0, deck2.play.get());
 
     // Pretend the track load succeeds.
-    deck1.slotLoadTrack(pTrack, false);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck1.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader or play states.
@@ -935,7 +1023,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck2_TrackLoadFailed) {
     // Pretend a track is playing on deck 2.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck2.slotLoadTrack(pTrack, true);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck2.fakeTrackLoadedEvent(pTrack);
 
@@ -964,7 +1056,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck2_TrackLoadFailed) {
     EXPECT_CALL(*pProcessor, emitLoadTrackToPlayer(_, QString("[Channel1]"), false));
 
     // Pretend the track load fails.
-    deck1.slotLoadTrack(pTrack, false);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck1.fakeTrackLoadFailedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -974,7 +1070,11 @@ TEST_F(AutoDJProcessorTest, EnabledSuccess_PlayingDeck2_TrackLoadFailed) {
     EXPECT_DOUBLE_EQ(1.0, deck2.play.get());
 
     // Pretend the track load succeeds.
-    deck1.slotLoadTrack(pTrack, false);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck1.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -1009,7 +1109,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck1_LoadOnDeck2_TrackLoadSuccess) {
     // Pretend a track is playing on deck 2.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck2.slotLoadTrack(pTrack, true);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck2.fakeTrackLoadedEvent(pTrack);
 
@@ -1034,7 +1138,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck1_LoadOnDeck2_TrackLoadSuccess) {
     EXPECT_DOUBLE_EQ(1.0, deck2.play.get());
 
     // Pretend the track load succeeds.
-    deck1.slotLoadTrack(pTrack, false);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck1.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader or play states.
@@ -1077,7 +1185,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck1_LoadOnDeck2_TrackLoadSuccess) {
     EXPECT_DOUBLE_EQ(0.0, deck2.play.get());
 
     // Pretend the track load request succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -1096,7 +1208,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck1_LoadOnDeck2_TrackLoadFailed) {
     // Pretend a track is playing on deck 2.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck2.slotLoadTrack(pTrack, true);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck2.fakeTrackLoadedEvent(pTrack);
 
@@ -1123,7 +1239,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck1_LoadOnDeck2_TrackLoadFailed) {
     EXPECT_DOUBLE_EQ(1.0, deck2.play.get());
 
     // Pretend the track load succeeds.
-    deck1.slotLoadTrack(pTrack, false);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck1.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader or play states.
@@ -1170,7 +1290,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck1_LoadOnDeck2_TrackLoadFailed) {
     EXPECT_CALL(*pProcessor, emitLoadTrackToPlayer(_, QString("[Channel2]"), false));
 
     // Pretend the track load request fails.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadFailedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -1180,7 +1304,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck1_LoadOnDeck2_TrackLoadFailed) {
     EXPECT_DOUBLE_EQ(0.0, deck2.play.get());
 
     // Pretend the second track load request succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -1199,7 +1327,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_LoadOnDeck1_TrackLoadSuccess) {
     // Pretend a track is playing on deck 1.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -1224,7 +1356,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_LoadOnDeck1_TrackLoadSuccess) {
     EXPECT_DOUBLE_EQ(0.0, deck2.play.get());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader or play states.
@@ -1267,7 +1403,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_LoadOnDeck1_TrackLoadSuccess) {
     EXPECT_DOUBLE_EQ(1.0, deck2.play.get());
 
     // Pretend the track load request succeeds.
-    deck1.slotLoadTrack(pTrack, false);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck1.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -1286,7 +1426,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_LoadOnDeck1_TrackLoadFailed) {
     // Pretend a track is playing on deck 1.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -1313,7 +1457,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_LoadOnDeck1_TrackLoadFailed) {
     EXPECT_DOUBLE_EQ(0.0, deck2.play.get());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader or play states.
@@ -1360,7 +1508,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_LoadOnDeck1_TrackLoadFailed) {
     EXPECT_CALL(*pProcessor, emitLoadTrackToPlayer(_, QString("[Channel1]"), false));
 
     // Pretend the track load request fails.
-    deck1.slotLoadTrack(pTrack, false);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck1.fakeTrackLoadFailedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -1370,7 +1522,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_LoadOnDeck1_TrackLoadFailed) {
     EXPECT_DOUBLE_EQ(1.0, deck2.play.get());
 
     // Pretend the track load request succeeds.
-    deck1.slotLoadTrack(pTrack, false);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck1.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader, or play states.
@@ -1392,7 +1548,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_Long_Transition) {
     // Pretend a track is playing on deck 1.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -1409,7 +1569,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_Long_Transition) {
     EXPECT_EQ(AutoDJProcessor::ADJ_IDLE, pProcessor->getState());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // Set a long transition time
@@ -1481,7 +1645,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_Pause_Transition) {
     // Pretend that track is 2 minutes long.
     pTrack->setDuration(120);
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -1497,7 +1665,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_Pause_Transition) {
     EXPECT_EQ(AutoDJProcessor::ADJ_IDLE, pProcessor->getState());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // The track should have been cued at 0.0.
@@ -1511,7 +1683,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_Pause_Transition) {
     EXPECT_DOUBLE_EQ(0.0, deck2.playposition.get());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // The newly loaded track should have been seeked back by the trackSamples of transition.
@@ -1561,7 +1737,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_SeekEnd) {
     // Pretend a track is playing on deck 1.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -1578,7 +1758,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_SeekEnd) {
     EXPECT_EQ(AutoDJProcessor::ADJ_IDLE, pProcessor->getState());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader or play states.
@@ -1613,7 +1797,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_SeekBeforeTransition) {
     // Pretend a track is playing on deck 1.
     TrackPointer pTrack = newTestTrack();
     // Load track and mark it playing.
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
     // Indicate the track loaded successfully.
     deck1.fakeTrackLoadedEvent(pTrack);
 
@@ -1630,7 +1818,11 @@ TEST_F(AutoDJProcessorTest, FadeToDeck2_SeekBeforeTransition) {
     EXPECT_EQ(AutoDJProcessor::ADJ_IDLE, pProcessor->getState());
 
     // Pretend the track load succeeds.
-    deck2.slotLoadTrack(pTrack, false);
+    deck2.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     deck2.fakeTrackLoadedEvent(pTrack);
 
     // No change to the mode, crossfader or play states.
@@ -1689,7 +1881,11 @@ TEST_F(AutoDJProcessorTest, TrackZeroLength) {
     // have connected to this eventually).
     TrackPointer pTrack(newTestTrack(testId));
     pTrack->setDuration(0);
-    deck1.slotLoadTrack(pTrack, true);
+    deck1.slotLoadTrack(pTrack,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            true);
 
     // Expect that the track is rejected an a new one is loaded
     // Signal that the request to load pTrack succeeded.
diff --git a/src/test/controller_mapping_file_handler_test.cpp b/src/test/controller_mapping_file_handler_test.cpp
index 57dd8594f3..1fe26a79a8 100644
--- a/src/test/controller_mapping_file_handler_test.cpp
+++ b/src/test/controller_mapping_file_handler_test.cpp
@@ -13,6 +13,7 @@
 
 using ::testing::_;
 using ::testing::FieldsAre;
+using namespace std::chrono_literals;
 
 class LegacyControllerMappingFileHandlerTest
         : public LegacyControllerMappingFileHandler,
@@ -20,7 +21,7 @@ class LegacyControllerMappingFileHandlerTest
   public:
     void SetUp() override {
         mixxx::Time::setTestMode(true);
-        mixxx::Time::setTestElapsedTime(mixxx::Duration::fromMillis(10));
+        mixxx::Time::addTestTime(10ms);
         SETUP_LOG_CAPTURE();
     }
 
diff --git a/src/test/controllerrenderingengine_test.cpp b/src/test/controllerrenderingengine_test.cpp
index 864497861f..885ae68df1 100644
--- a/src/test/controllerrenderingengine_test.cpp
+++ b/src/test/controllerrenderingengine_test.cpp
@@ -12,12 +12,13 @@
 #include "test/mixxxtest.h"
 
 using ::testing::_;
+using namespace std::chrono_literals;
 
 class ControllerRenderingEngineTest : public MixxxTest {
   public:
     void SetUp() override {
         mixxx::Time::setTestMode(true);
-        mixxx::Time::setTestElapsedTime(mixxx::Duration::fromMillis(10));
+        mixxx::Time::addTestTime(10ms);
         SETUP_LOG_CAPTURE();
     }
 
diff --git a/src/test/controllers/controller_columnid_regression_test.cpp b/src/test/controllers/controller_columnid_regression_test.cpp
index 09c8f0d677..7eac444818 100644
--- a/src/test/controllers/controller_columnid_regression_test.cpp
+++ b/src/test/controllers/controller_columnid_regression_test.cpp
@@ -13,11 +13,13 @@
 #include "test/mixxxtest.h"
 #include "util/time.h"
 
+using namespace std::chrono_literals;
+
 class ControllerLibraryColumnIDRegressionTest : public MixxxTest {
   protected:
     void SetUp() override {
         mixxx::Time::setTestMode(true);
-        mixxx::Time::setTestElapsedTime(mixxx::Duration::fromMillis(10));
+        mixxx::Time::addTestTime(10ms);
     }
 
     void TearDown() override {
diff --git a/src/test/controllerscriptenginelegacy_test.cpp b/src/test/controllerscriptenginelegacy_test.cpp
index 9fd4c5e34f..2e02368922 100644
--- a/src/test/controllerscriptenginelegacy_test.cpp
+++ b/src/test/controllerscriptenginelegacy_test.cpp
@@ -26,6 +26,7 @@
 #include "util/time.h"
 
 using ::testing::_;
+using namespace std::chrono_literals;
 
 typedef std::unique_ptr<QTemporaryFile> ScopedTemporaryFile;
 
@@ -47,7 +48,7 @@ class ControllerScriptEngineLegacyTest : public ControllerScriptEngineLegacy, pu
 
     void SetUp() override {
         mixxx::Time::setTestMode(true);
-        mixxx::Time::setTestElapsedTime(mixxx::Duration::fromMillis(10));
+        mixxx::Time::addTestTime(10ms);
         QThread::currentThread()->setObjectName("Main");
         initialize();
     }
@@ -209,7 +210,7 @@ TEST_F(ControllerScriptEngineLegacyTest, softTakeover_setValue) {
     EXPECT_DOUBLE_EQ(-10.0, co->get());
 
     // Advance time to 2x the threshold.
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
 
     // Change the control internally (putting it out of sync with the
     // ControllerEngine).
@@ -240,8 +241,7 @@ TEST_F(ControllerScriptEngineLegacyTest, softTakeover_setParameter) {
     EXPECT_TRUE(evaluateAndAssert("engine.setParameter('[Test]', 'co', 0.0);"));
     EXPECT_DOUBLE_EQ(-10.0, co->get());
 
-    // Advance time to 2x the threshold.
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
 
     // Change the control internally (putting it out of sync with the
     // ControllerEngine).
diff --git a/src/test/controlobjectscripttest.cpp b/src/test/controlobjectscripttest.cpp
index ada000c19c..0da96f86b6 100644
--- a/src/test/controlobjectscripttest.cpp
+++ b/src/test/controlobjectscripttest.cpp
@@ -199,7 +199,8 @@ TEST_F(ControlObjectScriptTest, CompressingProxyCompareValueMulti) {
 }
 
 TEST_F(ControlObjectScriptTest, CompressingProxyMultiConnection) {
-    // Check that slotValueChanged callback is called 1 time if multiple connections exist forthe same slot
+    // Check that slotValueChanged callback is called 1 time if multiple
+    // connections exist for the same slot
     EXPECT_CALL(*coScript1, slotValueChanged(32.0, _))
             .Times(1)
             .WillOnce(Return());
@@ -218,7 +219,8 @@ TEST_F(ControlObjectScriptTest, CompressingProxyMultiConnection) {
 }
 
 TEST_F(ControlObjectScriptTest, QueuedFallbackMultiConnection) {
-    // Check that slotValueChanged callback is called 1 time if multiple connections exist forthe same slot
+    // Check that slotValueChanged callback is called 1 time if multiple
+    // connections exist for the same slot
     EXPECT_CALL(*coScript1, slotValueChanged(62.0, _))
             .Times(1)
             .WillOnce(Return());
diff --git a/src/test/cuecontrol_test.cpp b/src/test/cuecontrol_test.cpp
index 5666a9bf28..399f983f1c 100644
--- a/src/test/cuecontrol_test.cpp
+++ b/src/test/cuecontrol_test.cpp
@@ -48,7 +48,11 @@ class CueControlTest : public BaseSignalPathTest {
     }
 
     void unloadTrack() {
-        m_pMixerDeck1->slotLoadTrack(TrackPointer(), false);
+        m_pMixerDeck1->slotLoadTrack(TrackPointer(),
+#ifdef __STEM__
+                mixxx::kNoStemSelectedIdx,
+#endif
+                false);
     }
 
     mixxx::audio::FramePos getCurrentFramePos() {
diff --git a/src/test/hotcuecontrol_test.cpp b/src/test/hotcuecontrol_test.cpp
index 73eca9f01f..df13f131dd 100644
--- a/src/test/hotcuecontrol_test.cpp
+++ b/src/test/hotcuecontrol_test.cpp
@@ -79,7 +79,11 @@ class HotcueControlTest : public BaseSignalPathTest {
     }
 
     void unloadTrack() {
-        m_pMixerDeck1->slotLoadTrack(TrackPointer(), false);
+        m_pMixerDeck1->slotLoadTrack(TrackPointer(),
+#ifdef __STEM__
+                mixxx::kNoStemSelectedIdx,
+#endif
+                false);
     }
 
     mixxx::audio::FramePos currentFramePosition() {
diff --git a/src/test/looping_control_test.cpp b/src/test/looping_control_test.cpp
index 3f444c4954..8a543b82c4 100644
--- a/src/test/looping_control_test.cpp
+++ b/src/test/looping_control_test.cpp
@@ -1253,7 +1253,7 @@ TEST_F(LoopingControlTest, LoopResizeUsingAnchor) {
 
     ProcessBuffer();
 
-    // The loop is resized its end oint this time
+    // The loop is resized and its end joint this time
     EXPECT_FRAMEPOS_EQ_CONTROL(mixxx::audio::FramePos{175}, m_pLoopStartPoint);
     EXPECT_FRAMEPOS_EQ_CONTROL(mixxx::audio::FramePos{625}, m_pLoopEndPoint);
     ProcessBuffer();
diff --git a/src/test/metaknob_link_test.cpp b/src/test/metaknob_link_test.cpp
index 0e589624e8..beffd52e78 100644
--- a/src/test/metaknob_link_test.cpp
+++ b/src/test/metaknob_link_test.cpp
@@ -13,13 +13,14 @@
 #include "test/baseeffecttest.h"
 #include "util/time.h"
 
+using namespace std::chrono_literals;
+
 class MetaLinkTest : public BaseEffectTest {
   protected:
     MetaLinkTest()
             : m_main(m_factory.getOrCreateHandle("[Master]"), "[Master]"),
               m_headphone(m_factory.getOrCreateHandle("[Headphone]"), "[Headphone]") {
         mixxx::Time::setTestMode(true);
-        mixxx::Time::setTestElapsedTime(mixxx::Duration::fromNanos(0));
         m_pEffectsManager->registerInputChannel(m_main);
         m_pEffectsManager->registerInputChannel(m_headphone);
         registerTestBackend();
@@ -126,8 +127,7 @@ TEST_F(MetaLinkTest, MetaToParameter_Softtakeover_EffectEnabled) {
     m_pControlValue->set(0.0);
 
     // Let enough time pass by to exceed soft-takeover's override interval.
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() +
-            mixxx::Duration::fromMillis(2));
+    advanceTimePastThreshold(2ms);
 
     // Ignored by SoftTakeover since it is too far from the current
     // parameter value of 0.0.
@@ -148,8 +148,7 @@ TEST_F(MetaLinkTest, MetaToParameter_Softtakeover_EffectDisabled) {
     m_pControlValue->set(0.0);
 
     // Let enough time pass by to exceed soft-takeover's override interval.
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() +
-            mixxx::Duration::fromMillis(2));
+    advanceTimePastThreshold(2ms);
 
     m_pEffectSlot->slotEffectMetaParameter(1.0, false);
     EXPECT_EQ(1.0, m_pControlValue->get());
@@ -166,8 +165,7 @@ TEST_F(MetaLinkTest, SuperToMeta_Softtakeover_EffectEnabled) {
     m_pEffectSlot->setMetaParameter(1.0, true);
 
     // Let enough time pass by to exceed soft-takeover's override interval.
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() +
-            mixxx::Duration::fromMillis(2));
+    advanceTimePastThreshold(2ms);
 
     // Ignored by SoftTakeover since it is too far from the current
     // metaknob value of 1.0.
@@ -185,8 +183,7 @@ TEST_F(MetaLinkTest, SuperToMeta_Softtakeover_EffectDisabled) {
     m_pEffectSlot->setMetaParameter(1.0, true);
 
     // Let enough time pass by to exceed soft-takeover's override interval.
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() +
-            mixxx::Duration::fromMillis(2));
+    advanceTimePastThreshold(2ms);
 
     m_pChainSlot->setSuperParameter(0.0);
     EXPECT_EQ(0.0, m_pEffectSlot->getMetaParameter());
diff --git a/src/test/midicontrollertest.cpp b/src/test/midicontrollertest.cpp
index 17488adcdb..83811eb5fe 100644
--- a/src/test/midicontrollertest.cpp
+++ b/src/test/midicontrollertest.cpp
@@ -262,7 +262,7 @@ TEST_F(MidiControllerTest, ReceiveMessage_ToggleCO_PushOnOff) {
     // (NOTE_OFF, 0x00) for release.
     ConfigKey key("[Channel1]", "keylock");
     ControlPushButton cpb(key);
-    cpb.setButtonMode(ControlPushButton::TOGGLE);
+    cpb.setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     unsigned char channel = 0x01;
     unsigned char control = 0x10;
@@ -297,7 +297,7 @@ TEST_F(MidiControllerTest, ReceiveMessage_ToggleCO_PushOnOn) {
     // (NOTE_ON, 0x00) for release.
     ConfigKey key("[Channel1]", "keylock");
     ControlPushButton cpb(key);
-    cpb.setButtonMode(ControlPushButton::TOGGLE);
+    cpb.setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     unsigned char channel = 0x01;
     unsigned char control = 0x10;
@@ -327,7 +327,7 @@ TEST_F(MidiControllerTest, ReceiveMessage_ToggleCO_ToggleOnOff_ButtonMidiOption)
     // push button.
     ConfigKey key("[Channel1]", "keylock");
     ControlPushButton cpb(key);
-    cpb.setButtonMode(ControlPushButton::TOGGLE);
+    cpb.setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     unsigned char channel = 0x01;
     unsigned char control = 0x10;
@@ -367,7 +367,7 @@ TEST_F(MidiControllerTest, ReceiveMessage_ToggleCO_ToggleOnOff_SwitchMidiOption)
     // button rather than a momentary push button.
     ConfigKey key("[Channel1]", "keylock");
     ControlPushButton cpb(key);
-    cpb.setButtonMode(ControlPushButton::TOGGLE);
+    cpb.setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     unsigned char channel = 0x01;
     unsigned char control = 0x10;
@@ -423,7 +423,7 @@ TEST_F(MidiControllerTest, ReceiveMessage_ToggleCO_PushCC) {
     // as (CC, 0x7f) for press and (CC, 0x00) for release.
     ConfigKey key("[Channel1]", "keylock");
     ControlPushButton cpb(key);
-    cpb.setButtonMode(ControlPushButton::TOGGLE);
+    cpb.setButtonMode(mixxx::control::ButtonMode::Toggle);
 
     unsigned char channel = 0x01;
     unsigned char control = 0x10;
diff --git a/src/test/playermanagertest.cpp b/src/test/playermanagertest.cpp
index a0f8ac2d36..ba5fd028b4 100644
--- a/src/test/playermanagertest.cpp
+++ b/src/test/playermanagertest.cpp
@@ -148,7 +148,11 @@ TEST_F(PlayerManagerTest, UnEjectTest) {
     ASSERT_NE(nullptr, pTrack1);
     TrackId testId1 = pTrack1->getId();
     ASSERT_TRUE(testId1.isValid());
-    deck1->slotLoadTrack(pTrack1, false);
+    deck1->slotLoadTrack(pTrack1,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     ASSERT_NE(nullptr, deck1->getLoadedTrack());
 
     m_pEngine->process(1024);
@@ -161,7 +165,11 @@ TEST_F(PlayerManagerTest, UnEjectTest) {
     // Load another track.
     TrackPointer pTrack2 = getOrAddTrackByLocation(getTestDir().filePath(kTrackLocationTest2));
     ASSERT_NE(nullptr, pTrack2);
-    deck1->slotLoadTrack(pTrack2, false);
+    deck1->slotLoadTrack(pTrack2,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
 
     // Ejecting in an empty deck loads the last-ejected track.
     auto deck2 = m_pPlayerManager->getDeck(2);
@@ -182,7 +190,11 @@ TEST_F(PlayerManagerTest, UnEjectReplaceTrackTest) {
     ASSERT_NE(nullptr, pTrack1);
     TrackId testId1 = pTrack1->getId();
     ASSERT_TRUE(testId1.isValid());
-    deck1->slotLoadTrack(pTrack1, false);
+    deck1->slotLoadTrack(pTrack1,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     ASSERT_NE(nullptr, deck1->getLoadedTrack());
 
     m_pEngine->process(1024);
@@ -191,7 +203,11 @@ TEST_F(PlayerManagerTest, UnEjectReplaceTrackTest) {
     // Load another track, replacing the first, causing it to be unloaded.
     TrackPointer pTrack2 = getOrAddTrackByLocation(getTestDir().filePath(kTrackLocationTest2));
     ASSERT_NE(nullptr, pTrack2);
-    deck1->slotLoadTrack(pTrack2, false);
+    deck1->slotLoadTrack(pTrack2,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     m_pEngine->process(1024);
     waitForTrackToBeLoaded(deck1);
 
@@ -227,7 +243,11 @@ TEST_F(PlayerManagerTest, UnReplaceTest) {
     ASSERT_NE(nullptr, pTrack1);
     TrackId testId1 = pTrack1->getId();
     ASSERT_TRUE(testId1.isValid());
-    deck1->slotLoadTrack(pTrack1, false);
+    deck1->slotLoadTrack(pTrack1,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     m_pEngine->process(1024);
     waitForTrackToBeLoaded(deck1);
     ASSERT_NE(nullptr, deck1->getLoadedTrack());
@@ -235,7 +255,11 @@ TEST_F(PlayerManagerTest, UnReplaceTest) {
     // Load another track.
     TrackPointer pTrack2 = getOrAddTrackByLocation(getTestDir().filePath(kTrackLocationTest2));
     ASSERT_NE(nullptr, pTrack2);
-    deck1->slotLoadTrack(pTrack2, false);
+    deck1->slotLoadTrack(pTrack2,
+#ifdef __STEM__
+            mixxx::kNoStemSelectedIdx,
+#endif
+            false);
     m_pEngine->process(1024);
     waitForTrackToBeLoaded(deck1);
     ASSERT_NE(nullptr, deck1->getLoadedTrack());
diff --git a/src/test/signalpathtest.h b/src/test/signalpathtest.h
index a1d4926bfd..e7ee5830e0 100644
--- a/src/test/signalpathtest.h
+++ b/src/test/signalpathtest.h
@@ -169,7 +169,11 @@ class BaseSignalPathTest : public MixxxTest, SoundSourceProviderRegistration {
         if (pEngineDeck->getEngineBuffer()->isTrackLoaded()) {
             pEngineDeck->getEngineBuffer()->ejectTrack();
         }
-        pDeck->slotLoadTrack(pTrack, false);
+        pDeck->slotLoadTrack(pTrack,
+#ifdef __STEM__
+                mixxx::kNoStemSelectedIdx,
+#endif
+                false);
 
         // Wait for the track to load.
         ProcessBuffer();
diff --git a/src/test/softtakeover_test.cpp b/src/test/softtakeover_test.cpp
index f35d546f5a..bb08fb2475 100644
--- a/src/test/softtakeover_test.cpp
+++ b/src/test/softtakeover_test.cpp
@@ -2,23 +2,21 @@
 
 #include <gtest/gtest.h>
 
-#include <QScopedPointer>
-#include <QtDebug>
-#include <memory>
+#include <gsl/pointers>
 
 #include "control/controlpotmeter.h"
-#include "control/controlpushbutton.h"
-#include "preferences/usersettings.h"
 #include "test/mixxxtest.h"
 #include "util/time.h"
 
 namespace {
 
+using namespace std::chrono_literals;
+
 class SoftTakeoverTest : public MixxxTest {
   protected:
     void SetUp() override {
         mixxx::Time::setTestMode(true);
-        mixxx::Time::setTestElapsedTime(mixxx::Duration::fromMillis(10));
+        mixxx::Time::addTestTime(10ms);
     }
 
     void TearDown() override {
@@ -28,82 +26,71 @@ class SoftTakeoverTest : public MixxxTest {
 
 TEST_F(SoftTakeoverTest, DoesntIgnoreDisabledControl) {
     // Range -1.0 to 1.0
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -1.0, 1.0);
+    ControlPotmeter co(ConfigKey("[Channel1]", "test_pot"), -1.0, 1.0);
 
     SoftTakeoverCtrl st_control;
-    EXPECT_FALSE(st_control.ignore(co.get(), co->get()));
-}
-
-TEST_F(SoftTakeoverTest, DoesntIgnoreNonPotmeter) {
-    auto co = std::make_unique<ControlPushButton>(ConfigKey("[Channel1]", "test_button"));
-
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
-    // First update is always ignored so this proves the CPB is not enabled for
-    // soft-takeover.
-    EXPECT_FALSE(st_control.ignore(co.get(), 0));
+    EXPECT_FALSE(st_control.ignore(&co, co.get()));
 }
 
 TEST_F(SoftTakeoverTest, IgnoresFirstValue) {
     // Range -1.0 to 1.0
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -1.0, 1.0);
+    ControlPotmeter co(ConfigKey("[Channel1]", "test_pot"), -1.0, 1.0);
 
     SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-    EXPECT_TRUE(st_control.ignore(co.get(), 5));
+    st_control.enable(gsl::make_not_null(&co));
+    EXPECT_TRUE(st_control.ignore(&co, 5));
 }
 
 TEST_F(SoftTakeoverTest, DoesntIgnoreSameValue) {
     // Range -1.0 to 1.0
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -1.0, 1.0);
+    ControlPotmeter co(ConfigKey("[Channel1]", "test_pot"), -1.0, 1.0);
 
-    co->set(0.6);
+    co.set(0.6);
     SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
+    st_control.enable(gsl::make_not_null(&co));
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(0.6)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(0.6)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(0.6)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(0.6)));
 }
 
 // These are corner cases that allow for quickly flicking/whipping controls
 //  from a standstill when the previous knob value matches the current CO value
 TEST_F(SoftTakeoverTest, SuperFastPrevEqCurrent) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
+    ControlPotmeter co(ConfigKey("[Channel1]", "test_pot"), -250, 250);
 
     // From the bottom
-    co->set(-250);
+    co.set(-250);
     SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
+    st_control.enable(gsl::make_not_null(&co));
 
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-250)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-250)));
     // This can happen any time afterwards, so we test 10 seconds
-    mixxx::Time::setTestElapsedTime(mixxx::Duration::fromSeconds(10));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(200)));
+    mixxx::Time::addTestTime(10s);
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(200)));
 
     // From the top
-    co->set(250);
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(250)));
+    co.set(250);
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(250)));
     // This can happen any time afterwards, so we test 10 seconds
-    mixxx::Time::setTestElapsedTime(mixxx::Duration::fromSeconds(10));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(-200)));
+    mixxx::Time::addTestTime(10s);
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(-200)));
 }
 
 // But when they don't match, this type of thing should be ignored!
 //  FIXME: This fails on the st::ignore() implementation in 2.0.0-rc1
 TEST_F(SoftTakeoverTest, DISABLED_SuperFastNotSame) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
+    ControlPotmeter co(ConfigKey("[Channel1]", "test_pot"), -250, 250);
 
-    co->set(250);
+    co.set(250);
     SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
+    st_control.enable(gsl::make_not_null(&co));
 
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(249)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(249)));
     // This can happen any time afterwards, so we test 10 seconds
-    mixxx::Time::setTestElapsedTime(mixxx::Duration::fromSeconds(10));
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-200)));
+    mixxx::Time::addTestTime(10s);
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-200)));
 }
 
 /* The meat of the tests
@@ -118,476 +105,305 @@ TEST_F(SoftTakeoverTest, DISABLED_SuperFastNotSame) {
  *  - New value arrival time (below or above threshold)
  */
 
-// ---- Previous Near & less than current
-
-TEST_F(SoftTakeoverTest, PrevNearLess_NewNearLess_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
+class SoftTakeoverTestWithValue : public SoftTakeoverTest {
+  protected:
+    ControlPotmeter co{ConfigKey("[Channel1]", "test_pot"), -250, 250};
+    SoftTakeoverCtrl st_control{};
 
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
+    void SetUp() override {
+        SoftTakeoverTest::SetUp();
+        co.set(50);
+        st_control.enable(gsl::make_not_null(&co));
+    }
+};
 
+// ---- Previous Near & less than current
+TEST_F(SoftTakeoverTestWithValue, PrevNearLess_NewNearLess_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(40)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(45)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(40)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(45)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearLess_NewNearMore_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearLess_NewNearMore_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(40)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(60)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(40)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(60)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearLess_NewFarLess_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearLess_NewFarLess_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(40)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(1)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(40)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(1)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearLess_NewFarMore_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearLess_NewFarMore_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(40)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(100)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(40)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(100)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearLess_NewNearLess_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearLess_NewNearLess_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(40)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(45)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(40)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(45)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearLess_NewNearMore_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearLess_NewNearMore_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(40)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(60)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(40)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(60)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  same     close           far             later               TRUE
 //  FIXME: This fails on the st::ignore() implementation in 2.0.0-rc1
-TEST_F(SoftTakeoverTest, DISABLED_PrevNearLess_NewFarLess_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, DISABLED_PrevNearLess_NewFarLess_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(40)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(1)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(40)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(1)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  opposite close           far             later               TRUE
 //  FIXME: This fails on the st::ignore() implementation in 2.0.0-rc1
-TEST_F(SoftTakeoverTest, DISABLED_PrevNearLess_NewFarMore_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, DISABLED_PrevNearLess_NewFarMore_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(40)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(100)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(40)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(100)));
 }
 
 // ---- Previous Near & greater than current
 
-TEST_F(SoftTakeoverTest, PrevNearMore_NewNearLess_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearMore_NewNearLess_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(55)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(45)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(55)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(45)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearMore_NewNearMore_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearMore_NewNearMore_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(55)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(60)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(55)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(60)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearMore_NewFarLess_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearMore_NewFarLess_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(55)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(1)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(55)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(1)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearMore_NewFarMore_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearMore_NewFarMore_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(55)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(100)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(55)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(100)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearMore_NewNearLess_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearMore_NewNearLess_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(55)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(45)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(55)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(45)));
 }
 
-TEST_F(SoftTakeoverTest, PrevNearMore_NewNearMore_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevNearMore_NewNearMore_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(55)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(60)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(55)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(60)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  opposite close           far             later               TRUE
 //  FIXME: This fails on the st::ignore() implementation in 2.0.0-rc1
-TEST_F(SoftTakeoverTest, DISABLED_PrevNearMore_NewFarLess_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, DISABLED_PrevNearMore_NewFarLess_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(55)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(1)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(55)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(1)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  same     close           far             later               TRUE
 //  FIXME: This fails on the st::ignore() implementation in 2.0.0-rc1
-TEST_F(SoftTakeoverTest, DISABLED_PrevNearMore_NewFarMore_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, DISABLED_PrevNearMore_NewFarMore_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(55)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(100)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(55)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(100)));
 }
 
 // ---- Previous Far & less than current
 
-TEST_F(SoftTakeoverTest, PrevFarLess_NewNearLess_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarLess_NewNearLess_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-50)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(45)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-50)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(45)));
 }
 
-TEST_F(SoftTakeoverTest, PrevFarLess_NewNearMore_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarLess_NewNearMore_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-50)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(60)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-50)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(60)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  same     far             far             soon                TRUE
 //  FIXME: This fails on the st::ignore() implementation in 2.0.0-rc1
-TEST_F(SoftTakeoverTest, DISABLED_PrevFarLess_NewFarLess_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, DISABLED_PrevFarLess_NewFarLess_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-50)));
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(1)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-50)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(1)));
 }
 
-TEST_F(SoftTakeoverTest, PrevFarLess_NewFarMore_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarLess_NewFarMore_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-50)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(100)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-50)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(100)));
 }
 
-TEST_F(SoftTakeoverTest, PrevFarLess_NewNearLess_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarLess_NewNearLess_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-50)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(45)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-50)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(45)));
 }
 
-TEST_F(SoftTakeoverTest, PrevFarLess_NewNearMore_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarLess_NewNearMore_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-50)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(60)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-50)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(60)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  same     far             far             later               TRUE
-TEST_F(SoftTakeoverTest, PrevFarLess_NewFarLess_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarLess_NewFarLess_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-50)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(1)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-50)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(1)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  opposite far             far             later               TRUE
 //  FIXME: This fails on the st::ignore() implementation in 2.0.0-rc1
-TEST_F(SoftTakeoverTest, DISABLED_PrevFarLess_NewFarMore_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, DISABLED_PrevFarLess_NewFarMore_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-50)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(100)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-50)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(100)));
 }
 
 // ---- Previous Far & greater than current
 
-TEST_F(SoftTakeoverTest, PrevFarMore_NewNearLess_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarMore_NewNearLess_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(120)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(45)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(120)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(45)));
 }
 
-TEST_F(SoftTakeoverTest, PrevFarMore_NewNearMore_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarMore_NewNearMore_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(120)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(60)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(120)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(60)));
 }
 
-TEST_F(SoftTakeoverTest, PrevFarMore_NewFarLess_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarMore_NewFarLess_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(120)));
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(1)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(120)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(1)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  same     far             far             soon                TRUE
 //  FIXME: This fails on the st::ignore() implementation in 2.0.0-rc1
-TEST_F(SoftTakeoverTest, DISABLED_PrevFarMore_NewFarMore_Soon) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, DISABLED_PrevFarMore_NewFarMore_Soon) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(120)));
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(100)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(120)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(100)));
 }
 
-TEST_F(SoftTakeoverTest, PrevFarMore_NewNearLess_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarMore_NewNearLess_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(120)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(45)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(120)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(45)));
 }
 
-TEST_F(SoftTakeoverTest, PrevFarMore_NewNearMore_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarMore_NewNearMore_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(120)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(60)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(120)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(60)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  opposite far             far             later               TRUE
 //  FIXME: This fails on the st::ignore() implementation in 2.0.0-rc1
-TEST_F(SoftTakeoverTest, DISABLED_PrevFarMore_NewFarLess_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, DISABLED_PrevFarMore_NewFarLess_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(120)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(1)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(120)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(1)));
 }
 
 // Ignore this case:
 //  Sides    prev distance   new distance    new value arrives   Ignore
 //  same     far             far             later               TRUE
-TEST_F(SoftTakeoverTest, PrevFarMore_NewFarMore_Late) {
-    auto co = std::make_unique<ControlPotmeter>(ConfigKey("[Channel1]", "test_pot"), -250, 250);
-
-    co->set(50);
-    SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
-
+TEST_F(SoftTakeoverTestWithValue, PrevFarMore_NewFarMore_Late) {
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(120)));
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(100)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(120)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(100)));
 }
 
 TEST_F(SoftTakeoverTest, CatchOutOfBounds) {
-    auto co = std::make_unique<ControlPotmeter>(
-            ConfigKey("[Channel1]", "test_pot"), -250, 250, true);
+    ControlPotmeter co(ConfigKey("[Channel1]", "test_pot"), -250, 250, true);
 
-    co->set(50);
+    co.set(50);
     SoftTakeoverCtrl st_control;
-    st_control.enable(co.get());
+    st_control.enable(&co);
 
     // First is always ignored.
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(45)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(45)));
     // Cross the original value to take over
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(55)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(55)));
 
     // Set value to an out of bounds value
-    co->set(300);
-    mixxx::Time::setTestElapsedTime(SoftTakeover::TestAccess::getTimeThreshold() * 2);
+    co.set(300);
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
     // Actions in the same direction shall be ignored
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(60)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(60)));
     // actions in the other edirection shall be ignored
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(40)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(40)));
     // reaching the lower border should be ignored
-    EXPECT_TRUE(st_control.ignore(co.get(), co->getParameterForValue(-250)));
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(-250)));
     // reaching the upper border near the out of bounds value should not be ignored.
-    EXPECT_FALSE(st_control.ignore(co.get(), co->getParameterForValue(250)));
+    EXPECT_FALSE(st_control.ignore(&co, co.getParameterForValue(250)));
+}
+
+TEST_F(SoftTakeoverTestWithValue, willIgnore) {
+    // First is always ignored.
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(120)));
+    SoftTakeover::TestAccess::advanceTimePastThreshold();
+    EXPECT_TRUE(st_control.willIgnore(&co, co.getParameterForValue(80)));
+    // do not ignore a value in range;
+    EXPECT_FALSE(st_control.willIgnore(&co, co.getParameterForValue(51)));
+    // but still ignore a value outside range because willIgnore just tests
+    EXPECT_TRUE(st_control.ignore(&co, co.getParameterForValue(80)));
 }
 
 // For the ignore cases, check that they work correctly with various signed values
diff --git a/src/test/soundFileFormats/generateFiles.sh b/src/test/soundFileFormats/generateFiles.sh
index b3b14bc5b7..fde6b2c2e6 100755
--- a/src/test/soundFileFormats/generateFiles.sh
+++ b/src/test/soundFileFormats/generateFiles.sh
@@ -189,9 +189,10 @@ do
                     echo "Generating ${ssize}-bit ${rate}Hz ${channel}-channel ${format} file"
                     sox -V0 1kHzR440HzLReference_32i96kStereo.wav -b "${ssize}" -c "${channel}" -r "${rate}" "test${ssize}bit${friendlyrate}k${friendlychannel}.${format}"
                 fi
-                if [ $? -gt 1 ]
+                ret=$?
+                if [ "$ret" -gt 1 ]
                 then
-                    echo "Error #$?, aborting"
+                    echo "Error #$ret, aborting"
                     exit 1
                 fi
             done
diff --git a/src/test/wpushbutton_test.cpp b/src/test/wpushbutton_test.cpp
index c866cb2a77..1f3f328c45 100644
--- a/src/test/wpushbutton_test.cpp
+++ b/src/test/wpushbutton_test.cpp
@@ -32,10 +32,11 @@ class WPushButtonTest : public MixxxTest {
 TEST_F(WPushButtonTest, QuickPressNoLatchTest) {
     QScopedPointer<ControlPushButton> pPushControl(
         new ControlPushButton(ConfigKey("[Test]", "push")));
-    pPushControl->setButtonMode(ControlPushButton::LONGPRESSLATCHING);
+    pPushControl->setButtonMode(mixxx::control::ButtonMode::LongPressLatching);
 
-    m_pButton.reset(new WPushButton(NULL, ControlPushButton::LONGPRESSLATCHING,
-                                    ControlPushButton::PUSH));
+    m_pButton.reset(new WPushButton(NULL,
+            mixxx::control::ButtonMode::LongPressLatching,
+            mixxx::control::ButtonMode::Push));
     m_pButton->setStates(2);
     m_pButton->addLeftConnection(
         new ControlParameterWidgetConnection(
@@ -58,10 +59,11 @@ TEST_F(WPushButtonTest, QuickPressNoLatchTest) {
 TEST_F(WPushButtonTest, LongPressLatchTest) {
     QScopedPointer<ControlPushButton> pPushControl(
         new ControlPushButton(ConfigKey("[Test]", "push")));
-    pPushControl->setButtonMode(ControlPushButton::LONGPRESSLATCHING);
+    pPushControl->setButtonMode(mixxx::control::ButtonMode::LongPressLatching);
 
-    m_pButton.reset(new WPushButton(NULL, ControlPushButton::LONGPRESSLATCHING,
-                                    ControlPushButton::PUSH));
+    m_pButton.reset(new WPushButton(NULL,
+            mixxx::control::ButtonMode::LongPressLatching,
+            mixxx::control::ButtonMode::Push));
     m_pButton->setStates(2);
     m_pButton->addLeftConnection(
         new ControlParameterWidgetConnection(
diff --git a/src/track/keyutils.cpp b/src/track/keyutils.cpp
index c17608255b..49efd36dee 100644
--- a/src/track/keyutils.cpp
+++ b/src/track/keyutils.cpp
@@ -5,6 +5,7 @@
 #include <QRegularExpression>
 #include <QtDebug>
 
+#include "util/color/colorpalette.h"
 #include "util/color/predefinedcolorpalettes.h"
 #include "util/color/rgbcolor.h"
 #include "util/compatibility/qmutex.h"
@@ -465,11 +466,10 @@ double KeyUtils::keyToNumericValue(ChromaticKey key) {
 }
 
 // static
-QColor KeyUtils::keyToColor(ChromaticKey key) {
+QColor KeyUtils::keyToColor(ChromaticKey key, const ColorPalette& palette) {
     int openKeyNumber = keyToOpenKeyNumber(key);
 
     if (openKeyNumber != 0) {
-        const auto& palette = mixxx::PredefinedColorPalettes::kDefaultKeyColorPalette;
         DEBUG_ASSERT(openKeyNumber <= palette.size() && openKeyNumber >= 1);
         const auto rgbColor = palette.at(openKeyNumber - 1); // Open Key numbers start from 1
         return mixxx::RgbColor::toQColor(rgbColor);
diff --git a/src/track/keyutils.h b/src/track/keyutils.h
index c3de137c38..c18d850616 100644
--- a/src/track/keyutils.h
+++ b/src/track/keyutils.h
@@ -8,6 +8,7 @@
 #include "control/controlproxy.h"
 #include "proto/keys.pb.h"
 #include "track/keys.h"
+#include "util/color/colorpalette.h"
 #include "util/math.h"
 #include "util/types.h"
 
@@ -68,7 +69,7 @@ class KeyUtils {
 
     static double keyToNumericValue(mixxx::track::io::key::ChromaticKey key);
 
-    static QColor keyToColor(mixxx::track::io::key::ChromaticKey key);
+    static QColor keyToColor(mixxx::track::io::key::ChromaticKey key, const ColorPalette& palette);
 
     static QPair<mixxx::track::io::key::ChromaticKey, double> scaleKeyOctaves(
         mixxx::track::io::key::ChromaticKey key, double scale);
diff --git a/src/track/serato/markers2.h b/src/track/serato/markers2.h
index f0a3210660..c4b2633324 100644
--- a/src/track/serato/markers2.h
+++ b/src/track/serato/markers2.h
@@ -149,7 +149,7 @@ class SeratoMarkers2ColorEntry : public SeratoMarkers2Entry {
     QByteArray dump() const override;
 
     SeratoStoredTrackColor getColor() const {
-        return m_color;
+//        return m_color;
     }
 
     void setColor(SeratoStoredTrackColor color) {
@@ -159,7 +159,7 @@ class SeratoMarkers2ColorEntry : public SeratoMarkers2Entry {
     quint32 length() const override;
 
   private:
-    SeratoStoredTrackColor m_color;
+//    SeratoStoredTrackColor m_color;
 };
 
 inline bool operator==(const SeratoMarkers2ColorEntry& lhs,
diff --git a/src/track/track.h b/src/track/track.h
index 471c2aae68..0d181d3ab0 100644
--- a/src/track/track.h
+++ b/src/track/track.h
@@ -185,7 +185,7 @@ class Track : public QObject {
 
     // Returns the content of the year library column.
     // This was original only the four digit (gregorian) calendar year of the release date
-    // but allows to store any user string. Now it is altenatively used as
+    // but allows to store any user string. Now it is alternatively used as
     // recording date/time in the ISO 8601 yyyy-MM-ddTHH:mm:ss format tunkated at any point,
     // following the TDRC ID3v2.4 frame or if not exists, TYER + TDAT.
     QString getYear() const;
@@ -435,6 +435,16 @@ class Track : public QObject {
     void setAudioProperties(
             const mixxx::audio::StreamInfo& streamInfo);
 
+    // Information about the actual properties of the
+    // audio stream is only available after opening the
+    // source at least once. On this occasion the metadata
+    // stream info of the track need to be updated to reflect
+    // these values.
+    bool hasStreamInfoFromSource() const {
+        const auto locked = lockMutex(&m_qMutex);
+        return m_record.hasStreamInfoFromSource();
+    }
+
   signals:
     void artistChanged(const QString&);
     void titleChanged(const QString&);
@@ -568,16 +578,6 @@ class Track : public QObject {
     ExportTrackMetadataResult exportMetadata(
             const mixxx::MetadataSource& metadataSource,
             const SyncTrackMetadataParams& syncParams);
-
-    // Information about the actual properties of the
-    // audio stream is only available after opening the
-    // source at least once. On this occasion the metadata
-    // stream info of the track need to be updated to reflect
-    // these values.
-    bool hasStreamInfoFromSource() const {
-        const auto locked = lockMutex(&m_qMutex);
-        return m_record.hasStreamInfoFromSource();
-    }
     void updateStreamInfoFromSource(
             mixxx::audio::StreamInfo&& streamInfo);
 
diff --git a/src/track/trackmetadata.h b/src/track/trackmetadata.h
index e01dc1b9cd..ea947533f5 100644
--- a/src/track/trackmetadata.h
+++ b/src/track/trackmetadata.h
@@ -13,7 +13,7 @@ class TrackMetadata final {
     //  - read-only
     //  - stored in file tags
     //  - adjusted when opening the audio stream (if available)
-    MIXXX_DECL_PROPERTY(audio::StreamInfo, streamInfo, StreamInfo)
+//    MIXXX_DECL_PROPERTY(audio::StreamInfo, streamInfo, StreamInfo)
 
     // Track properties
     //   - read-write
diff --git a/src/util/color/predefinedcolorpalettes.cpp b/src/util/color/predefinedcolorpalettes.cpp
index 385a575cd3..0e3a88b2b3 100644
--- a/src/util/color/predefinedcolorpalettes.cpp
+++ b/src/util/color/predefinedcolorpalettes.cpp
@@ -159,6 +159,88 @@ constexpr mixxx::RgbColor kMixxxKeyColor10(0x3D8AFD);
 constexpr mixxx::RgbColor kMixxxKeyColor11(0xAC64FE);
 constexpr mixxx::RgbColor kMixxxKeyColor12(0xFD3FEA);
 
+// Traktor Key Color Palette
+// NOTE: C Major is 1d in Open Key Notation
+
+constexpr mixxx::RgbColor kTraktorKeyColor1(0xB960A2);
+constexpr mixxx::RgbColor kTraktorKeyColor2(0x8269AB);
+constexpr mixxx::RgbColor kTraktorKeyColor3(0x527FC0);
+constexpr mixxx::RgbColor kTraktorKeyColor4(0x3CC0EF);
+constexpr mixxx::RgbColor kTraktorKeyColor5(0x5BC1CE);
+constexpr mixxx::RgbColor kTraktorKeyColor6(0x4CB686);
+constexpr mixxx::RgbColor kTraktorKeyColor7(0x73B629);
+constexpr mixxx::RgbColor kTraktorKeyColor8(0x9FC516);
+constexpr mixxx::RgbColor kTraktorKeyColor9(0xFDD615);
+constexpr mixxx::RgbColor kTraktorKeyColor10(0xF28B2E);
+constexpr mixxx::RgbColor kTraktorKeyColor11(0xEC6637);
+constexpr mixxx::RgbColor kTraktorKeyColor12(0xE84C4D);
+
+// Mixed In Key Key Color Palette
+// NOTE: C Major is 8B in Camelot Notation
+
+constexpr mixxx::RgbColor kMIKKeyColor1(0xF17EDB);
+constexpr mixxx::RgbColor kMIKKeyColor2(0xD18BFD);
+constexpr mixxx::RgbColor kMIKKeyColor3(0x9EB4FD);
+constexpr mixxx::RgbColor kMIKKeyColor4(0x4DD3F8);
+constexpr mixxx::RgbColor kMIKKeyColor5(0x01EAEC);
+constexpr mixxx::RgbColor kMIKKeyColor6(0x00EECB);
+constexpr mixxx::RgbColor kMIKKeyColor7(0x20EF7F);
+constexpr mixxx::RgbColor kMIKKeyColor8(0x7FF448);
+constexpr mixxx::RgbColor kMIKKeyColor9(0xE0CA6D);
+constexpr mixxx::RgbColor kMIKKeyColor10(0xFDA078);
+constexpr mixxx::RgbColor kMIKKeyColor11(0xFF8693);
+constexpr mixxx::RgbColor kMIKKeyColor12(0xFD7EB3);
+
+// Accessible Color Palettes
+// When arranged in a circle, the hue varies vertically and lightness/saturation
+// varies horizontally so that every color is unique, but adjacent colors are
+// similar.
+
+// Protanopia / Protanomaly
+
+constexpr mixxx::RgbColor kProtKeyColor1(0x2626D9);
+constexpr mixxx::RgbColor kProtKeyColor2(0x7582D7);
+constexpr mixxx::RgbColor kProtKeyColor3(0xA7C2DD);
+constexpr mixxx::RgbColor kProtKeyColor4(0xB8E0E0);
+constexpr mixxx::RgbColor kProtKeyColor5(0xA7DDC2);
+constexpr mixxx::RgbColor kProtKeyColor6(0x75D782);
+constexpr mixxx::RgbColor kProtKeyColor7(0x26D926);
+constexpr mixxx::RgbColor kProtKeyColor8(0x0DA522);
+constexpr mixxx::RgbColor kProtKeyColor9(0x02783D);
+constexpr mixxx::RgbColor kProtKeyColor10(0x006666);
+constexpr mixxx::RgbColor kProtKeyColor11(0x023D78);
+constexpr mixxx::RgbColor kProtKeyColor12(0x0D22A5);
+
+// Deuteranopia / Deuteranomaly
+
+constexpr mixxx::RgbColor kDeutKeyColor1(0xD92626);
+constexpr mixxx::RgbColor kDeutKeyColor2(0xD77582);
+constexpr mixxx::RgbColor kDeutKeyColor3(0xDDA7C2);
+constexpr mixxx::RgbColor kDeutKeyColor4(0xE0B8E0);
+constexpr mixxx::RgbColor kDeutKeyColor5(0xC2A7DD);
+constexpr mixxx::RgbColor kDeutKeyColor6(0x8275D7);
+constexpr mixxx::RgbColor kDeutKeyColor7(0x2626D9);
+constexpr mixxx::RgbColor kDeutKeyColor8(0x220DA5);
+constexpr mixxx::RgbColor kDeutKeyColor9(0x3D0278);
+constexpr mixxx::RgbColor kDeutKeyColor10(0x660066);
+constexpr mixxx::RgbColor kDeutKeyColor11(0x78023D);
+constexpr mixxx::RgbColor kDeutKeyColor12(0xA50D22);
+
+// Deuteranopia / Deuteranomaly
+
+constexpr mixxx::RgbColor kTritKeyColor1(0x26D926);
+constexpr mixxx::RgbColor kTritKeyColor2(0x82D775);
+constexpr mixxx::RgbColor kTritKeyColor3(0xC2DDA7);
+constexpr mixxx::RgbColor kTritKeyColor4(0xE0E0B8);
+constexpr mixxx::RgbColor kTritKeyColor5(0xDDC2A7);
+constexpr mixxx::RgbColor kTritKeyColor6(0xD78275);
+constexpr mixxx::RgbColor kTritKeyColor7(0xD92626);
+constexpr mixxx::RgbColor kTritKeyColor8(0xA5220D);
+constexpr mixxx::RgbColor kTritKeyColor9(0x783D02);
+constexpr mixxx::RgbColor kTritKeyColor10(0x666600);
+constexpr mixxx::RgbColor kTritKeyColor11(0x3D7802);
+constexpr mixxx::RgbColor kTritKeyColor12(0x22A50D);
+
 // Replaces "no color" values and is used for new cues if auto_hotcue_colors is
 // disabled
 constexpr mixxx::RgbColor kSchemaMigrationReplacementColor(0xFF8000);
@@ -169,7 +251,7 @@ namespace mixxx {
 
 const ColorPalette PredefinedColorPalettes::kMixxxHotcueColorPalette =
         ColorPalette(
-                QStringLiteral("Mixxx Hotcue Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPaletes", "Mixxx Hotcue Colors"),
                 {
                         kColorMixxxRed,
                         kColorMixxxGreen,
@@ -186,34 +268,35 @@ const ColorPalette PredefinedColorPalettes::kMixxxHotcueColorPalette =
                 // controllers with >8 hotcue buttons, for example a Novation Launchpad.
                 {0, 1, 2, 3, 4, 5, 6, 7});
 
-const ColorPalette PredefinedColorPalettes::kSeratoTrackMetadataHotcueColorPalette =
-        ColorPalette(
-                QStringLiteral("Serato DJ Track Metadata Hotcue Colors"),
-                {
-                        kSeratoTrackMetadataHotcueColorRed,
-                        kSeratoTrackMetadataHotcueColorOrange,
-                        kSeratoTrackMetadataHotcueColorBrown,
-                        kSeratoTrackMetadataHotcueColorYellow,
-                        kSeratoTrackMetadataHotcueColorEmerald,
-                        kSeratoTrackMetadataHotcueColorKelly,
-                        kSeratoTrackMetadataHotcueColorGreen,
-                        kSeratoTrackMetadataHotcueColorSea,
-                        kSeratoTrackMetadataHotcueColorJade,
-                        kSeratoTrackMetadataHotcueColorTurquoise,
-                        kSeratoTrackMetadataHotcueColorTeal,
-                        kSeratoTrackMetadataHotcueColorBlue,
-                        kSeratoTrackMetadataHotcueColorDarkBlue,
-                        kSeratoTrackMetadataHotcueColorViolet,
-                        kSeratoTrackMetadataHotcueColorPurple,
-                        kSeratoTrackMetadataHotcueColorFuchsia,
-                        kSeratoTrackMetadataHotcueColorMagenta,
-                        kSeratoTrackMetadataHotcueColorCarmine,
-                },
-                {0, 2, 12, 3, 6, 15, 9, 14});
+const ColorPalette
+        PredefinedColorPalettes::kSeratoTrackMetadataHotcueColorPalette =
+                ColorPalette(QT_TRANSLATE_NOOP("PredefinedColorPalettes",
+                                     "Serato DJ Track Metadata Hotcue Colors"),
+                        {
+                                kSeratoTrackMetadataHotcueColorRed,
+                                kSeratoTrackMetadataHotcueColorOrange,
+                                kSeratoTrackMetadataHotcueColorBrown,
+                                kSeratoTrackMetadataHotcueColorYellow,
+                                kSeratoTrackMetadataHotcueColorEmerald,
+                                kSeratoTrackMetadataHotcueColorKelly,
+                                kSeratoTrackMetadataHotcueColorGreen,
+                                kSeratoTrackMetadataHotcueColorSea,
+                                kSeratoTrackMetadataHotcueColorJade,
+                                kSeratoTrackMetadataHotcueColorTurquoise,
+                                kSeratoTrackMetadataHotcueColorTeal,
+                                kSeratoTrackMetadataHotcueColorBlue,
+                                kSeratoTrackMetadataHotcueColorDarkBlue,
+                                kSeratoTrackMetadataHotcueColorViolet,
+                                kSeratoTrackMetadataHotcueColorPurple,
+                                kSeratoTrackMetadataHotcueColorFuchsia,
+                                kSeratoTrackMetadataHotcueColorMagenta,
+                                kSeratoTrackMetadataHotcueColorCarmine,
+                        },
+                        {0, 2, 12, 3, 6, 15, 9, 14});
 
 const ColorPalette PredefinedColorPalettes::kSeratoDJProHotcueColorPalette =
         ColorPalette(
-                QStringLiteral("Serato DJ Pro Hotcue Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Serato DJ Pro Hotcue Colors"),
                 {
                         kSeratoDJProHotcueColorRed1,
                         kSeratoDJProHotcueColorOrange1,
@@ -265,25 +348,25 @@ const QList<mixxx::RgbColor> kRekordboxColorsSelection = {
 
 const ColorPalette PredefinedColorPalettes::kRekordboxCOLD1HotcueColorPalette =
         ColorPalette(
-                QStringLiteral("Rekordbox COLD1 Hotcue Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Rekordbox COLD1 Hotcue Colors"),
                 kRekordboxColorsSelection,
                 {5, 8, 1, 6, 7, 2, 7, 5});
 
 const ColorPalette PredefinedColorPalettes::kRekordboxCOLD2HotcueColorPalette =
         ColorPalette(
-                QStringLiteral("Rekordbox COLD2 Hotcue Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Rekordbox COLD2 Hotcue Colors"),
                 kRekordboxColorsSelection,
                 {7, 5, 5, 5, 3, 4, 3, 2});
 
 const ColorPalette PredefinedColorPalettes::kRekordboxCOLORFULHotcueColorPalette =
         ColorPalette(
-                QStringLiteral("Rekordbox COLORFUL Hotcue Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Rekordbox COLORFUL Hotcue Colors"),
                 kRekordboxColorsSelection,
                 {15, 5, 10, 2, 8, 13, 4, 12});
 
 const ColorPalette PredefinedColorPalettes::kMixxxTrackColorPalette =
         ColorPalette(
-                QStringLiteral("Mixxx Track Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Mixxx Track Colors"),
                 {
                         kMixxxTrackColorDarkRed,
                         kMixxxTrackColorRed,
@@ -308,7 +391,7 @@ const ColorPalette PredefinedColorPalettes::kMixxxTrackColorPalette =
 
 const ColorPalette PredefinedColorPalettes::kRekordboxTrackColorPalette =
         ColorPalette(
-                QStringLiteral("Rekordbox Track Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Rekordbox Track Colors"),
                 {
                         kRekordboxTrackColorPink,
                         kRekordboxTrackColorRed,
@@ -322,7 +405,7 @@ const ColorPalette PredefinedColorPalettes::kRekordboxTrackColorPalette =
 
 const ColorPalette PredefinedColorPalettes::kSeratoDJProTrackColorPalette =
         ColorPalette(
-                QStringLiteral("Serato DJ Pro Track Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Serato DJ Pro Track Colors"),
                 {
                         kSeratoDJProTrackColorGrey1,
                         kSeratoDJProTrackColorGrey2,
@@ -348,7 +431,7 @@ const ColorPalette PredefinedColorPalettes::kSeratoDJProTrackColorPalette =
 
 const ColorPalette PredefinedColorPalettes::kTraktorProTrackColorPalette =
         ColorPalette(
-                QStringLiteral("Traktor Pro Track Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Traktor Pro Track Colors"),
                 {
                         kTraktorProTrackColorRed,
                         kTraktorProTrackColorOrange,
@@ -361,7 +444,7 @@ const ColorPalette PredefinedColorPalettes::kTraktorProTrackColorPalette =
 
 const ColorPalette PredefinedColorPalettes::kVirtualDJTrackColorPalette =
         ColorPalette(
-                QStringLiteral("VirtualDJ Track Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "VirtualDJ Track Colors"),
                 {
                         kVirtualDJTrackColorRed,
                         kVirtualDJTrackColorYellow,
@@ -374,7 +457,7 @@ const ColorPalette PredefinedColorPalettes::kVirtualDJTrackColorPalette =
 
 const ColorPalette PredefinedColorPalettes::kMixxxKeyColorPalette =
         ColorPalette(
-                QStringLiteral("Mixxx Key Colors"),
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Mixxx Key Colors"),
                 {
                         kMixxxKeyColor1,
                         kMixxxKeyColor2,
@@ -390,6 +473,96 @@ const ColorPalette PredefinedColorPalettes::kMixxxKeyColorPalette =
                         kMixxxKeyColor12,
                 });
 
+const ColorPalette PredefinedColorPalettes::kTraktorKeyColorPalette =
+        ColorPalette(
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Traktor Key Colors"),
+                {
+                        kTraktorKeyColor1,
+                        kTraktorKeyColor2,
+                        kTraktorKeyColor3,
+                        kTraktorKeyColor4,
+                        kTraktorKeyColor5,
+                        kTraktorKeyColor6,
+                        kTraktorKeyColor7,
+                        kTraktorKeyColor8,
+                        kTraktorKeyColor9,
+                        kTraktorKeyColor10,
+                        kTraktorKeyColor11,
+                        kTraktorKeyColor12,
+                });
+
+const ColorPalette PredefinedColorPalettes::kMIKKeyColorPalette =
+        ColorPalette(
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Mixed In Key - Key Colors"),
+                {
+                        kMIKKeyColor1,
+                        kMIKKeyColor2,
+                        kMIKKeyColor3,
+                        kMIKKeyColor4,
+                        kMIKKeyColor5,
+                        kMIKKeyColor6,
+                        kMIKKeyColor7,
+                        kMIKKeyColor8,
+                        kMIKKeyColor9,
+                        kMIKKeyColor10,
+                        kMIKKeyColor11,
+                        kMIKKeyColor12,
+                });
+
+const ColorPalette PredefinedColorPalettes::kProtKeyColorPalette =
+        ColorPalette(
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Protanopia / Protanomaly Key Colors"),
+                {
+                        kProtKeyColor1,
+                        kProtKeyColor2,
+                        kProtKeyColor3,
+                        kProtKeyColor4,
+                        kProtKeyColor5,
+                        kProtKeyColor6,
+                        kProtKeyColor7,
+                        kProtKeyColor8,
+                        kProtKeyColor9,
+                        kProtKeyColor10,
+                        kProtKeyColor11,
+                        kProtKeyColor12,
+                });
+
+const ColorPalette PredefinedColorPalettes::kDeutKeyColorPalette =
+        ColorPalette(QT_TRANSLATE_NOOP("PredefinedColorPalettes",
+                             "Deuteranopia / Deuteranomaly Key Colors"),
+                {
+                        kDeutKeyColor1,
+                        kDeutKeyColor2,
+                        kDeutKeyColor3,
+                        kDeutKeyColor4,
+                        kDeutKeyColor5,
+                        kDeutKeyColor6,
+                        kDeutKeyColor7,
+                        kDeutKeyColor8,
+                        kDeutKeyColor9,
+                        kDeutKeyColor10,
+                        kDeutKeyColor11,
+                        kDeutKeyColor12,
+                });
+
+const ColorPalette PredefinedColorPalettes::kTritKeyColorPalette =
+        ColorPalette(
+                QT_TRANSLATE_NOOP("PredefinedColorPalettes", "Tritanopia / Tritanomaly Key Colors"),
+                {
+                        kTritKeyColor1,
+                        kTritKeyColor2,
+                        kTritKeyColor3,
+                        kTritKeyColor4,
+                        kTritKeyColor5,
+                        kTritKeyColor6,
+                        kTritKeyColor7,
+                        kTritKeyColor8,
+                        kTritKeyColor9,
+                        kTritKeyColor10,
+                        kTritKeyColor11,
+                        kTritKeyColor12,
+                });
+
 const ColorPalette PredefinedColorPalettes::kDefaultHotcueColorPalette =
         mixxx::PredefinedColorPalettes::kMixxxHotcueColorPalette;
 
@@ -414,6 +587,11 @@ const QList<ColorPalette> PredefinedColorPalettes::kPalettes{
         mixxx::PredefinedColorPalettes::kVirtualDJTrackColorPalette,
         // Key Color Palettes
         mixxx::PredefinedColorPalettes::kMixxxKeyColorPalette,
+        mixxx::PredefinedColorPalettes::kTraktorKeyColorPalette,
+        mixxx::PredefinedColorPalettes::kMIKKeyColorPalette,
+        mixxx::PredefinedColorPalettes::kProtKeyColorPalette,
+        mixxx::PredefinedColorPalettes::kDeutKeyColorPalette,
+        mixxx::PredefinedColorPalettes::kTritKeyColorPalette,
 };
 
 const mixxx::RgbColor PredefinedColorPalettes::kDefaultCueColor =
diff --git a/src/util/color/predefinedcolorpalettes.h b/src/util/color/predefinedcolorpalettes.h
index 8d349603ec..9527d3f6bc 100644
--- a/src/util/color/predefinedcolorpalettes.h
+++ b/src/util/color/predefinedcolorpalettes.h
@@ -19,6 +19,11 @@ class PredefinedColorPalettes {
     static const ColorPalette kVirtualDJTrackColorPalette;
 
     static const ColorPalette kMixxxKeyColorPalette;
+    static const ColorPalette kTraktorKeyColorPalette;
+    static const ColorPalette kMIKKeyColorPalette;
+    static const ColorPalette kProtKeyColorPalette;
+    static const ColorPalette kDeutKeyColorPalette;
+    static const ColorPalette kTritKeyColorPalette;
 
     static const ColorPalette kDefaultHotcueColorPalette;
     static const ColorPalette kDefaultTrackColorPalette;
diff --git a/src/util/sample.cpp b/src/util/sample.cpp
index 0d3d08da58..6fa53e1787 100644
--- a/src/util/sample.cpp
+++ b/src/util/sample.cpp
@@ -882,6 +882,23 @@ void SampleUtil::copyOneStereoFromMulti(
     }
 }
 
+// static
+void SampleUtil::copyStereoToMulti(
+        CSAMPLE* M_RESTRICT pDest,
+        const CSAMPLE* M_RESTRICT pSrc,
+        SINT numFrames,
+        mixxx::audio::ChannelCount numChannels,
+        int channelOffset) {
+    DEBUG_ASSERT(numChannels > mixxx::audio::ChannelCount::stereo() &&
+            channelOffset - 1 < numFrames);
+    // forward loop
+    // note: LOOP VECTORIZED.
+    for (SINT i = 0; i < numFrames; ++i) {
+        pDest[i * numChannels + channelOffset] = pSrc[i * 2];
+        pDest[i * numChannels + channelOffset + 1] = pSrc[i * 2 + 1];
+    }
+}
+
 // static
 void SampleUtil::reverse(CSAMPLE* pBuffer, SINT numSamples) {
     for (SINT j = 0; j < numSamples / 4; ++j) {
diff --git a/src/util/sample.h b/src/util/sample.h
index 661a998c69..2951da114e 100644
--- a/src/util/sample.h
+++ b/src/util/sample.h
@@ -36,16 +36,22 @@ class SampleUtil {
     inline
     static void clear(CSAMPLE* pBuffer, SINT numSamples) {
         DEBUG_ASSERT(numSamples >= 0);
-        // Special case: This works, because the binary representation
-        // of 0.0f is 0!
-        memset(pBuffer, 0, sizeof(*pBuffer) * numSamples);
-        //fill(pBuffer, CSAMPLE_ZERO, iNumSamples);
+        // We need to cast `numSamples` to an unsigned type to fix a
+        // `-Wstringop-overflow` warning on GCC 14.1.1. Casting to unsigned is
+        // okay, because the `DEBUG_ASSERT` above catches negative values
+        // anyway.
+        const auto sampleCount = static_cast<std::size_t>(numSamples);
+        // Special case: We can use memset here, because the binary representation
+        // of 0.0f is 0! This is much faster without optimizations than using
+        // `fill()`.
+        memset(pBuffer, 0, sizeof(*pBuffer) * sampleCount);
     }
 
     // Sets every sample in pBuffer to value
     inline
     static void fill(CSAMPLE* pBuffer, CSAMPLE value,
             SINT numSamples) {
+        DEBUG_ASSERT(numSamples >= 0);
         std::fill_n(pBuffer, numSamples, value);
     }
 
@@ -370,6 +376,17 @@ class SampleUtil {
             mixxx::audio::ChannelCount numChannels,
             int sourceChannel = 0);
 
+    // Copies and strips interleaved stereo sample data in pSrc with
+    // down to multi-channel samples into pDest. Samples will be written at the
+    // channel pointed by channelOffset. Samples from all other channels will be
+    // ignored. pDst must contain (numFrames * numChannels) samples (numFrames *
+    // 2) samples will be written into pDest
+    static void copyStereoToMulti(CSAMPLE* pDest,
+            const CSAMPLE* pSrc,
+            SINT numFrames,
+            mixxx::audio::ChannelCount numChannels,
+            int channelOffset);
+
     // reverses stereo sample in place
     static void reverse(CSAMPLE* pBuffer, SINT numSamples);
 
diff --git a/src/util/time.cpp b/src/util/time.cpp
index e7214e9db4..6860035a4e 100644
--- a/src/util/time.cpp
+++ b/src/util/time.cpp
@@ -3,12 +3,12 @@
 namespace mixxx {
 
 // static
-LLTIMER Time::s_timer;
+Time::LLTIMER Time::s_timer;
 
 // static
 bool Time::s_testMode = false;
 
 // static
-Duration Time::s_testElapsed = Duration::fromNanos(0);
+Time::time_point Time::s_testElapsed = Time::time_point::min();
 
 } // namespace mixxx
diff --git a/src/util/time.h b/src/util/time.h
index 47fe6e0d49..87dad6d7b8 100644
--- a/src/util/time.h
+++ b/src/util/time.h
@@ -1,24 +1,41 @@
 #pragma once
 
+#include <chrono>
+
+#include "util/duration.h"
 #include "util/performancetimer.h"
 #include "util/threadcputimer.h"
-#include "util/duration.h"
 
 namespace mixxx {
 
-#define LLTIMER PerformanceTimer
-//#define LLTIMER ThreadCpuTimer
-
 class Time {
+    using LLTIMER = PerformanceTimer;
+    // using LLTIMER = ThreadCpuTimer;
+
   public:
+    using rep = LLTIMER::ClockT::rep;
+    using duration = LLTIMER::ClockT::duration;
+    using period = LLTIMER::ClockT::period;
+    using time_point = LLTIMER::ClockT::time_point;
+
+    // default to underlying clock. In testmode, all bets are off anyways.
+    static constexpr bool is_steady = LLTIMER::ClockT::is_steady;
+
     static void start() {
         s_timer.start();
     }
+    // <chrono> like interface that includes the testMode hack.
+    static time_point now() {
+        if (s_testMode) {
+            return s_testElapsed;
+        }
+        return time_point(s_timer.elapsed().toStdDuration());
+    }
 
     // Returns a Duration representing time elapsed since Mixxx started up.
     static mixxx::Duration elapsed() {
         if (s_testMode) {
-            return s_testElapsed;
+            return Duration::fromStdDuration(s_testElapsed.time_since_epoch());
         }
         return s_timer.elapsed();
     }
@@ -28,9 +45,9 @@ class Time {
     static void setTestMode(bool test) {
         s_testMode = test;
     }
-
-    static void setTestElapsedTime(mixxx::Duration elapsed) {
-        s_testElapsed = elapsed;
+    template<class Rep, class Period>
+    static void addTestTime(std::chrono::duration<Rep, Period> elapsed) {
+        s_testElapsed += elapsed;
     }
 
   private:
@@ -38,7 +55,12 @@ class Time {
 
     // For testing timing related behavior.
     static bool s_testMode;
-    static mixxx::Duration s_testElapsed;
+    static time_point s_testElapsed;
 };
 
+// Working around incomplete C++20 support on MacOS
+#if defined(__cpp_lib_chrono) && __cpp_lib_chrono >= 201907L
+static_assert(std::chrono::is_clock_v<Time>);
+#endif
+
 } // namespace mixxx
diff --git a/src/waveform/renderers/allshader/waveformrendererstem.cpp b/src/waveform/renderers/allshader/waveformrendererstem.cpp
index a1d03a6337..8e02a71e98 100644
--- a/src/waveform/renderers/allshader/waveformrendererstem.cpp
+++ b/src/waveform/renderers/allshader/waveformrendererstem.cpp
@@ -4,6 +4,7 @@
 #include <QImage>
 #include <QOpenGLTexture>
 
+#include "engine/engine.h"
 #include "track/track.h"
 #include "util/math.h"
 #include "waveform/renderers/allshader/matrixforwidgetgeometry.h"
@@ -11,10 +12,6 @@
 #include "waveform/renderers/waveformwidgetrenderer.h"
 #include "waveform/waveform.h"
 
-namespace {
-constexpr int kMaxSupportedStems = 4;
-} // anonymous namespace
-
 namespace allshader {
 
 WaveformRendererStem::WaveformRendererStem(
@@ -33,16 +30,16 @@ void WaveformRendererStem::initializeGL() {
     m_shader.init();
     m_textureShader.init();
     auto group = m_pEQEnabled->getKey().group;
-    for (int stemIdx = 1; stemIdx <= kMaxSupportedStems; stemIdx++) {
+    for (int stemIdx = 1; stemIdx <= mixxx::kMaxSupportedStems; stemIdx++) {
         DEBUG_ASSERT(group.endsWith("]"));
         QString stemGroup = QStringLiteral("%1Stem%2]")
                                     .arg(group.left(group.size() - 1),
                                             QString::number(stemIdx));
         m_pStemGain.emplace_back(
                 std::make_unique<ControlProxy>(stemGroup,
-                        QStringLiteral("volume").arg(stemIdx)));
+                        QStringLiteral("volume")));
         m_pStemMute.emplace_back(std::make_unique<ControlProxy>(
-                stemGroup, QStringLiteral("mute").arg(stemIdx)));
+                stemGroup, QStringLiteral("mute")));
     }
 }
 
@@ -79,6 +76,8 @@ void WaveformRendererStem::paintGL() {
         return;
     }
 
+    uint selectedStem = m_waveformRenderer->getSelectedStem();
+
     const float devicePixelRatio = m_waveformRenderer->getDevicePixelRatio();
     const int length = static_cast<int>(m_waveformRenderer->getLength() * devicePixelRatio);
 
@@ -125,7 +124,7 @@ void WaveformRendererStem::paintGL() {
     const double maxSamplingRange = visualIncrementPerPixel / 2.0;
 
     for (int visualIdx = 0; visualIdx < length; ++visualIdx) {
-        for (int stemIdx = 0; stemIdx < 4; stemIdx++) {
+        for (int stemIdx = 0; stemIdx < mixxx::kMaxSupportedStems; stemIdx++) {
             // Stem is drawn twice with different opacity level, this allow to
             // see the maximum signal by transparency
             for (int layerIdx = 0; layerIdx < 2; layerIdx++) {
@@ -160,7 +159,9 @@ void WaveformRendererStem::paintGL() {
 
                 // Apply the gains
                 if (layerIdx) {
-                    max *= m_pStemMute[stemIdx]->toBool()
+                    max *= m_pStemMute[stemIdx]->toBool() ||
+                                    (selectedStem &&
+                                            selectedStem != static_cast<uint>(stemIdx) + 1)
                             ? 0.f
                             : static_cast<float>(m_pStemGain[stemIdx]->get());
                 }
diff --git a/src/waveform/renderers/waveformwidgetrenderer.cpp b/src/waveform/renderers/waveformwidgetrenderer.cpp
index ffefe5d6d4..1b28006a93 100644
--- a/src/waveform/renderers/waveformwidgetrenderer.cpp
+++ b/src/waveform/renderers/waveformwidgetrenderer.cpp
@@ -21,6 +21,9 @@ constexpr int kDefaultDimBrightThreshold = 127;
 
 WaveformWidgetRenderer::WaveformWidgetRenderer(const QString& group)
         : m_group(group),
+#ifdef __STEM__
+          m_selectedStem(0),
+#endif
           m_orientation(Qt::Horizontal),
           m_dimBrightThreshold(kDefaultDimBrightThreshold),
           m_height(-1),
@@ -416,6 +419,12 @@ void WaveformWidgetRenderer::setDisplayBeatGridAlpha(int alpha) {
     m_alphaBeatGrid = alpha;
 }
 
+#ifdef __STEM__
+void WaveformWidgetRenderer::selectStem(uint stemIdx) {
+    m_selectedStem = stemIdx;
+}
+#endif
+
 void WaveformWidgetRenderer::setTrack(TrackPointer track) {
     m_pTrack = track;
     //used to postpone first display until track sample is actually available
diff --git a/src/waveform/renderers/waveformwidgetrenderer.h b/src/waveform/renderers/waveformwidgetrenderer.h
index 47cd21b67a..86a6bf860b 100644
--- a/src/waveform/renderers/waveformwidgetrenderer.h
+++ b/src/waveform/renderers/waveformwidgetrenderer.h
@@ -46,6 +46,12 @@ class WaveformWidgetRenderer {
         return m_pTrack;
     }
 
+#ifdef __STEM__
+    uint getSelectedStem() const {
+        return m_selectedStem;
+    }
+#endif
+
     bool isSlipActive() const {
         return m_pos[::WaveformRendererAbstract::Play] != m_pos[::WaveformRendererAbstract::Slip];
     }
@@ -170,6 +176,9 @@ class WaveformWidgetRenderer {
         return renderer;
     }
 
+#ifdef __STEM__
+    void selectStem(uint stemIdx);
+#endif
     void setTrack(TrackPointer track);
     void setMarkPositions(const QList<WaveformMarkOnScreen>& markPositions) {
         m_markPositions = markPositions;
@@ -195,6 +204,9 @@ class WaveformWidgetRenderer {
   protected:
     const QString m_group;
     TrackPointer m_pTrack;
+#ifdef __STEM__
+    uint m_selectedStem;
+#endif
     QList<WaveformRendererAbstract*> m_rendererStack;
     Qt::Orientation m_orientation;
     int m_dimBrightThreshold;
diff --git a/src/waveform/waveformwidgetfactory.h b/src/waveform/waveformwidgetfactory.h
index 17dadc391f..703ecad904 100644
--- a/src/waveform/waveformwidgetfactory.h
+++ b/src/waveform/waveformwidgetfactory.h
@@ -197,7 +197,9 @@ class WaveformWidgetFactory : public QObject, public Singleton<WaveformWidgetFac
     void setOverviewNormalized(bool normalize);
     int isOverviewNormalized() const { return m_overviewNormalized;}
 
-    const QVector<WaveformWidgetAbstractHandle> getAvailableTypes() const { return m_waveformWidgetHandles;}
+    const QVector<WaveformWidgetAbstractHandle>& getAvailableTypes() const {
+        return m_waveformWidgetHandles;
+    }
     void getAvailableVSyncTypes(QList<QPair<int, QString>>* list);
     void destroyWidgets();
 
diff --git a/src/widget/wbasewidget.h b/src/widget/wbasewidget.h
index 78923dea6c..aca5d52a4c 100644
--- a/src/widget/wbasewidget.h
+++ b/src/widget/wbasewidget.h
@@ -63,7 +63,7 @@ class WBaseWidget {
 
   protected:
     // Whenever a connected control is changed, onConnectedControlChanged is
-    // called. This allows the widget implementor to respond to the change and
+    // called. This allows the widget implementer to respond to the change and
     // gives them both the parameter and its corresponding value.
     virtual void onConnectedControlChanged(double dParameter, double dValue) {
         Q_UNUSED(dParameter);
diff --git a/src/widget/weffectchainpresetselector.cpp b/src/widget/weffectchainpresetselector.cpp
index 3b93b290a5..0218b7470a 100644
--- a/src/widget/weffectchainpresetselector.cpp
+++ b/src/widget/weffectchainpresetselector.cpp
@@ -139,7 +139,7 @@ void WEffectChainPresetSelector::paintEvent(QPaintEvent* e) {
     // Quick effect controls in the mixer.
     QStylePainter painter(this);
     QStyleOptionComboBox comboStyle;
-    // Inititialize the style and draw the frame, down-arrow etc.
+    // Initialize the style and draw the frame, down-arrow etc.
     // Note: using 'comboStyle.initFrom(this)' and 'painter.drawComplexControl(...)
     // here would not paint the hover style of the down arrow.
     initStyleOption(&comboStyle);
diff --git a/src/widget/wlibrarysidebar.cpp b/src/widget/wlibrarysidebar.cpp
index 663006112c..0a92052d13 100644
--- a/src/widget/wlibrarysidebar.cpp
+++ b/src/widget/wlibrarysidebar.cpp
@@ -240,17 +240,10 @@ void WLibrarySidebar::keyPressEvent(QKeyEvent* event) {
     // item is not focused, require second press to perform the desired action.
 
     SidebarModel* sidebarModel = qobject_cast<SidebarModel*>(model());
-    QModelIndexList selectedIndices = selectionModel()->selectedRows();
-    if (sidebarModel && !selectedIndices.isEmpty()) {
-        QModelIndex index = selectedIndices.at(0);
-        if (event->matches(QKeySequence::Delete) || event->key() == Qt::Key_Backspace) {
-            sidebarModel->clear(index);
-            return;
-        }
-        if (event->matches(QKeySequence::Paste)) {
-            sidebarModel->paste(index);
-            return;
-        }
+    QModelIndex selIndex = selectedIndex();
+    if (sidebarModel && selIndex.isValid() && event->matches(QKeySequence::Paste)) {
+        sidebarModel->paste(selIndex);
+        return;
     }
 
     focusSelectedIndex();
diff --git a/src/widget/wlibrarytableview.h b/src/widget/wlibrarytableview.h
index 6a63ecc2de..c4ac76fc1d 100644
--- a/src/widget/wlibrarytableview.h
+++ b/src/widget/wlibrarytableview.h
@@ -56,7 +56,12 @@ class WLibraryTableView : public QTableView, public virtual LibraryView {
 
   signals:
     void loadTrack(TrackPointer pTrack);
-    void loadTrackToPlayer(TrackPointer pTrack, const QString& group, bool play = false);
+    void loadTrackToPlayer(TrackPointer pTrack,
+            const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play = false);
     void trackSelected(TrackPointer pTrack);
     void onlyCachedCoverArt(bool);
     void scrollValueChanged(int);
diff --git a/src/widget/wpushbutton.cpp b/src/widget/wpushbutton.cpp
index e6e54ccfbe..5cc3c18820 100644
--- a/src/widget/wpushbutton.cpp
+++ b/src/widget/wpushbutton.cpp
@@ -17,13 +17,14 @@
 
 WPushButton::WPushButton(QWidget* pParent)
         : WWidget(pParent),
-          m_leftButtonMode(ControlPushButton::PUSH),
-          m_rightButtonMode(ControlPushButton::PUSH) {
+          m_leftButtonMode(mixxx::control::ButtonMode::Push),
+          m_rightButtonMode(mixxx::control::ButtonMode::Push) {
     setStates(0);
 }
 
-WPushButton::WPushButton(QWidget* pParent, ControlPushButton::ButtonMode leftButtonMode,
-                         ControlPushButton::ButtonMode rightButtonMode)
+WPushButton::WPushButton(QWidget* pParent,
+        mixxx::control::ButtonMode leftButtonMode,
+        mixxx::control::ButtonMode rightButtonMode)
         : WWidget(pParent),
           m_leftButtonMode(leftButtonMode),
           m_rightButtonMode(rightButtonMode) {
@@ -141,7 +142,7 @@ void WPushButton::setup(const QDomNode& node, const SkinContext& context) {
 
     if (leftConnection) {
         bool leftClickForcePush = context.selectBool(node, "LeftClickIsPushButton", false);
-        m_leftButtonMode = ControlPushButton::PUSH;
+        m_leftButtonMode = mixxx::control::ButtonMode::Push;
         if (!leftClickForcePush) {
             const ConfigKey& configKey = leftConnection->getKey();
             ControlPushButton* p = qobject_cast<ControlPushButton*>(
@@ -153,22 +154,22 @@ void WPushButton::setup(const QDomNode& node, const SkinContext& context) {
         if (leftConnection->getEmitOption() &
                 ControlParameterWidgetConnection::EMIT_DEFAULT) {
             switch (m_leftButtonMode) {
-                case ControlPushButton::PUSH:
-                case ControlPushButton::POWERWINDOW:
+            case mixxx::control::ButtonMode::Push:
+            case mixxx::control::ButtonMode::PowerWindow:
                 leftConnection->setEmitOption(
                         ControlParameterWidgetConnection::EMIT_ON_PRESS_AND_RELEASE);
                 break;
-                case ControlPushButton::LONGPRESSLATCHING:
-                    leftConnection->setEmitOption(
-                            ControlParameterWidgetConnection::EMIT_ON_PRESS_AND_RELEASE);
-                    m_pLongPressLatching = std::make_unique<LongPressLatching>(this);
-                    break;
-                case ControlPushButton::TOGGLE:
-                case ControlPushButton::TRIGGER:
-                default:
-                    leftConnection->setEmitOption(
-                            ControlParameterWidgetConnection::EMIT_ON_PRESS);
-                    break;
+            case mixxx::control::ButtonMode::LongPressLatching:
+                leftConnection->setEmitOption(
+                        ControlParameterWidgetConnection::EMIT_ON_PRESS_AND_RELEASE);
+                m_pLongPressLatching = std::make_unique<LongPressLatching>(this);
+                break;
+            case mixxx::control::ButtonMode::Toggle:
+            case mixxx::control::ButtonMode::Trigger:
+            default:
+                leftConnection->setEmitOption(
+                        ControlParameterWidgetConnection::EMIT_ON_PRESS);
+                break;
             }
         }
         if (leftConnection->getDirectionOption() &
@@ -188,20 +189,20 @@ void WPushButton::setup(const QDomNode& node, const SkinContext& context) {
     if (!m_rightConnections.isEmpty()) {
         ControlParameterWidgetConnection* rightConnection = m_rightConnections.at(0);
         bool rightClickForcePush = context.selectBool(node, "RightClickIsPushButton", false);
-        m_rightButtonMode = ControlPushButton::PUSH;
+        m_rightButtonMode = mixxx::control::ButtonMode::Push;
         if (!rightClickForcePush) {
             const ConfigKey configKey = rightConnection->getKey();
             ControlPushButton* p = qobject_cast<ControlPushButton*>(
                     ControlObject::getControl(configKey));
             if (p) {
                 m_rightButtonMode = p->getButtonMode();
-                if (m_rightButtonMode != ControlPushButton::PUSH &&
-                        m_rightButtonMode != ControlPushButton::TOGGLE &&
-                        m_rightButtonMode != ControlPushButton::TRIGGER) {
+                if (m_rightButtonMode != mixxx::control::ButtonMode::Push &&
+                        m_rightButtonMode != mixxx::control::ButtonMode::Toggle &&
+                        m_rightButtonMode != mixxx::control::ButtonMode::Trigger) {
                     SKIN_WARNING(node,
                             context,
                             "WPushButton::setup: Connecting a Pushbutton not "
-                            "in PUSH, TRIGGER or TOGGLE mode is not "
+                            "in Push, Trigger or Toggle mode is not "
                             "implemented\n Please consider to set "
                             "<RightClickIsPushButton>true</"
                             "RightClickIsPushButton>");
@@ -211,18 +212,18 @@ void WPushButton::setup(const QDomNode& node, const SkinContext& context) {
         if (rightConnection->getEmitOption() &
                 ControlParameterWidgetConnection::EMIT_DEFAULT) {
             switch (m_rightButtonMode) {
-                case ControlPushButton::PUSH:
-                case ControlPushButton::POWERWINDOW:
-                case ControlPushButton::LONGPRESSLATCHING:
-                    rightConnection->setEmitOption(
-                            ControlParameterWidgetConnection::EMIT_ON_PRESS_AND_RELEASE);
-                    break;
-                case ControlPushButton::TOGGLE:
-                case ControlPushButton::TRIGGER:
-                default:
-                    rightConnection->setEmitOption(
-                            ControlParameterWidgetConnection::EMIT_ON_PRESS);
-                    break;
+            case mixxx::control::ButtonMode::Push:
+            case mixxx::control::ButtonMode::PowerWindow:
+            case mixxx::control::ButtonMode::LongPressLatching:
+                rightConnection->setEmitOption(
+                        ControlParameterWidgetConnection::EMIT_ON_PRESS_AND_RELEASE);
+                break;
+            case mixxx::control::ButtonMode::Toggle:
+            case mixxx::control::ButtonMode::Trigger:
+            default:
+                rightConnection->setEmitOption(
+                        ControlParameterWidgetConnection::EMIT_ON_PRESS);
+                break;
             }
         }
         if (rightConnection->getDirectionOption() &
@@ -373,8 +374,7 @@ void WPushButton::mousePressEvent(QMouseEvent * e) {
     const bool leftClick = e->button() == Qt::LeftButton;
     const bool rightClick = e->button() == Qt::RightButton;
 
-    if (m_leftButtonMode == ControlPushButton::POWERWINDOW
-            && m_iNoStates == 2) {
+    if (m_leftButtonMode == mixxx::control::ButtonMode::PowerWindow && m_iNoStates == 2) {
         if (leftClick) {
             m_clickTimer.setSingleShot(true);
             m_clickTimer.start(ControlPushButtonBehavior::kPowerWindowTimeMillis);
@@ -384,15 +384,15 @@ void WPushButton::mousePressEvent(QMouseEvent * e) {
             setControlParameterLeftDown(emitValue);
             restyleAndRepaint();
         }
-        // discharge right clicks here, because is used for latching in POWERWINDOW mode
+        // discharge right clicks here, because is used for latching in PowerWindow mode
         return;
     }
 
     if (rightClick) {
         // This is the secondary button function always a Pushbutton
         // due the lack of visual feedback we do not allow a toggle function
-        if (m_rightButtonMode == ControlPushButton::PUSH ||
-                m_rightButtonMode == ControlPushButton::TRIGGER ||
+        if (m_rightButtonMode == mixxx::control::ButtonMode::Push ||
+                m_rightButtonMode == mixxx::control::ButtonMode::Trigger ||
                 m_iNoStates == 1) {
             m_bPressed = true;
             setControlParameterRightDown(1.0);
@@ -404,8 +404,7 @@ void WPushButton::mousePressEvent(QMouseEvent * e) {
     if (leftClick) {
         m_bPressed = true;
         double emitValue;
-        if (m_leftButtonMode == ControlPushButton::PUSH
-                || m_iNoStates == 1) {
+        if (m_leftButtonMode == mixxx::control::ButtonMode::Push || m_iNoStates == 1) {
             // This is either forced to behave like a push button on left-click
             // or this is a push button.
             emitValue = 1.0;
@@ -416,7 +415,7 @@ void WPushButton::mousePressEvent(QMouseEvent * e) {
             if (!util_isnan(emitValue) && m_iNoStates > 0) {
                 emitValue = static_cast<int>(emitValue + 1.0) % m_iNoStates;
             }
-            if (m_leftButtonMode == ControlPushButton::LONGPRESSLATCHING) {
+            if (m_leftButtonMode == mixxx::control::ButtonMode::LongPressLatching) {
                 m_clickTimer.setSingleShot(true);
                 m_clickTimer.start(ControlPushButtonBehavior::kLongPressLatchingTimeMillis);
                 if (oldValue == 0.0 && m_pLongPressLatching) {
@@ -480,8 +479,7 @@ void WPushButton::mouseReleaseEvent(QMouseEvent * e) {
         m_pLongPressLatching->stop();
     }
 
-    if (m_leftButtonMode == ControlPushButton::POWERWINDOW
-            && m_iNoStates == 2) {
+    if (m_leftButtonMode == mixxx::control::ButtonMode::PowerWindow && m_iNoStates == 2) {
         if (leftClick) {
             const bool rightButtonDown = QApplication::mouseButtons() & Qt::RightButton;
             if (m_bPressed && !m_clickTimer.isActive() && !rightButtonDown) {
@@ -502,8 +500,7 @@ void WPushButton::mouseReleaseEvent(QMouseEvent * e) {
         // due the leak of visual feedback we do not allow a toggle
         // function
         m_bPressed = false;
-        if (m_rightButtonMode == ControlPushButton::PUSH
-                || m_iNoStates == 1) {
+        if (m_rightButtonMode == mixxx::control::ButtonMode::Push || m_iNoStates == 1) {
             setControlParameterRightUp(0.0);
         }
         restyleAndRepaint();
@@ -513,13 +510,12 @@ void WPushButton::mouseReleaseEvent(QMouseEvent * e) {
     if (leftClick) {
         m_bPressed = false;
         double emitValue = getControlParameterLeft();
-        if (m_leftButtonMode == ControlPushButton::PUSH
-                || m_iNoStates == 1) {
+        if (m_leftButtonMode == mixxx::control::ButtonMode::Push || m_iNoStates == 1) {
             // This is a Pushbutton
             emitValue = 0.0;
         } else {
-            if (m_leftButtonMode == ControlPushButton::LONGPRESSLATCHING
-                    && m_clickTimer.isActive() && emitValue >= 1.0) {
+            if (m_leftButtonMode == mixxx::control::ButtonMode::LongPressLatching &&
+                    m_clickTimer.isActive() && emitValue >= 1.0) {
                 // revert toggle if button is released too early
                 if (!util_isnan(emitValue) && m_iNoStates > 0) {
                     emitValue = static_cast<int>(emitValue - 1.0) % m_iNoStates;
diff --git a/src/widget/wpushbutton.h b/src/widget/wpushbutton.h
index a1970cf02a..1e4ff3ddf0 100644
--- a/src/widget/wpushbutton.h
+++ b/src/widget/wpushbutton.h
@@ -19,8 +19,9 @@ class WPushButton : public WWidget {
   public:
     explicit WPushButton(QWidget* pParent = nullptr);
     // Used by WPushButtonTest.
-    WPushButton(QWidget* pParent, ControlPushButton::ButtonMode leftButtonMode,
-                ControlPushButton::ButtonMode rightButtonMode);
+    WPushButton(QWidget* pParent,
+            mixxx::control::ButtonMode leftButtonMode,
+            mixxx::control::ButtonMode rightButtonMode);
 
     Q_PROPERTY(bool pressed READ isPressed);
 
@@ -109,8 +110,8 @@ class WPushButton : public WWidget {
     PaintablePointer m_pPixmapBack;
 
     // short click toggle button long click push button
-    ControlPushButton::ButtonMode m_leftButtonMode;
-    ControlPushButton::ButtonMode m_rightButtonMode;
+    mixxx::control::ButtonMode m_leftButtonMode;
+    mixxx::control::ButtonMode m_rightButtonMode;
     QTimer m_clickTimer;
     QVector<int> m_align;
 
diff --git a/src/widget/wstemcontrol.cpp b/src/widget/wstemcontrol.cpp
new file mode 100644
index 0000000000..dafdf7b818
--- /dev/null
+++ b/src/widget/wstemcontrol.cpp
@@ -0,0 +1,177 @@
+#include "widget/wstemcontrol.h"
+
+#include <QCoreApplication>
+#include <QDragEnterEvent>
+#include <QEvent>
+#include <QHBoxLayout>
+#include <QLabel>
+#include <QMainWindow>
+#include <QPalette>
+#include <QPushButton>
+#include <QStyleOption>
+#include <QVBoxLayout>
+
+#include "control/controlproxy.h"
+#include "moc_wstemcontrol.cpp"
+#include "track/track.h"
+#include "util/math.h"
+#include "util/parented_ptr.h"
+#include "widget/controlwidgetconnection.h"
+#include "widget/wglwidget.h"
+#include "widget/wknob.h"
+#include "widget/wknobcomposed.h"
+#include "widget/wlabel.h"
+
+namespace {
+// FIXME(XXX) this is a workaround to ensure that that knob keep the aspect
+// ratio as defined in its maxSize. This needs to be moved an implemented by the
+// component directly
+void ensureWidgetRatio(QLayout* layout) {
+    for (int i = 0; i < layout->count(); i++) {
+        auto pWidget = layout->itemAt(i)->widget();
+        if (!qobject_cast<WKnobComposed*>(pWidget) && !qobject_cast<WKnob*>(pWidget)) {
+            continue;
+        }
+        float ratio = static_cast<float>(pWidget->maximumWidth()) /
+                static_cast<float>(pWidget->maximumHeight());
+        int maxSize = qMin(pWidget->width(), pWidget->height());
+        QSize currentSize = pWidget->size();
+        QSize newSize;
+
+        if (ratio > 1) {
+            newSize = QSize(maxSize, static_cast<int>(maxSize / ratio));
+        } else {
+            newSize = QSize(static_cast<int>(maxSize * ratio), maxSize);
+        }
+
+        if (currentSize == newSize) {
+            continue;
+        }
+
+        pWidget->resize(newSize);
+        layout->itemAt(i)->invalidate();
+    }
+}
+
+QString getGroupForStem(const QString& deckGroup, int stemIdx) {
+    DEBUG_ASSERT(deckGroup.endsWith("]"));
+    return QStringLiteral("%1Stem%2]")
+            .arg(deckGroup.left(deckGroup.size() - 1),
+                    QString::number(stemIdx + 1));
+}
+} // namespace
+
+WStemControlBox::WStemControlBox(
+        const QString& group, QWidget* parent)
+        : WWidgetGroup(parent), m_group(group), m_hasStem(false), m_displayed(true) {
+    auto pLayout = make_parented<QVBoxLayout>(this);
+    pLayout->setSpacing(0);
+    pLayout->setContentsMargins(0, 0, 0, 0);
+    setLayout(pLayout);
+
+    setObjectName("StemControlBox");
+
+    setWindowFlag(Qt::Sheet);
+    setWindowFlag(Qt::FramelessWindowHint);
+    setWindowFlag(Qt::NoDropShadowWindowHint);
+    setWindowFlag(Qt::WindowDoesNotAcceptFocus);
+
+    // setWindowFlag(Qt::BypassWindowManagerHint); // Make it fly over?
+
+    setAttribute(Qt::WA_OpaquePaintEvent);
+    setAttribute(Qt::WA_NoSystemBackground);
+    setAttribute(Qt::WA_TranslucentBackground);
+    setFocusPolicy(Qt::NoFocus);
+}
+
+void WStemControlBox::setDisplayed(bool displayed) {
+    m_displayed = displayed;
+    emit displayedChanged(m_displayed);
+}
+
+void WStemControlBox::slotSelectStem(uint stemIdx) {
+    m_selectedStem = stemIdx;
+}
+
+void WStemControlBox::slotTrackLoaded(TrackPointer track) {
+    m_hasStem = false;
+    if (!track) {
+        return;
+    }
+
+    auto stemInfo = track->getStemInfo();
+
+    if (stemInfo.isEmpty()) {
+        return;
+    }
+
+    m_hasStem = true;
+
+    int stemCount = qMin(m_stemControl.size(),
+            static_cast<std::size_t>(stemInfo.size()));
+    for (int stemIdx = 0; stemIdx < stemCount; stemIdx++) {
+        m_stemControl[stemIdx]->setStem(stemInfo[stemIdx]);
+    }
+}
+
+void WStemControlBox::addControl(QWidget* control) {
+    auto pWidget = std::make_unique<WStemControl>(control, this, m_group, m_stemControl.size());
+    layout()->addWidget(pWidget.get());
+    m_stemControl.push_back(std::move(pWidget));
+}
+
+WStemControl::WStemControl(QWidget* widgetGroup, QWidget* parent, const QString& group, int stemIdx)
+        : WWidget(parent),
+          m_widget(widgetGroup),
+          m_mutedCo(std::make_unique<ControlProxy>(
+                  getGroupForStem(group, stemIdx), QStringLiteral("mute"))) {
+    auto pLayout = make_parented<QHBoxLayout>(this);
+    pLayout->setSpacing(0);
+    pLayout->setContentsMargins(0, 0, 0, 0);
+
+    m_widget->setParent(this);
+    setMinimumSize(m_widget->minimumSize());
+    setMaximumSize(m_widget->maximumSize());
+    setSizePolicy(m_widget->sizePolicy());
+
+    layout()->addWidget(m_widget);
+
+    m_mutedCo->connectValueChanged(this, [this](double value) {
+        m_stemColor.setAlphaF(value == 1 ? 0.5 : 1.0);
+        updateStyle();
+    });
+}
+
+void WStemControl::setStem(const StemInfo& stemInfo) {
+    m_stemColor = stemInfo.getColor();
+    m_stemColor.setAlphaF(m_mutedCo->get() == 1 ? 0.5 : 1.0);
+    updateStyle();
+    WLabel* label = findChild<WLabel*>("stem_label");
+    VERIFY_OR_DEBUG_ASSERT(label) {
+        qWarning() << "Cannot find the Label \"stem_label\" in the Stem control";
+        return;
+    }
+    label->setText(stemInfo.getLabel());
+}
+
+void WStemControl::updateStyle() {
+    setStyleSheet(QString("WStemControl { background-color: %1; }")
+                          .arg(m_stemColor.name(QColor::HexArgb)));
+}
+
+void WStemControl::resizeEvent(QResizeEvent* e) {
+    WWidget::resizeEvent(e);
+    ensureWidgetRatio(m_widget->layout());
+}
+
+void WStemControl::showEvent(QShowEvent* e) {
+    WWidget::showEvent(e);
+    ensureWidgetRatio(m_widget->layout());
+}
+
+void WStemControl::paintEvent(QPaintEvent*) {
+    QStyleOption opt;
+    opt.initFrom(this);
+    QPainter p(this);
+    style()->drawPrimitive(QStyle::PE_Widget, &opt, &p, this);
+}
diff --git a/src/widget/wstemcontrol.h b/src/widget/wstemcontrol.h
new file mode 100644
index 0000000000..1a0a08f505
--- /dev/null
+++ b/src/widget/wstemcontrol.h
@@ -0,0 +1,67 @@
+#pragma once
+
+#include <vector>
+
+#include "track/steminfo.h"
+#include "track/track_decl.h"
+#include "util/parented_ptr.h"
+#include "waveform/renderers/waveformmark.h"
+#include "widget/trackdroptarget.h"
+#include "widget/wwidget.h"
+#include "widget/wwidgetgroup.h"
+
+class ControlProxy;
+class WKnob;
+class WStemControl;
+
+class WStemControlBox : public WWidgetGroup {
+    Q_OBJECT
+  public:
+    Q_PROPERTY(bool displayed READ isDisplayed WRITE setDisplayed NOTIFY displayedChanged);
+
+    WStemControlBox(
+            const QString& group, QWidget* parent = nullptr);
+
+    void addControl(QWidget* control);
+    bool shouldShow() const {
+        return m_hasStem && m_displayed && m_selectedStem == mixxx::kNoStemSelectedIdx;
+    }
+
+    bool isDisplayed() const {
+        return m_displayed;
+    }
+
+    void setDisplayed(bool displayed);
+  public slots:
+    void slotTrackLoaded(TrackPointer track);
+    void slotSelectStem(uint stemIdx);
+
+  signals:
+    void displayedChanged(bool);
+
+  private:
+    std::vector<std::unique_ptr<WStemControl>> m_stemControl;
+    QString m_group;
+    bool m_hasStem;
+    uint m_selectedStem;
+    bool m_displayed;
+};
+
+class WStemControl : public WWidget {
+    Q_OBJECT
+  public:
+    WStemControl(QWidget* widgetGroup, QWidget* parent, const QString& group, int stemIdx);
+    void setStem(const StemInfo& stemInfo);
+
+  protected:
+    void paintEvent(QPaintEvent*) override;
+    void resizeEvent(QResizeEvent*) override;
+    void showEvent(QShowEvent*) override;
+
+  private:
+    QWidget* m_widget;
+    QColor m_stemColor;
+    std::unique_ptr<ControlProxy> m_mutedCo;
+
+    void updateStyle();
+};
diff --git a/src/widget/wtrackmenu.cpp b/src/widget/wtrackmenu.cpp
index f9df992a90..77e7ef9863 100644
--- a/src/widget/wtrackmenu.cpp
+++ b/src/widget/wtrackmenu.cpp
@@ -293,13 +293,6 @@ void WTrackMenu::createActions() {
         connect(m_pAutoDJReplaceAct, &QAction::triggered, this, &WTrackMenu::slotAddToAutoDJReplace);
     }
 
-    if (featureIsEnabled(Feature::LoadTo)) {
-        m_pAddToPreviewDeck = new QAction(tr("Preview Deck"), m_pLoadToMenu);
-        // currently there is only one preview deck so just map it here.
-        QString previewDeckGroup = PlayerManager::groupForPreviewDeck(0);
-        connect(m_pAddToPreviewDeck, &QAction::triggered, this, [this, previewDeckGroup] { loadSelectionToGroup(previewDeckGroup); });
-    }
-
     if (featureIsEnabled(Feature::Remove)) {
         // Keyboard shortcuts are set here just to have them displayed in the menu.
         // Actual keypress is handled in WTrackTableView::keyPressEvent().
@@ -582,14 +575,6 @@ void WTrackMenu::setupActions() {
     }
 
     if (featureIsEnabled(Feature::LoadTo)) {
-        m_pLoadToMenu->addMenu(m_pDeckMenu);
-
-        m_pLoadToMenu->addMenu(m_pSamplerMenu);
-
-        if (m_pNumPreviewDecks.get() > 0.0) {
-            m_pLoadToMenu->addAction(m_pAddToPreviewDeck);
-        }
-
         addMenu(m_pLoadToMenu);
         addSeparator();
     }
@@ -890,11 +875,59 @@ CoverInfo WTrackMenu::getCoverInfoOfLastTrack() const {
     }
 }
 
+void WTrackMenu::generateTrackLoadMenu(const QString& group,
+        const QString& label,
+        TrackPointer pTrack,
+        QMenu* pParentMenu,
+        bool enabled) {
+#ifdef __STEM__
+    if (pTrack && !pTrack->hasStreamInfoFromSource()) {
+        // The stem metadata are loaded on stream info refresh, which occurs
+        // when the file gets loaded for the time in the session. If there is no
+        // stream info from source, when open the file, which lead to loading
+        // the stem manifest.
+        mixxx::AudioSource::OpenParams config;
+        config.setChannelCount(mixxx::kMaxEngineChannelInputCount);
+        SoundSourceProxy(pTrack).openAudioSource(config);
+    }
+    if (enabled && pTrack && pTrack->hasStem()) {
+        QMenu* pStemMenu = new QMenu(label, pParentMenu);
+
+        QAction* pAction = new QAction(tr("Load as a stem deck"), this);
+        pStemMenu->addAction(pAction);
+        connect(pAction, &QAction::triggered, this, [this, group] { loadSelectionToGroup(group); });
+        pStemMenu->addSeparator();
+
+        auto stemInfo = pTrack->getStemInfo();
+        for (uint stemIdx = 0; stemIdx < mixxx::kMaxSupportedStems; stemIdx++) {
+            QAction* pAction =
+                    new QAction(tr("Load the \"%1\" stem")
+                                        .arg(stemInfo.at(stemIdx).getLabel()),
+                            this);
+            pStemMenu->addAction(pAction);
+            connect(pAction, &QAction::triggered, this, [this, group, stemIdx] {
+                loadSelectionToGroup(group, stemIdx + 1);
+            });
+        }
+        pParentMenu->addMenu(pStemMenu);
+    } else {
+#endif
+        QAction* pAction = new QAction(label, this);
+        pAction->setEnabled(enabled);
+        pParentMenu->addAction(pAction);
+        connect(pAction, &QAction::triggered, this, [this, group] { loadSelectionToGroup(group); });
+#ifdef __STEM__
+    }
+#endif
+}
+
 void WTrackMenu::updateMenus() {
     if (isEmpty()) {
         return;
     }
 
+    m_pLoadToMenu->clear();
+
     // Gray out some stuff if multiple songs were selected.
     const bool singleTrackSelected = getTrackCount() == 1;
 
@@ -927,12 +960,15 @@ void WTrackMenu::updateMenus() {
                 bool deckEnabled =
                         (!deckPlaying || allowLoadTrackIntoPlayingDeck) &&
                         singleTrackSelected;
-                QAction* pAction = new QAction(tr("Deck %1").arg(i), this);
-                pAction->setEnabled(deckEnabled);
-                m_pDeckMenu->addAction(pAction);
-                connect(pAction, &QAction::triggered, this, [this, deckGroup] { loadSelectionToGroup(deckGroup); });
+                auto pTrack = getFirstTrackPointer();
+                generateTrackLoadMenu(deckGroup,
+                        tr("Deck %1").arg(i),
+                        getFirstTrackPointer(),
+                        m_pDeckMenu,
+                        deckEnabled);
             }
         }
+        m_pLoadToMenu->addMenu(m_pDeckMenu);
 
         int iNumSamplers = static_cast<int>(m_pNumSamplers.get());
         const int maxSamplersPerMenu = 16;
@@ -940,6 +976,7 @@ void WTrackMenu::updateMenus() {
             m_pSamplerMenu->clear();
             QMenu* pMenu = m_pSamplerMenu;
             int samplersInMenu = 0;
+            TrackPointer pTrack = getFirstTrackPointer();
             for (int i = 1; i <= iNumSamplers; ++i) {
                 if (samplersInMenu == maxSamplersPerMenu) {
                     samplersInMenu = 0;
@@ -954,17 +991,23 @@ void WTrackMenu::updateMenus() {
                 bool samplerPlaying = ControlObject::get(
                                               ConfigKey(samplerGroup, "play")) > 0.0;
                 bool samplerEnabled = !samplerPlaying && singleTrackSelected;
-                QAction* pAction = new QAction(samplerTrString(i), pMenu);
-                pAction->setEnabled(samplerEnabled);
-                pMenu->addAction(pAction);
-                connect(pAction,
-                        &QAction::triggered,
-                        this,
-                        [this, samplerGroup] {
-                            loadSelectionToGroup(samplerGroup);
-                        });
+
+                generateTrackLoadMenu(samplerGroup,
+                        samplerTrString(i),
+                        pTrack,
+                        pMenu,
+                        samplerEnabled);
             }
         }
+        m_pLoadToMenu->addMenu(m_pSamplerMenu);
+
+        if (m_pNumPreviewDecks.get() > 0.0) {
+            // currently there is only one preview deck so just map it here.
+            generateTrackLoadMenu(PlayerManager::groupForPreviewDeck(0),
+                    tr("Preview Deck"),
+                    getFirstTrackPointer(),
+                    m_pLoadToMenu);
+        }
     }
 
     if (featureIsEnabled(Feature::Playlist)) {
@@ -1821,7 +1864,11 @@ void WTrackMenu::slotColorPicked(const mixxx::RgbColor::optional_t& color) {
     hide();
 }
 
-void WTrackMenu::loadSelectionToGroup(const QString& group, bool play) {
+void WTrackMenu::loadSelectionToGroup(const QString& group,
+#ifdef __STEM__
+        uint stemIdx,
+#endif
+        bool play) {
     TrackPointer pTrack = getFirstTrackPointer();
     if (!pTrack) {
         return;
@@ -1841,7 +1888,11 @@ void WTrackMenu::loadSelectionToGroup(const QString& group, bool play) {
 
     // TODO: load track from this class without depending on
     // external slot to load track
-    emit loadTrackToPlayer(pTrack, group, play);
+    emit loadTrackToPlayer(pTrack, group,
+#ifdef __STEM__
+            stemIdx,
+#endif
+            play);
 }
 
 namespace {
diff --git a/src/widget/wtrackmenu.h b/src/widget/wtrackmenu.h
index 23b0efda0b..a19c4668e6 100644
--- a/src/widget/wtrackmenu.h
+++ b/src/widget/wtrackmenu.h
@@ -110,7 +110,12 @@ class WTrackMenu : public QMenu {
     const QString getDeckGroup() const;
 
   signals:
-    void loadTrackToPlayer(TrackPointer pTrack, const QString& group, bool play = false);
+    void loadTrackToPlayer(TrackPointer pTrack,
+            const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play = false);
     void trackMenuVisible(bool visible);
     void saveCurrentViewState();
     void restoreCurrentViewStateOrIndex();
@@ -214,6 +219,12 @@ class WTrackMenu : public QMenu {
     void setupActions();
     void updateMenus();
 
+    void generateTrackLoadMenu(const QString& group,
+            const QString& label,
+            TrackPointer pTrack,
+            QMenu* pParentMenu,
+            bool enabled = true);
+
     bool featureIsEnabled(Feature flag) const;
 
     void addSelectionToPlaylist(int iPlaylistId);
@@ -225,7 +236,11 @@ class WTrackMenu : public QMenu {
     void clearBeats();
     void lockBpm(bool lock);
 
-    void loadSelectionToGroup(const QString& group, bool play = false);
+    void loadSelectionToGroup(const QString& group,
+#ifdef __STEM__
+            uint stemIdx = mixxx::kNoStemSelectedIdx,
+#endif
+            bool play = false);
     void clearTrackSelection();
 
     std::pair<bool, bool> getTrackBpmLockStates() const;
@@ -279,9 +294,6 @@ class WTrackMenu : public QMenu {
     // Save Track Metadata Action:
     QAction* m_pExportMetadataAct{};
 
-    // Load Track to PreviewDeck
-    QAction* m_pAddToPreviewDeck{};
-
     // Send to Auto-DJ Action
     QAction* m_pAutoDJBottomAct{};
     QAction* m_pAutoDJTopAct{};
diff --git a/src/widget/wtracktableview.cpp b/src/widget/wtracktableview.cpp
index b939dd2c83..0b4f8a950f 100644
--- a/src/widget/wtracktableview.cpp
+++ b/src/widget/wtracktableview.cpp
@@ -1247,7 +1247,11 @@ void WTrackTableView::activateSelectedTrack() {
     slotMouseDoubleClicked(indices.at(0));
 }
 
-void WTrackTableView::loadSelectedTrackToGroup(const QString& group, bool play) {
+void WTrackTableView::loadSelectedTrackToGroup(const QString& group,
+#ifdef __STEM__
+        uint stemIdx,
+#endif
+        bool play) {
     auto indices = getSelectedRows();
     if (indices.isEmpty()) {
         return;
@@ -1281,7 +1285,12 @@ void WTrackTableView::loadSelectedTrackToGroup(const QString& group, bool play)
     auto* trackModel = getTrackModel();
     TrackPointer pTrack;
     if (trackModel && (pTrack = trackModel->getTrack(index))) {
+#ifdef __STEM__
+        DEBUG_ASSERT(!stemIdx || pTrack->hasStem());
+        emit loadTrackToPlayer(pTrack, group, stemIdx, play);
+#else
         emit loadTrackToPlayer(pTrack, group, play);
+#endif
     }
 }
 
diff --git a/src/widget/wtracktableview.h b/src/widget/wtracktableview.h
index 7ec93a3ae6..19fc5306d2 100644
--- a/src/widget/wtracktableview.h
+++ b/src/widget/wtracktableview.h
@@ -38,7 +38,11 @@ class WTrackTableView : public WLibraryTableView {
     void keyPressEvent(QKeyEvent* event) override;
     void resizeEvent(QResizeEvent* event) override;
     void activateSelectedTrack();
-    void loadSelectedTrackToGroup(const QString& group, bool play);
+    void loadSelectedTrackToGroup(const QString& group,
+#ifdef __STEM__
+            uint stemIdx,
+#endif
+            bool play);
     void assignNextTrackColor() override;
     void assignPreviousTrackColor() override;
     TrackModel::SortColumnId getColumnIdFromCurrentIndex() override;
diff --git a/src/widget/wwaveformviewer.cpp b/src/widget/wwaveformviewer.cpp
index 22629abc88..1cbdc678f5 100644
--- a/src/widget/wwaveformviewer.cpp
+++ b/src/widget/wwaveformviewer.cpp
@@ -11,6 +11,19 @@
 #include "waveform/widgets/waveformwidgetabstract.h"
 #include "widget/wcuemenupopup.h"
 #include "widget/wglwidget.h"
+#ifdef __STEM__
+#include <QGuiApplication>
+
+#include "mixxxmainwindow.h"
+#include "widget/wstemcontrol.h"
+
+namespace {
+const QString kStemControlLeftAlignment = QStringLiteral("left");
+const QString kStemControlRightAlignment = QStringLiteral("right");
+const QString kStemControlElementName = QStringLiteral("StemControl");
+const QString kStemElementName = QStringLiteral("Stem");
+} // anonymous namespace
+#endif
 
 WWaveformViewer::WWaveformViewer(
         const QString& group,
@@ -23,7 +36,13 @@ WWaveformViewer::WWaveformViewer(
           m_bScratching(false),
           m_bBending(false),
           m_pCueMenuPopup(make_parented<WCueMenuPopup>(pConfig, this)),
-          m_waveformWidget(nullptr) {
+          m_waveformWidget(nullptr)
+#ifdef __STEM__
+          ,
+          m_stemControlWidget(std::make_unique<WStemControlBox>(group, this))
+#endif
+
+{
     setMouseTracking(true);
     setAcceptDrops(true);
     m_pZoom = new ControlProxy(group, "waveform_zoom", this, ControlFlag::NoAssertIfMissing);
@@ -39,11 +58,50 @@ WWaveformViewer::WWaveformViewer(
     m_pPassthroughEnabled = make_parented<ControlProxy>(group, "passthrough", this);
     m_pPassthroughEnabled->connectValueChanged(this, &WWaveformViewer::passthroughChanged);
 
+#ifdef __STEM__
+    connect(m_stemControlWidget.get(), &WStemControlBox::displayedChanged, this, [this](bool) {
+        adjustStemControl();
+    });
+    // TODO alternative to MixxxMainWindow becoming a singleton
+    // for (QWindow* window: QGuiApplication::allWindows()) {
+    //     if (window->objectName() == "MixxxMainWindowClassWindow") {
+    //         m_mainWindow = window;
+    //         m_mainWindow->installEventFilter(this);
+    //         break;
+    //     }
+    // }
+    m_mainWindow = MixxxMainWindow::instance();
+    if (m_mainWindow) {
+        m_mainWindow->installEventFilter(this);
+    }
+#endif
+
     setAttribute(Qt::WA_OpaquePaintEvent);
     setFocusPolicy(Qt::NoFocus);
 }
 
+#ifdef __STEM__
+bool WWaveformViewer::eventFilter(QObject* obj, QEvent* event) {
+    switch (event->type()) {
+    case QEvent::Move:
+    case QEvent::WindowStateChange:
+    case QEvent::Resize:
+        adjustStemControl();
+        break;
+
+    default:
+        break;
+    }
+    return WWidget::eventFilter(obj, event);
+}
+#endif
+
 WWaveformViewer::~WWaveformViewer() {
+#ifdef __STEM__
+    if (m_mainWindow) {
+        m_mainWindow->removeEventFilter(this);
+    }
+#endif
     //qDebug() << "~WWaveformViewer";
 }
 
@@ -52,8 +110,50 @@ void WWaveformViewer::setup(const QDomNode& node, const SkinContext& context) {
         m_waveformWidget->setup(node, context);
         m_dimBrightThreshold = m_waveformWidget->getDimBrightThreshold();
     }
+
+#ifdef __STEM__
+    QDomElement child = node.firstChildElement(kStemControlElementName);
+    if (!child.isNull()) {
+        QString alignment = child.attribute("alignment", kStemControlLeftAlignment).toLower();
+        if (alignment == kStemControlRightAlignment) {
+            m_stemControlWidgetAlignment = WWaveformViewer::StemControlAlignment::Right;
+        } else {
+            m_stemControlWidgetAlignment = WWaveformViewer::StemControlAlignment::Left;
+        }
+    }
+#endif
 }
 
+#ifdef __STEM__
+void WWaveformViewer::adjustStemControl() {
+    m_stemControlWidget->resize(m_stemControlWidget->width(), height());
+
+    if (m_stemControlWidget->height() > height() ||
+            !m_stemControlWidget->shouldShow() ||
+            (m_mainWindow && !m_mainWindow->isVisible())) {
+        m_stemControlWidget->hide();
+    } else if (m_stemControlWidget->shouldShow() &&
+            (m_mainWindow && m_mainWindow->isVisible())) {
+        m_stemControlWidget->show();
+        for (QWindow* window : QGuiApplication::allWindows()) {
+            if (window->objectName() == "DlgPreferencesDlgWindow" && window->isActive()) {
+                window->raise();
+                break;
+            }
+        }
+    }
+
+    switch (m_stemControlWidgetAlignment) {
+    case WWaveformViewer::StemControlAlignment::Right:
+        m_stemControlWidget->move(mapToGlobal(QPoint(width() - m_stemControlWidget->width(), 0)));
+        break;
+    case WWaveformViewer::StemControlAlignment::Left:
+        m_stemControlWidget->move(mapToGlobal(QPoint(0, 0)));
+        break;
+    }
+}
+#endif
+
 void WWaveformViewer::resizeEvent(QResizeEvent* event) {
     Q_UNUSED(event);
     if (m_waveformWidget) {
@@ -63,6 +163,9 @@ void WWaveformViewer::resizeEvent(QResizeEvent* event) {
         // a QWidget, though that will be called directly.
         m_waveformWidget->resize(width(), height());
     }
+#ifdef __STEM__
+    adjustStemControl();
+#endif
 }
 
 void WWaveformViewer::showEvent(QShowEvent* event) {
@@ -76,6 +179,13 @@ void WWaveformViewer::showEvent(QShowEvent* event) {
     }
 }
 
+void WWaveformViewer::hideEvent(QHideEvent* event) {
+    Q_UNUSED(event);
+#ifdef __STEM__
+    adjustStemControl();
+#endif
+}
+
 void WWaveformViewer::mousePressEvent(QMouseEvent* event) {
     if (!m_waveformWidget) {
         return;
@@ -225,6 +335,23 @@ void WWaveformViewer::slotTrackLoaded(TrackPointer track) {
     if (m_waveformWidget) {
         m_waveformWidget->setTrack(track);
     }
+#ifdef __STEM__
+    m_stemControlWidget->slotTrackLoaded(track);
+    adjustStemControl();
+#endif
+}
+
+#ifdef __STEM__
+void WWaveformViewer::slotSelectStem(uint stemIdx) {
+    if (m_waveformWidget) {
+        m_waveformWidget->selectStem(stemIdx);
+    }
+    m_stemControlWidget->slotSelectStem(stemIdx);
+}
+#endif
+
+void WWaveformViewer::slotTrackUnloaded(TrackPointer pOldTrack) {
+    slotLoadingTrack(pOldTrack, TrackPointer());
 }
 
 void WWaveformViewer::slotLoadingTrack(TrackPointer pNewTrack, TrackPointer pOldTrack) {
@@ -233,6 +360,10 @@ void WWaveformViewer::slotLoadingTrack(TrackPointer pNewTrack, TrackPointer pOld
     if (m_waveformWidget) {
         m_waveformWidget->setTrack(TrackPointer());
     }
+#ifdef __STEM__
+    m_stemControlWidget->slotTrackLoaded(TrackPointer());
+    adjustStemControl();
+#endif
 }
 
 void WWaveformViewer::onZoomChange(double zoom) {
diff --git a/src/widget/wwaveformviewer.h b/src/widget/wwaveformviewer.h
index eead266f54..0a820579fb 100644
--- a/src/widget/wwaveformviewer.h
+++ b/src/widget/wwaveformviewer.h
@@ -8,6 +8,7 @@
 
 class ControlProxy;
 class WaveformWidgetAbstract;
+class WStemControlBox;
 class WCueMenuPopup;
 class QDomNode;
 class SkinContext;
@@ -15,6 +16,11 @@ class SkinContext;
 class WWaveformViewer : public WWidget, public TrackDropTarget {
     Q_OBJECT
   public:
+    enum StemControlAlignment {
+        Left = Qt::AlignLeft,
+        Right = Qt::AlignRight
+    };
+
     WWaveformViewer(
             const QString& group,
             UserSettingsPointer pConfig,
@@ -36,6 +42,14 @@ class WWaveformViewer : public WWidget, public TrackDropTarget {
     void mouseReleaseEvent(QMouseEvent * /*unused*/) override;
     void leaveEvent(QEvent* /*unused*/) override;
 
+#ifdef __STEM__
+    // Used by LegacySkinParser to inject the stem toolbox if defined
+    WStemControlBox* stemControlWidget() const {
+        return m_stemControlWidget.get();
+    }
+
+    bool eventFilter(QObject* object, QEvent* event) override;
+#endif
   signals:
     void trackDropped(const QString& filename, const QString& group) override;
     void cloneDeck(const QString& sourceGroup, const QString& targetGroup) override;
@@ -43,10 +57,15 @@ class WWaveformViewer : public WWidget, public TrackDropTarget {
 
   public slots:
     void slotTrackLoaded(TrackPointer track);
+    void slotTrackUnloaded(TrackPointer pOldTrack);
     void slotLoadingTrack(TrackPointer pNewTrack, TrackPointer pOldTrack);
+#ifdef __STEM__
+    void slotSelectStem(uint stemIdx);
+#endif
 
   protected:
     void showEvent(QShowEvent* event) override;
+    void hideEvent(QHideEvent* event) override;
     void resizeEvent(QResizeEvent *event) override;
     void wheelEvent(QWheelEvent *event) override;
 
@@ -80,6 +99,14 @@ class WWaveformViewer : public WWidget, public TrackDropTarget {
     WaveformMarkPointer m_pHoveredMark;
 
     WaveformWidgetAbstract* m_waveformWidget;
+#ifdef __STEM__
+    std::unique_ptr<WStemControlBox> m_stemControlWidget;
+    QWidget* m_mainWindow;
+
+    void adjustStemControl();
+#endif
+
+    StemControlAlignment m_stemControlWidgetAlignment;
 
     int m_dimBrightThreshold;
 
diff --git a/tools/README b/tools/README
index 875579939d..def2a3d404 100644
--- a/tools/README
+++ b/tools/README
@@ -17,6 +17,6 @@ sudo modprobe uhid
 #    `-DPRODUCT_ID=0x1234` to customize product ID
 #    `-DDEVICE_NAME="My Device"` to customize the device name
 cd build && gcc ../tools/dummy_hid_device.c -lhidapi-hidraw -o dummy_hid_device && sudo ./dummy_hid_device
-# Allow the created hidraw device to be accesssed by the user. You may also set the write udev rules. Finally, you can also run Mixxx as root, but that's not recommended.
+# Allow the created hidraw device to be accessed by the user. You may also set the write udev rules. Finally, you can also run Mixxx as root, but that's not recommended.
 sudo chown "$USER" "$(ls -1t /dev/hidraw* | head -n 1)"
 ```
diff --git a/tools/qsscheck.py b/tools/qsscheck.py
index 43c2cf67dd..d570549f9e 100755
--- a/tools/qsscheck.py
+++ b/tools/qsscheck.py
@@ -18,6 +18,12 @@ RE_XML_OBJNAME_SETVAR = re.compile(
 )
 RE_CLASSNAME = re.compile(r"^[A-Z]\w+$")
 RE_OBJNAME_VARTAG = re.compile(r"<.*>")
+# Some object names set via variables in
+# src/library/tabledelegates/checkboxdelegate.cpp
+CPP_OBJNAMES = [
+    "LibraryBPMButton",
+    "LibraryPlayedCheckbox",
+]
 
 # List of Qt Widgets, generated with:
 #     python -c 'import inspect, from PyQt5 import QtWidgets;
@@ -230,7 +236,7 @@ def get_skins(path):
 def get_global_names(mixxx_path):
     """Returns 2 sets with all class and object names in the Mixxx codebase."""
     classnames = set()
-    objectnames = set()
+    objectnames = set(CPP_OBJNAMES)
     for root, dirs, fnames in os.walk(os.path.join(mixxx_path, "src")):
         for fname in fnames:
             ext = os.path.splitext(fname)[1]
